From 6a1223e664356c8f6f4b0823c7e17fab8ea93009 Mon Sep 17 00:00:00 2001
From: stlifey <stlifey@gmail.com>
Date: Wed, 14 Dec 2011 14:03:04 +0800
Subject: [PATCH] XT701

---
 Documentation/kernel-parameters.txt                |    2 -
 NOTICE                                             |  355 +++
 .../configs/ext_config/feature/cup2touch.config    |    2 +
 arch/arm/configs/mapphone_defconfig                |   10 +-
 arch/arm/configs/sholest_cu_defconfig              | 2172 ++++++++++++++++
 arch/arm/mach-omap2/Kconfig                        |   16 +-
 arch/arm/mach-omap2/Makefile                       |   18 +-
 arch/arm/mach-omap2/Makefile.boot                  |   10 +-
 arch/arm/mach-omap2/board-mapphone-camera.c        |   16 -
 arch/arm/mach-omap2/board-mapphone-keypad.c        |   29 -
 arch/arm/mach-omap2/board-mapphone-spi.c           |    6 +
 arch/arm/mach-omap2/board-mapphone.c               |   22 +
 arch/arm/mach-omap2/board-sholest-camera.c         |  598 +++++
 arch/arm/mach-omap2/board-sholest-flash.c          |  120 +
 arch/arm/mach-omap2/board-sholest-gpio.c           |  304 +++
 arch/arm/mach-omap2/board-sholest-hsmmc.c          |  350 +++
 arch/arm/mach-omap2/board-sholest-keypad.c         |  158 ++
 arch/arm/mach-omap2/board-sholest-mdtv.c           |  109 +
 arch/arm/mach-omap2/board-sholest-mmcprobe.c       |   78 +
 arch/arm/mach-omap2/board-sholest-padconf.c        | 1837 ++++++++++++++
 arch/arm/mach-omap2/board-sholest-panel.c          |  202 ++
 arch/arm/mach-omap2/board-sholest-sensors.c        |  382 +++
 arch/arm/mach-omap2/board-sholest-spi.c            |  698 ++++++
 arch/arm/mach-omap2/board-sholest-wifi.c           |  202 ++
 arch/arm/mach-omap2/board-sholest.c                | 1820 ++++++++++++++
 arch/arm/mach-omap2/mux.c                          |   68 +-
 arch/arm/plat-omap/dma.c                           |    7 +
 arch/arm/plat-omap/include/dspbridge/dbdefs.h      |    1 +
 arch/arm/plat-omap/include/dspbridge/mem.h         |    2 +-
 arch/arm/plat-omap/include/mach/board-mapphone.h   |    3 +
 .../plat-omap/include/mach/board-sholest-padconf.h |  135 +
 arch/arm/plat-omap/include/mach/board-sholest.h    |   73 +
 arch/arm/plat-omap/include/mach/dt_path.h          |   33 +
 arch/arm/plat-omap/include/mach/hardware.h         |    5 +
 arch/arm/plat-omap/include/mach/mux.h              |   39 +-
 arch/arm/plat-omap/include/mach/oldisp_user.h      |   10 +
 drivers/dsp/bridge/rmgr/proc.c                     |    5 +-
 drivers/dsp/bridge/services/mem.c                  |    6 +-
 drivers/gpu/pvr/omap3430/sysutils_linux.c          |    2 +
 drivers/i2c/chips/Kconfig                          |    8 +
 drivers/i2c/chips/Makefile                         |    3 +-
 drivers/i2c/chips/lp3907_i2c.c                     |  529 ++++
 drivers/input/misc/Kconfig                         |    8 +
 drivers/input/misc/gpio_matrix.c                   |    2 +
 drivers/input/touchscreen/qtouch_obp_ts.c          |  220 ++-
 drivers/leds/Kconfig                               |   32 +
 drivers/leds/Makefile                              |    3 +
 drivers/leds/led-lm3530.c                          |  304 +++-
 drivers/leds/leds-bd7885.c                         |  661 +++++
 drivers/leds/leds-bu9847.c                         |  297 +++
 drivers/leds/leds-ld-cpcap-afled.c                 |  174 ++
 drivers/leds/leds-ld-cpcap-disp.c                  |   41 +-
 drivers/leds/leds-ld-cpcap-rgb.c                   |   29 +-
 drivers/media/dvb/siano/Kconfig                    |   73 +-
 drivers/media/dvb/siano/Makefile                   |   42 +-
 drivers/media/dvb/siano/compat.h                   |  238 ++
 drivers/media/dvb/siano/sms-cards.c                |  329 ++-
 drivers/media/dvb/siano/sms-cards.h                |   72 +-
 drivers/media/dvb/siano/smschar.c                  |  683 +++++
 drivers/media/dvb/siano/smscharioctl.h             |   58 +
 drivers/media/dvb/siano/smscoreapi.c               | 1255 +++++++---
 drivers/media/dvb/siano/smscoreapi.h               |  721 ++++--
 drivers/media/dvb/siano/smsdbg_prn.h               |   57 +
 drivers/media/dvb/siano/smsdvb.c                   |  423 +++-
 drivers/media/dvb/siano/smsendian.c                |  100 +
 drivers/media/dvb/siano/smsendian.h                |   32 +
 drivers/media/dvb/siano/smsir.c                    |  301 +++
 drivers/media/dvb/siano/smsir.h                    |   93 +
 drivers/media/dvb/siano/smsspicommon.c             |  384 +++
 drivers/media/dvb/siano/smsspicommon.h             |   96 +
 drivers/media/dvb/siano/smsspilog.c                |  506 ++++
 drivers/media/dvb/siano/smsspiphy.h                |   39 +
 drivers/media/dvb/siano/smsspiphy_omap34xx.c       |  374 +++
 drivers/media/dvb/siano/smsusb.c                   |   45 -
 drivers/media/video/Kconfig                        |   30 +
 drivers/media/video/Makefile                       |    3 +
 drivers/media/video/hp3a/hp3a.h                    |    1 +
 drivers/media/video/hp3a/hp3a_af.c                 |   28 +-
 drivers/media/video/hp3a/hp3a_common.h             |   18 +-
 drivers/media/video/hp3a/hp3a_ext.c                |   19 +-
 drivers/media/video/hp3a/hp3a_hardpipe.c           |    4 +-
 drivers/media/video/hp3a/hp3a_histogram.c          |   67 +-
 drivers/media/video/hp3a/hp3a_ioctl.c              |   54 +-
 drivers/media/video/hp3a/hp3a_queue.c              |    5 +-
 drivers/media/video/hp3a/hp3a_raw.c                |   34 +-
 drivers/media/video/hp3a/hp3a_stats.c              |  214 ++-
 drivers/media/video/hplens.c                       |   56 +-
 drivers/media/video/mipi_dli.c                     |  185 ++
 drivers/media/video/oldisp/isp.c                   |  759 ++++---
 drivers/media/video/oldisp/isp.h                   |    7 +-
 drivers/media/video/oldisp/ispccdc.c               |  166 +-
 drivers/media/video/oldisp/ispccdc.h               |    3 +
 drivers/media/video/oldisp/ispcsi2.c               |   16 +
 drivers/media/video/oldisp/ispcsi2.h               |    6 +
 drivers/media/video/oldisp/ispmmu.c                |   12 +-
 drivers/media/video/oldisp/ispmmu.h                |    2 +-
 drivers/media/video/oldisp/isppreview.c            |   73 +-
 drivers/media/video/oldisp/ispreg.h                |    7 +-
 drivers/media/video/oldisp/ispresizer.c            |  214 +-
 drivers/media/video/oldomap34xxcam.c               |   48 +-
 drivers/media/video/oldomap34xxcam.h               |    2 +
 drivers/media/video/omap-vout/omapvout-dss.c       |   59 +-
 drivers/media/video/omap-vout/omapvout-dss.h       |    6 +
 drivers/media/video/omap-vout/omapvout.c           |  120 +-
 drivers/media/video/ov8810.c                       | 2606 ++++++++++++++++++++
 drivers/media/video/ov8810.h                       |  985 ++++++++
 drivers/media/video/tda19989.c                     |  489 ++++
 drivers/media/video/tda19989.h                     |   30 +
 drivers/media/video/videobuf-core.c                |    1 +
 drivers/mfd/cpcap-3mm5.c                           |   70 +-
 drivers/mfd/cpcap-core.c                           |   27 +-
 drivers/mfd/cpcap-regacc.c                         |   30 +
 drivers/misc/akm8973_akmd.c                        |    4 +-
 drivers/misc/lis331dlh.c                           |    3 +-
 drivers/mmc/core/debugfs.c                         |    1 +
 drivers/sim/sim_core.c                             |    2 +-
 drivers/spi/spi.c                                  |   31 +
 drivers/usb/gadget/f_acm.c                         |   36 +-
 drivers/usb/gadget/f_mass_storage.c                |    2 +-
 drivers/usb/gadget/f_mtp.c                         |   27 +-
 drivers/usb/gadget/mot_android.c                   |   17 +-
 drivers/usb/gadget/u_serial.c                      |   17 +
 drivers/usb/gadget/u_serial.h                      |    3 +
 drivers/video/omap2/displays/Kconfig               |    6 +
 drivers/video/omap2/displays/Makefile              |    2 +
 drivers/video/omap2/displays/panel-hdtv.c          |  185 ++
 drivers/video/omap2/displays/panel-sholes.c        |  542 ++++-
 drivers/video/omap2/displays/panel-sholes.h        |   13 +
 drivers/video/omap2/dss/display.c                  |   10 +
 drivers/video/omap2/dss/dsi.c                      |  239 ++-
 drivers/video/omap2/dss/manager.c                  |    5 +
 drivers/video/omap2/dss/overlay.c                  |   36 +
 drivers/video/omap2/omapfb/omapfb-sysfs.c          |    6 +
 drivers/watchdog/omap_wdt.c                        |   10 +-
 fs/yaffs2/yaffs_guts.h                             |    4 +-
 include/linux/i2c/lp3907_i2c.h                     |   41 +
 include/linux/led-lm3530.h                         |    5 +
 include/linux/leds-bd7885.h                        |  122 +
 include/linux/leds-bu9847.h                        |   67 +
 include/linux/leds-ld-cpcap.h                      |   37 +-
 include/linux/mipi_dli.h                           |   18 +
 include/linux/panel-suppliers.h                    |   26 +
 include/linux/qtouch_obp_ts.h                      |  161 ++-
 include/linux/soundcard.h                          |    3 +
 include/linux/spi/cpcap.h                          |   12 +
 include/linux/spi/spi.h                            |    4 +
 kernel/power/main.c                                |   13 +
 net/bluetooth/hci_conn.c                           |    2 +-
 net/ipv4/tcp_output.c                              |   34 +
 sound/oss/moto_audio/cpcap_audio_driver.c          |  225 ++-
 sound/oss/moto_audio/cpcap_audio_driver.h          |    2 +-
 sound/oss/moto_audio/omap34xx_audio_driver.c       |   42 +-
 sound/oss/omap34xx_audio_driver.c                  |   12 -
 153 files changed, 24560 insertions(+), 2060 deletions(-)
 create mode 100644 NOTICE
 create mode 100644 arch/arm/configs/ext_config/feature/cup2touch.config
 mode change 100755 => 100644 arch/arm/configs/mapphone_defconfig
 create mode 100644 arch/arm/configs/sholest_cu_defconfig
 mode change 100755 => 100644 arch/arm/mach-omap2/board-sholes.c
 create mode 100644 arch/arm/mach-omap2/board-sholest-camera.c
 create mode 100644 arch/arm/mach-omap2/board-sholest-flash.c
 create mode 100644 arch/arm/mach-omap2/board-sholest-gpio.c
 create mode 100644 arch/arm/mach-omap2/board-sholest-hsmmc.c
 create mode 100644 arch/arm/mach-omap2/board-sholest-keypad.c
 create mode 100644 arch/arm/mach-omap2/board-sholest-mdtv.c
 create mode 100644 arch/arm/mach-omap2/board-sholest-mmcprobe.c
 create mode 100644 arch/arm/mach-omap2/board-sholest-padconf.c
 create mode 100644 arch/arm/mach-omap2/board-sholest-panel.c
 create mode 100644 arch/arm/mach-omap2/board-sholest-sensors.c
 create mode 100644 arch/arm/mach-omap2/board-sholest-spi.c
 create mode 100644 arch/arm/mach-omap2/board-sholest-wifi.c
 create mode 100644 arch/arm/mach-omap2/board-sholest.c
 mode change 100755 => 100644 arch/arm/mach-omap2/serial.c
 mode change 100755 => 100644 arch/arm/plat-omap/dma.c
 create mode 100644 arch/arm/plat-omap/include/mach/board-sholest-padconf.h
 create mode 100644 arch/arm/plat-omap/include/mach/board-sholest.h
 mode change 100755 => 100644 arch/arm/plat-omap/include/mach/dma.h
 mode change 100755 => 100644 drivers/gpu/pvr/linkage.h
 mode change 100755 => 100644 drivers/gpu/pvr/lists.c
 mode change 100755 => 100644 drivers/gpu/pvr/lists.h
 mode change 100755 => 100644 drivers/gpu/pvr/lock.h
 mode change 100755 => 100644 drivers/gpu/pvr/mem_debug.c
 mode change 100755 => 100644 drivers/gpu/pvr/omaplfb/omaplfb.h
 mode change 100755 => 100644 drivers/gpu/pvr/omaplfb/omaplfb_displayclass.c
 mode change 100755 => 100644 drivers/gpu/pvr/omaplfb/omaplfb_linux.c
 mode change 100755 => 100644 drivers/gpu/pvr/pdump_osfunc.h
 mode change 100755 => 100644 drivers/gpu/pvr/sgx_mkif_km.h
 create mode 100644 drivers/i2c/chips/lp3907_i2c.c
 mode change 100755 => 100644 drivers/leds/led-cpcap-lm3554.c
 mode change 100755 => 100644 drivers/leds/led-lm3530.c
 create mode 100644 drivers/leds/leds-bd7885.c
 create mode 100644 drivers/leds/leds-bu9847.c
 create mode 100644 drivers/leds/leds-ld-cpcap-afled.c
 mode change 100755 => 100644 drivers/leds/leds-ld-cpcap-disp.c
 mode change 100755 => 100644 drivers/leds/leds-ld-cpcap-kpad.c
 mode change 100755 => 100644 drivers/leds/leds-ld-cpcap-rgb.c
 create mode 100644 drivers/media/dvb/siano/compat.h
 create mode 100644 drivers/media/dvb/siano/smschar.c
 create mode 100644 drivers/media/dvb/siano/smscharioctl.h
 create mode 100644 drivers/media/dvb/siano/smsdbg_prn.h
 create mode 100644 drivers/media/dvb/siano/smsendian.c
 create mode 100644 drivers/media/dvb/siano/smsendian.h
 create mode 100644 drivers/media/dvb/siano/smsir.c
 create mode 100644 drivers/media/dvb/siano/smsir.h
 create mode 100644 drivers/media/dvb/siano/smsspicommon.c
 create mode 100644 drivers/media/dvb/siano/smsspicommon.h
 create mode 100644 drivers/media/dvb/siano/smsspilog.c
 create mode 100644 drivers/media/dvb/siano/smsspiphy.h
 create mode 100644 drivers/media/dvb/siano/smsspiphy_omap34xx.c
 create mode 100644 drivers/media/video/mipi_dli.c
 create mode 100644 drivers/media/video/ov8810.c
 create mode 100644 drivers/media/video/ov8810.h
 create mode 100644 drivers/media/video/tda19989.c
 create mode 100644 drivers/media/video/tda19989.h
 mode change 100755 => 100644 drivers/misc/akm8973_akmd.c
 mode change 100755 => 100644 drivers/misc/modem_pm_driver/Kconfig
 mode change 100755 => 100644 drivers/misc/modem_pm_driver/Makefile
 mode change 100755 => 100644 drivers/misc/modem_pm_driver/modem_pm_driver.h
 mode change 100755 => 100644 drivers/misc/modem_pm_driver/modem_pm_driver_main.c
 mode change 100755 => 100644 drivers/misc/netmux/LICENSE
 mode change 100755 => 100644 drivers/misc/netmux/channelconfig.c
 mode change 100755 => 100644 drivers/misc/netmux/config.c
 mode change 100755 => 100644 drivers/misc/netmux/config.h
 mode change 100755 => 100644 drivers/misc/netmux/debug.c
 mode change 100755 => 100644 drivers/misc/netmux/debug.h
 mode change 100755 => 100644 drivers/misc/netmux/debug_client.h
 mode change 100755 => 100644 drivers/misc/netmux/debug_host.h
 mode change 100755 => 100644 drivers/misc/netmux/direct.c
 mode change 100755 => 100644 drivers/misc/netmux/direct.h
 mode change 100755 => 100644 drivers/misc/netmux/errorcodes.h
 mode change 100755 => 100644 drivers/misc/netmux/interface.c
 mode change 100755 => 100644 drivers/misc/netmux/interface.h
 mode change 100755 => 100644 drivers/misc/netmux/main.c
 mode change 100755 => 100644 drivers/misc/netmux/mux.c
 mode change 100755 => 100644 drivers/misc/netmux/mux.h
 mode change 100755 => 100644 drivers/misc/netmux/network.c
 mode change 100755 => 100644 drivers/misc/netmux/network.h
 mode change 100755 => 100644 drivers/misc/netmux/packet.h
 mode change 100755 => 100644 drivers/misc/netmux/protocol.c
 mode change 100755 => 100644 drivers/misc/netmux/protocol.h
 mode change 100755 => 100644 drivers/misc/netmux/register.c
 mode change 100755 => 100644 drivers/misc/netmux/register.h
 mode change 100755 => 100644 drivers/misc/netmux/shared/ldprotocol.h
 mode change 100755 => 100644 drivers/misc/netmux/tty.c
 mode change 100755 => 100644 drivers/misc/netmux/tty.h
 mode change 100755 => 100644 drivers/misc/netmux/types.h
 mode change 100755 => 100644 drivers/misc/netmux/utility.c
 mode change 100755 => 100644 drivers/misc/netmux/utility.h
 mode change 100755 => 100644 drivers/misc/netmux/utility_client.h
 mode change 100755 => 100644 drivers/misc/netmux/utility_host.h
 mode change 100755 => 100644 drivers/misc/netmux_linkdriver/LICENSE
 mode change 100755 => 100644 drivers/misc/netmux_linkdriver/usb/Makefile
 mode change 100755 => 100644 drivers/misc/ts27010mux/Kconfig
 mode change 100755 => 100644 drivers/misc/ts27010mux/Makefile
 mode change 100755 => 100644 drivers/misc/ts27010mux/ts0710.h
 mode change 100755 => 100644 drivers/misc/ts27010mux/ts27010_mux.c
 mode change 100755 => 100644 drivers/misc/ts27010mux/ts27010_mux.h
 mode change 100755 => 100644 drivers/misc/vib-gpio.c
 mode change 100755 => 100644 drivers/misc/vib-omap-pwm.c
 mode change 100755 => 100644 drivers/mmc/core/sdio_io.c
 mode change 100755 => 100644 drivers/mtd/nand/omap2.c
 create mode 100644 drivers/video/omap2/displays/panel-hdtv.c
 create mode 100644 drivers/video/omap2/displays/panel-sholes.h
 mode change 100755 => 100644 include/linux/akm8973_akmd.h
 mode change 100755 => 100644 include/linux/earlysuspend.h
 create mode 100644 include/linux/i2c/lp3907_i2c.h
 mode change 100755 => 100644 include/linux/led-cpcap-lm3554.h
 mode change 100755 => 100644 include/linux/led-lm3530.h
 create mode 100644 include/linux/leds-bd7885.h
 create mode 100644 include/linux/leds-bu9847.h
 mode change 100755 => 100644 include/linux/leds-ld-cpcap.h
 create mode 100644 include/linux/mipi_dli.h
 mode change 100755 => 100644 include/linux/mmc/sdio_func.h
 create mode 100644 include/linux/panel-suppliers.h
 mode change 100755 => 100644 include/linux/quickwakeup.h
 mode change 100755 => 100644 include/linux/sfh7743.h
 mode change 100755 => 100644 include/linux/wakelock.h
 mode change 100755 => 100644 sound/oss/cpcap_audio_driver.c
 mode change 100755 => 100644 sound/oss/moto_audio/cpcap_audio_driver.c
 mode change 100755 => 100644 sound/oss/moto_audio/omap34xx_audio_driver.c
 mode change 100755 => 100644 sound/oss/omap34xx_audio_driver.c

diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index f607528..54f21a5 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -2483,8 +2483,6 @@ and is between 256 and 4096 characters. It is defined in the file
 
 	wdt=		[WDT] Watchdog
 			See Documentation/watchdog/wdt.txt.
-	wdt_stat=        [WDT] Watchdog
-	        Turn off wdt option.
 
 	xd=		[HW,XT] Original XT pre-IDE (RLL encoded) disks.
 	xd_geo=		See header of drivers/block/xd.c.
diff --git a/NOTICE b/NOTICE
new file mode 100644
index 0000000..c87c902
--- /dev/null
+++ b/NOTICE
@@ -0,0 +1,355 @@
+   NOTE! This copyright does *not* cover user programs that use kernel
+ services by normal system calls - this is merely considered normal use
+ of the kernel, and does *not* fall under the heading of "derived work".
+ Also note that the GPL below is copyrighted by the Free Software
+ Foundation, but the instance of code that it refers to (the Linux
+ kernel) is copyrighted by me and others who actually wrote it.
+
+ Also note that the only valid version of the GPL as far as the kernel
+ is concerned is _this_ particular version of the license (ie v2, not
+ v2.2 or v3.x or whatever), unless explicitly otherwise stated.
+
+                        Linus Torvalds
+
+----------------------------------------
+
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff --git a/arch/arm/configs/ext_config/feature/cup2touch.config b/arch/arm/configs/ext_config/feature/cup2touch.config
new file mode 100644
index 0000000..3775748
--- /dev/null
+++ b/arch/arm/configs/ext_config/feature/cup2touch.config
@@ -0,0 +1,2 @@
+# CU p2 touch need special treatment for its differenct IC
+CONFIG_CUP2TOUCH=y
diff --git a/arch/arm/configs/mapphone_defconfig b/arch/arm/configs/mapphone_defconfig
old mode 100755
new mode 100644
index 8871da8..00c5ec1
--- a/arch/arm/configs/mapphone_defconfig
+++ b/arch/arm/configs/mapphone_defconfig
@@ -803,7 +803,7 @@ CONFIG_OMAP_MODEM_CONTROL=y
 # CONFIG_ENCLOSURE_SERVICES is not set
 # CONFIG_KERNEL_DEBUGGER_CORE is not set
 # CONFIG_UID_STAT is not set
-# CONFIG_VIB_OMAP_PWM is not set
+CONFIG_VIB_PWM=y
 CONFIG_VIB_GPIO=y
 # CONFIG_SENSORS_AKM8973 is not set
 CONFIG_SENSORS_AKM8973_AKMD=y
@@ -1257,8 +1257,10 @@ CONFIG_VIDEO_OMAP3_HP3A=y
 #
 # CONFIG_VIDEO_OV7670 is not set
 # CONFIG_VIDEO_TCM825X is not set
-CONFIG_VIDEO_MT9P012=y
+#CONFIG_VIDEO_MT9P012 is not set
 CONFIG_VIDEO_OMAP3_HPLENS=y
+CONFIG_VIDEO_OV8810=y
+CONFIG_VIDEO_MIPI_INTERFACE=y
 # CONFIG_VIDEO_IMX046 is not set
 # CONFIG_VIDEO_LV8093 is not set
 # CONFIG_VIDEO_SAA711X is not set
@@ -1672,7 +1674,9 @@ CONFIG_LEDS_CLASS=y
 # CONFIG_LEDS_PCA955X is not set
 CONFIG_LEDS_SHOLES=y
 CONFIG_LEDS_LM3530=y
-CONFIG_LEDS_LM3554=y
+#CONFIG_LEDS_LM3554 is not set
+CONFIG_LEDS_BD7885=y
+CONFIG_LEDS_BU9847=y
 
 #
 # LED Triggers
diff --git a/arch/arm/configs/sholest_cu_defconfig b/arch/arm/configs/sholest_cu_defconfig
new file mode 100644
index 0000000..0235c14
--- /dev/null
+++ b/arch/arm/configs/sholest_cu_defconfig
@@ -0,0 +1,2172 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.29-omap1
+# Tue Oct 20 13:15:45 2009
+# Fri Oct 23 20:03:54 2009
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_ARM_OF=y
+CONFIG_OF=y
+CONFIG_PROC_DEVICETREE=y
+CONFIG_BOOTINFO=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_CLASSIC_RCU=y
+# CONFIG_TREE_RCU is not set
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_PREEMPT_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_GROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+# CONFIG_USER_SCHED is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_DEBUG=y
+# CONFIG_CGROUP_NS is not set
+CONFIG_CGROUP_FREEZER=y
+# CONFIG_CGROUP_DEVICE is not set
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+# CONFIG_CGROUP_MEM_RES_CTLR is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_PANIC_TIMEOUT=1
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ASHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+CONFIG_ARCH_OMAP=y
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_W90X900 is not set
+
+#
+# TI OMAP Implementations
+#
+CONFIG_ARCH_OMAP_OTG=y
+# CONFIG_ARCH_OMAP1 is not set
+# CONFIG_ARCH_OMAP2 is not set
+CONFIG_ARCH_OMAP3=y
+
+#
+# OMAP Feature Selections
+#
+# CONFIG_ARCH_OMAP3_GP is not set
+CONFIG_ARCH_OMAP3_HS=y
+# CONFIG_OMAP_DEBUG_POWERDOMAIN is not set
+# CONFIG_OMAP_DEBUG_CLOCKDOMAIN is not set
+CONFIG_OMAP_SMARTREFLEX=y
+# CONFIG_OMAP_SMARTREFLEX_TESTING is not set
+CONFIG_OMAP_RESET_CLOCKS=y
+CONFIG_OMAP_BOOT_TAG=y
+CONFIG_OMAP_BOOT_REASON=y
+# CONFIG_OMAP_COMPONENT_VERSION is not set
+# CONFIG_OMAP_GPIO_SWITCH is not set
+# CONFIG_OMAP_MUX is not set
+# CONFIG_OMAP_MUX_DEBUG is not set
+# CONFIG_OMAP_MUX_WARNINGS is not set
+CONFIG_OMAP_MCBSP=y
+CONFIG_MEM_DUMP=y
+# CONFIG_OMAP_MBOX_FWK is not set
+# CONFIG_OMAP_IOMMU is not set
+# CONFIG_OMAP_MPU_TIMER is not set
+CONFIG_OMAP_32K_TIMER=y
+# CONFIG_OMAP3_DEBOBS is not set
+CONFIG_OMAP_32K_TIMER_HZ=128
+CONFIG_OMAP_TICK_GPTIMER=1
+CONFIG_OMAP_DM_TIMER=y
+# CONFIG_OMAP_LL_DEBUG_UART1 is not set
+# CONFIG_OMAP_LL_DEBUG_UART2 is not set
+CONFIG_OMAP_LL_DEBUG_UART3=y
+# CONFIG_OMAP_LL_DEBUG_UART_EXT is not set
+CONFIG_OMAP_SERIAL_WAKE=y
+# CONFIG_OMAP_PM_NONE is not set
+# CONFIG_OMAP_PM_NOOP is not set
+CONFIG_OMAP_PM_SRF=y
+CONFIG_ARCH_OMAP34XX=y
+CONFIG_ARCH_OMAP3430=y
+
+#
+# OMAP Board Type
+#
+# CONFIG_MACH_NOKIA_RX51 is not set
+# CONFIG_MACH_OMAP_LDP is not set
+# CONFIG_MACH_OMAP_ZOOM2 is not set
+CONFIG_WIFI_CONTROL_FUNC=y
+# CONFIG_TIWLAN_SDIO is not set
+# CONFIG_MACH_OMAP_3430SDP is not set
+# CONFIG_MACH_OMAP3EVM is not set
+# CONFIG_MACH_OMAP3_BEAGLE is not set
+# CONFIG_MACH_SHOLES is not set
+CONFIG_MACH_MAPPHONE=y
+CONFIG_MACH_SHOLEST=y
+# CONFIG_MACH_OVERO is not set
+# CONFIG_MACH_OMAP3_PANDORA is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_IFAR=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+# CONFIG_HAS_TLS_REG is not set
+# CONFIG_OUTER_CACHE is not set
+
+#
+# errata
+#
+CONFIG_ARM_ERRATA_430973=y
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PREEMPT=y
+CONFIG_HZ=128
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_LEDS=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="root=/dev/nfs nfsroot=192.168.0.1:/home/user/buildroot ip=192.168.0.2:192.168.0.1:192.168.0.1:255.255.255.0:tgt:eth0:off rw console=ttyS2,115200n8"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+# CONFIG_CPU_FREQ_DEBUG is not set
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_MIN_TICKS=2
+CONFIG_CPU_FREQ_SAMPLING_LATENCY_MULTIPLIER=500
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_MISC=y
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_PM_VERBOSE is not set
+# CONFIG_CAN_PM_TRACE is not set
+CONFIG_PM_DEBUG=y
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HAS_WAKELOCK=y
+CONFIG_HAS_EARLYSUSPEND=y
+CONFIG_WAKELOCK=y
+# CONFIG_WAKELOCK_STAT is not set
+CONFIG_USER_WAKELOCK=y
+CONFIG_EARLYSUSPEND=y
+# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
+# CONFIG_CONSOLE_EARLYSUSPEND is not set
+CONFIG_FB_EARLYSUSPEND=y
+# CONFIG_APM_EMULATION is not set
+CONFIG_QUICK_WAKEUP=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_COMPAT_NET_DEV_OPS=y
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+# CONFIG_XFRM_SUB_POLICY is not set
+CONFIG_XFRM_MIGRATE=y
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=y
+CONFIG_NET_KEY=y
+CONFIG_NET_KEY_MIGRATE=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+CONFIG_INET_ESP=y
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+# CONFIG_IPV6_ROUTE_INFO is not set
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_INET6_XFRM_TUNNEL=y
+CONFIG_INET6_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+# CONFIG_IPV6_SUBTREES is not set
+# CONFIG_IPV6_MROUTE is not set
+CONFIG_ANDROID_PARANOID_NETWORK=y
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CT_ACCT=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_GRE=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_DSCP=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
+CONFIG_NETFILTER_XT_TARGET_RATEEST=y
+CONFIG_NETFILTER_XT_TARGET_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_TRACE=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP=y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_DCCP=y
+CONFIG_NETFILTER_XT_MATCH_DSCP=y
+CONFIG_NETFILTER_XT_MATCH_ESP=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+CONFIG_NETFILTER_XT_MATCH_OWNER=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_RATEEST=y
+CONFIG_NETFILTER_XT_MATCH_REALM=y
+CONFIG_NETFILTER_XT_MATCH_RECENT=y
+CONFIG_NETFILTER_XT_MATCH_RECENT_PROC_COMPAT=y
+CONFIG_NETFILTER_XT_MATCH_SCTP=y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_IP_NF_QUEUE=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_ADDRTYPE=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_TARGET_IDLETIMER=y
+CONFIG_NF_NAT_SNMP_BASIC=y
+CONFIG_NF_NAT_PROTO_DCCP=y
+CONFIG_NF_NAT_PROTO_GRE=y
+CONFIG_NF_NAT_PROTO_UDPLITE=y
+CONFIG_NF_NAT_PROTO_SCTP=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_NF_NAT_IRC=y
+CONFIG_NF_NAT_TFTP=y
+CONFIG_NF_NAT_AMANDA=y
+CONFIG_NF_NAT_PPTP=y
+CONFIG_NF_NAT_H323=y
+CONFIG_NF_NAT_SIP=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_TARGET_CLUSTERIP=y
+CONFIG_IP_NF_TARGET_ECN=y
+CONFIG_IP_NF_TARGET_TTL=y
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPTABLES=y
+# CONFIG_IP_NF_ARPFILTER is not set
+# CONFIG_IP_NF_ARP_MANGLE is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+CONFIG_NET_CLS_ROUTE=y
+# CONFIG_DCB is not set
+
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+CONFIG_BT=y
+CONFIG_BT_L2CAP=y
+CONFIG_BT_SCO=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+# CONFIG_BT_BNEP_MC_FILTER is not set
+# CONFIG_BT_BNEP_PROTO_FILTER is not set
+CONFIG_BT_HIDP=y
+
+#
+# Bluetooth device drivers
+#
+# CONFIG_BT_HCIBTUSB is not set
+# CONFIG_BT_HCIBTSDIO is not set
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+# CONFIG_BT_HCIUART_BCSP is not set
+CONFIG_BT_HCIUART_LL=y
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBFUSB is not set
+# CONFIG_BT_HCIBRF6150 is not set
+# CONFIG_BT_HCIH4P is not set
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_PHONET is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+# CONFIG_WIRELESS_OLD_REGULATORY is not set
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+# CONFIG_MAC80211 is not set
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_PM=y
+# CONFIG_RFKILL_INPUT is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+CONFIG_OF_DEVICE=y
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_CONCAT=y
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_OMAP_NOR is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_OMAP2=y
+CONFIG_MTD_NAND_OMAP_HWECC=y
+CONFIG_MTD_NAND_OMAP_PREFETCH=y
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+CONFIG_ANDROID_PMEM=y
+# CONFIG_ICS932S401 is not set
+CONFIG_OMAP_MODEM_CONTROL=y
+# CONFIG_OMAP_STI is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_KERNEL_DEBUGGER_CORE is not set
+# CONFIG_UID_STAT is not set
+# CONFIG_VIB_OMAP_PWM is not set
+CONFIG_VIB_GPIO=y
+# CONFIG_SENSORS_AKM8973 is not set
+CONFIG_SENSORS_AKM8973_AKMD=y
+CONFIG_SENSORS_LIS331DLH=y
+CONFIG_WL127X_RFKILL=y
+CONFIG_WL127X_TEST=m
+CONFIG_APANIC=y
+CONFIG_APANIC_PLABEL="kpanic"
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_93CX6 is not set
+
+#
+# Motorola TS 27.010 Mux driver
+#
+CONFIG_MOT_FEAT_TS27010MUX=y
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# Motorola netmux driver
+#
+CONFIG_NETMUX_DRIVER=m
+CONFIG_MOT_NETMUX_LINKDRIVER=m
+
+#
+# Motorola sec driver
+#
+CONFIG_SEC_DRIVER=m
+
+#
+# Motorola Modem PM Driver
+#
+CONFIG_MODEM_PM_DRIVER=m
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ENC28J60 is not set
+CONFIG_SMC911X=y
+# CONFIG_SMSC911X is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+CONFIG_NETDEV_1000=y
+CONFIG_NETDEV_10000=y
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_WAN is not set
+CONFIG_PPP=y
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=y
+# CONFIG_PPP_SYNC_TTY is not set
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_MPPE=y
+# CONFIG_PPPOE is not set
+# CONFIG_PPPOL2TP is not set
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+CONFIG_INPUT_KEYRESET=y
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_OMAP is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC210X is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+CONFIG_TOUCHSCREEN_QUANTUM_OBP=y
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+CONFIG_INPUT_UINPUT=y
+CONFIG_INPUT_GPIO=y
+CONFIG_INPUT_KEYCHORD=y
+CONFIG_INPUT_PROXIMITY_SFH7743=y
+# CONFIG_INPUT_HALLEFFECT_BU52014HV is not set
+CONFIG_DISABLE_IRQ_WAKE_KPD=y
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+CONFIG_DEVMEM=y
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+CONFIG_GPIODEV=y
+CONFIG_GPIODEV_DEVICE_TREE=y
+
+CONFIG_GPIO_MAPPING=y
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+CONFIG_SERIAL_OMAP3430_HW_FLOW_CONTROL=y
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_OMAP=y
+CONFIG_SERIAL_OMAP_CONSOLE=y
+# CONFIG_SERIAL_OMAP_DMA_UART1 is not set
+# CONFIG_SERIAL_OMAP_DMA_UART2 is not set
+# CONFIG_SERIAL_OMAP_DMA_UART3 is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_DCC_TTY is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+CONFIG_I2C_OMAP=y
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_PCA963X is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+CONFIG_SPI_OMAP24XX=y
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_TSC210X is not set
+# CONFIG_SPI_TSC2301 is not set
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+CONFIG_W1=y
+CONFIG_W1_CON=y
+
+#
+# 1-wire Bus Masters
+#
+# CONFIG_W1_MASTER_DS2490 is not set
+# CONFIG_W1_MASTER_DS2482 is not set
+# CONFIG_W1_MASTER_DS1WM is not set
+# CONFIG_W1_MASTER_GPIO is not set
+CONFIG_HDQ_MASTER_OMAP=y
+
+#
+# 1-wire Slaves
+#
+# CONFIG_W1_SLAVE_THERM is not set
+# CONFIG_W1_SLAVE_SMEM is not set
+# CONFIG_W1_SLAVE_DS2431 is not set
+# CONFIG_W1_SLAVE_DS2433 is not set
+CONFIG_W1_SLAVE_DS2502=y
+# CONFIG_W1_SLAVE_DS2760 is not set
+# CONFIG_W1_SLAVE_BQ27000 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_BATTERY_DS2760 is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+CONFIG_CHARGER_CPCAP=y
+CONFIG_BATTERY_CPCAP=y
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_OMAP_WATCHDOG=y
+CONFIG_OMAP_WATCHDOG_AUTOPET=y
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+CONFIG_MFD_CPCAP=y
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+# CONFIG_VIDEO_ALLOW_V4L1 is not set
+CONFIG_VIDEO_V4L1_COMPAT=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+# CONFIG_MEDIA_TUNER_CUSTOMIZE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEOBUF_GEN=y
+CONFIG_VIDEOBUF_DMA_SG=y
+CONFIG_VIDEO_OMAP_VIDEOOUT=y
+CONFIG_VIDEO_OMAP_VIDEOOUT_BUFPOOL=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+CONFIG_VIDEO_FIXED_MINOR_RANGES=y
+# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
+CONFIG_VIDEO_OMAP3_HP3A=y
+# CONFIG_VIDEO_OMAP_MOT_VIDEOOUT is not set
+# CONFIG_VIDEO_OMAP_MOT_VIDEOOUT_BUFPOOL is not set
+# CONFIG_PANEL_HDTV is not set
+# CONFIG_HDMI_TDA19989 is not set
+
+#
+# Encoders/decoders and other helper chips
+#
+
+#
+# Audio decoders
+#
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TDA9875 is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_CS5345 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_M52790 is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+
+#
+# Video decoders
+#
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_TCM825X is not set
+#CONFIG_VIDEO_MT9P012 is not set
+CONFIG_VIDEO_OMAP3_HPLENS=y
+CONFIG_VIDEO_OV8810=y
+CONFIG_VIDEO_MIPI_INTERFACE=y
+# CONFIG_VIDEO_IMX046 is not set
+# CONFIG_VIDEO_LV8093 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_SAA717X is not set
+# CONFIG_VIDEO_TVP514X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+
+#
+# Video and audio decoders
+#
+# CONFIG_VIDEO_CX25840 is not set
+
+#
+# MPEG video encoders
+#
+# CONFIG_VIDEO_CX2341X is not set
+
+#
+# Video encoders
+#
+# CONFIG_VIDEO_SAA7127 is not set
+
+#
+# Video improvement chips
+#
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_VIDEO_OMAP3 is not set
+# CONFIG_SOC_CAMERA is not set
+CONFIG_VIDEO_OLDOMAP3=y
+CONFIG_VIDEO_OLDOMAP34XX_ISP_PREVIEWER=y
+CONFIG_VIDEO_OLDOMAP34XX_ISP_RESIZER=y
+CONFIG_VIDEO_OLDOMAP3_BUFFALLOC=y
+# CONFIG_V4L_USB_DRIVERS is not set
+# CONFIG_RADIO_ADAPTERS is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+CONFIG_SGX=y
+CONFIG_SGX_BUILD_RELEASE=y
+# CONFIG_SGX_BUILD_DEBUG is not set
+CONFIG_SGX_RELEASE_LOGGING=y
+# CONFIG_SGX_EDM_TRACING is not set
+CONFIG_SGX_MK_TRACE=y
+CONFIG_PVR_OMAPLFB=y
+CONFIG_PVR_OMAP_DSS2=y
+# CONFIG_PVR_OMAP_USE_VSYNC is not set
+CONFIG_PVR_APM=y
+# CONFIG_VGASTATE is not set
+CONFIG_VIDEO_OUTPUT_CONTROL=m
+CONFIG_FB=y
+CONFIG_FIRMWARE_EDID=y
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+CONFIG_FB_OMAP_BOOTLOADER_INIT=y
+CONFIG_OMAP2_DSS=y
+CONFIG_OMAP2_DSS_VRAM_SIZE=5
+CONFIG_OMAP2_DSS_DEBUG_SUPPORT=y
+# CONFIG_OMAP2_DSS_RFBI is not set
+# CONFIG_OMAP2_DSS_VENC is not set
+# CONFIG_OMAP2_DSS_SDI is not set
+CONFIG_OMAP2_DSS_DSI=y
+CONFIG_OMAP2_DSS_USE_DSI_PLL=y
+# CONFIG_OMAP2_DSS_FAKE_VSYNC is not set
+CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK=0
+
+#
+# OMAP2/3 Display Device Drivers
+#
+# CONFIG_PANEL_GENERIC is not set
+# CONFIG_PANEL_SAMSUNG_LTE430WQ_F0C is not set
+# CONFIG_PANEL_SHARP_LS037V7DW01 is not set
+# CONFIG_PANEL_N800 is not set
+# CONFIG_PANEL_ZOOM2 is not set
+# CONFIG_CTRL_BLIZZARD is not set
+CONFIG_CTRL_EDISCO=y
+CONFIG_PANEL_SHOLES=y
+CONFIG_FB_OMAP2=y
+CONFIG_FB_OMAP2_DEBUG_SUPPORT=y
+# CONFIG_FB_OMAP2_FORCE_AUTO_UPDATE is not set
+CONFIG_FB_OMAP2_NUM_FBS=1
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_ILI9320 is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+CONFIG_LCD_PLATFORM=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+# CONFIG_SND is not set
+CONFIG_SOUND_PRIME=y
+CONFIG_SOUND_CPCAP_OMAP=y
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_COMPAT=y
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_GREENASIA_FF is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_THRUSTMASTER_FF is not set
+# CONFIG_ZEROPLUS_FF is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+CONFIG_USB_OTG=y
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+CONFIG_USB_MON=y
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+CONFIG_EHCI_SKIP_SYS_RESUME=y
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_OMAP_EHCI_PHY_MODE is not set
+CONFIG_OMAP_EHCI_TLL_MODE=y
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+CONFIG_USB_MUSB_HDRC=y
+CONFIG_USB_MUSB_SOC=y
+
+#
+# OMAP 343x high speed USB support
+#
+# CONFIG_USB_MUSB_HOST is not set
+# CONFIG_USB_MUSB_PERIPHERAL is not set
+CONFIG_USB_MUSB_OTG=y
+CONFIG_USB_GADGET_MUSB_HDRC=y
+CONFIG_USB_MUSB_HDRC_HCD=y
+# CONFIG_MUSB_PIO_ONLY is not set
+CONFIG_USB_INVENTRA_DMA=y
+# CONFIG_USB_TI_CPPI_DMA is not set
+# CONFIG_USB_MUSB_DEBUG is not set
+
+#
+# USB Device Class drivers
+#
+CONFIG_USB_ACM=y
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
+#
+
+#
+# see USB_STORAGE Help for more information
+#
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=y
+# CONFIG_USB_SERIAL_CONSOLE is not set
+# CONFIG_USB_EZUSB is not set
+# CONFIG_USB_SERIAL_GENERIC is not set
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP2101 is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_FUNSOFT is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+CONFIG_USB_SERIAL_MOTOROLA=y
+CONFIG_USB_QSC6085_CDMA_MODEM=y
+# CONFIG_EMU_UART_DEBUG is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIEMENS_MPI is not set
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+# CONFIG_USB_SERIAL_OPTION is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+CONFIG_USB_SERIAL_MOTO_CDMA_FLASH=y
+
+#
+# USB Miscellaneous drivers
+#
+
+CONFIG_USB_IPC=y
+CONFIG_USB_IPC_TEST=y
+CONFIG_USB_PANIC_ENUMERATION=y
+
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=500
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_IMX is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_ANDROID is not set
+# CONFIG_USB_USBNET is not set
+CONFIG_USB_MOT_ANDROID=y
+# CONFIG_USB_CDC_COMPOSITE is not set
+
+#
+# OTG and related infrastructure
+#
+CONFIG_USB_OTG_UTILS=y
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_ISP1301_OMAP is not set
+CONFIG_CPCAP_USB=y
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_UNSAFE_RESUME=y
+# CONFIG_MMC_EMBEDDED_SDIO is not set
+CONFIG_MMC_PARANOID_SD_INIT=y
+CONFIG_MMC_TST=y
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+CONFIG_MMC_BLOCK_DEFERRED_RESUME=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+CONFIG_MMC_OMAP_HS=y
+CONFIG_OMAP_HS_MMC2=y
+# CONFIG_OMAP_HS_MMC3 is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_OMAP_DEBUG is not set
+# CONFIG_LEDS_OMAP is not set
+# CONFIG_LEDS_OMAP_PWM is not set
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_PCA955X is not set
+CONFIG_LEDS_SHOLES=y
+CONFIG_LEDS_SHOLEST=y
+CONFIG_LEDS_LM3530=y
+#CONFIG_LEDS_LM3554 is not set
+CONFIG_LEDS_BD7885=y
+CONFIG_LEDS_BU9847=y
+CONFIG_LEDS_AF_LED=y
+CONFIG_LEDS_FLASH_RESET=y
+
+#
+# LED Triggers
+#
+# CONFIG_LEDS_TRIGGERS is not set
+CONFIG_SWITCH=y
+# CONFIG_SWITCH_GPIO is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+CONFIG_RTC_INTF_ALARM=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+CONFIG_RTC_DRV_CPCAP=y
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_DMADEVICES is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+CONFIG_REGULATOR_CPCAP=y
+# CONFIG_UIO is not set
+CONFIG_STAGING=y
+# CONFIG_STAGING_EXCLUDE_BUILD is not set
+# CONFIG_MEILHAUS is not set
+# CONFIG_USB_IP_COMMON is not set
+# CONFIG_ECHO is not set
+# CONFIG_COMEDI is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_INPUT_MIMIO is not set
+# CONFIG_TRANZPORT is not set
+
+#
+# Android
+#
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_RAM_CONSOLE=y
+CONFIG_ANDROID_RAM_CONSOLE_ENABLE_VERBOSE=y
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION=y
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_DATA_SIZE=128
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_ECC_SIZE=16
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_SYMBOL_SIZE=8
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_POLYNOMIAL=0x11d
+# CONFIG_ANDROID_RAM_CONSOLE_EARLY_INIT is not set
+CONFIG_ANDROID_TIMED_OUTPUT=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+
+#
+# CBUS support
+#
+# CONFIG_CBUS is not set
+CONFIG_MPU_BRIDGE=y
+CONFIG_BRIDGE_DVFS=y
+CONFIG_BRIDGE_MEMPOOL_SIZE=0x600000
+# CONFIG_BRIDGE_DEBUG is not set
+
+#
+# File systems
+#
+# CONFIG_CORE_DUMP_PERMISSION is not set
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_QUOTA=y
+# CONFIG_QUOTA_NETLINK_INTERFACE is not set
+CONFIG_PRINT_QUOTA_WARNING=y
+CONFIG_QUOTA_TREE=y
+# CONFIG_QFMT_V1 is not set
+CONFIG_QFMT_V2=y
+CONFIG_QUOTACTL=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_PROC_OMAP_PHONE_ID=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_YAFFS_FS=y
+CONFIG_YAFFS_YAFFS1=y
+# CONFIG_YAFFS_9BYTE_TAGS is not set
+# CONFIG_YAFFS_DOES_ECC is not set
+CONFIG_YAFFS_DOES_TAGS_ECC=y
+CONFIG_YAFFS_YAFFS2=y
+CONFIG_YAFFS_AUTO_YAFFS2=y
+# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
+# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
+# CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
+CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NETWORK_FILESYSTEMS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+CONFIG_SCHEDSTATS=y
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+CONFIG_DEBUG_MUTEXES=y
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_VM=y
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_TRACE_BRANCH_PROFILING is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_ERRORS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+CONFIG_CRYPTO_PCBC=m
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=y
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_REED_SOLOMON=y
+CONFIG_REED_SOLOMON_ENC8=y
+CONFIG_REED_SOLOMON_DEC8=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+
+#
+# Motorola Features
+#
+CONFIG_UMTS_SYSPANIC=y
+
+# support MDTV system
+# CONFIG_MOT_FEAT_MDTV is not set
+# support LP3907 regulator for TDMB block
+# CONFIG_MOT_FEAT_LP3907 is not set
+
+# SMS1130 SPI interface
+# CONFIG_MOT_FEAT_SPI_SMS1130 is not set
+#
+# Supported SMS1130(TDMB tuner)
+#
+# CONFIG_DVB_CORE is not set
+# CONFIG_SMS_SIANO_MDTV_TDMB is not set
+# CONFIG_SMS_HOSTLIB_SUBSYS is not set
+
+#
+# End of Motorola Features
+#
+
+# LTT-LITE
+# CONFIG_LTT_LITE is not set
diff --git a/arch/arm/mach-omap2/Kconfig b/arch/arm/mach-omap2/Kconfig
index 5ce7d31..d2e8149 100644
--- a/arch/arm/mach-omap2/Kconfig
+++ b/arch/arm/mach-omap2/Kconfig
@@ -119,7 +119,7 @@ config MACH_OMAP_ZOOM2
 
 config WIFI_CONTROL_FUNC
         bool "Enable WiFi control function abstraction"
-	depends on MACH_OMAP_ZOOM2 || MACH_SHOLES || MACH_MAPPHONE
+	depends on MACH_OMAP_ZOOM2 || MACH_SHOLES || MACH_MAPPHONE || MACH_SHOLEST
         help
           Enables Power/Reset/Carddetect function abstraction
 
@@ -164,6 +164,10 @@ config MACH_SHOLES_UMTS
         bool "Motorola sholes umts"
         depends on MACH_SHOLES
 
+config MACH_SHOLEST
+        bool "Motorola sholes tablet"
+        depends on ARCH_OMAP3 && ARCH_OMAP34XX
+
 config MACH_MAPPHONE
         bool "Motorola Android Platform phone"
         depends on ARCH_OMAP3 && ARCH_OMAP34XX
@@ -176,6 +180,10 @@ config MACH_OMAP3_PANDORA
 	bool "OMAP3 Pandora"
 	depends on ARCH_OMAP3 && ARCH_OMAP34XX
 
+config MOT_FEAT_MDTV
+	bool "support MDTV system for motorola"
+	default n
+
 config EMU_UART_DEBUG
 	bool "Provide the option of setting MiniUSB port as UART3 to debug kernel"
 	default n
@@ -191,3 +199,9 @@ config PROC_OMAP_PHONE_ID
 	default n
 	help
 	  Exports the DIE_ID reg value.
+
+config CUP2TOUCH
+	bool "Support touch for CU p2"
+	default n
+	help
+	  CU p2 touch needs special treatment for its differenct IC
diff --git a/arch/arm/mach-omap2/Makefile b/arch/arm/mach-omap2/Makefile
index c4ab2c3..2981dc2 100644
--- a/arch/arm/mach-omap2/Makefile
+++ b/arch/arm/mach-omap2/Makefile
@@ -85,6 +85,20 @@ obj-$(CONFIG_MACH_SHOLES)		+= board-sholes.o \
 					   board-sholes-keypad.o \
 					   board-sholes-wifi.o \
 					   board-sholes-mmcprobe.o
+obj-$(CONFIG_MACH_SHOLEST)             	+= board-sholest.o \
+					   board-sholest-camera.o \
+					   board-sholest-flash.o \
+					   board-sholest-padconf.o \
+					   board-sholest-panel.o \
+					   board-sholest-spi.o \
+					   board-sholest-sensors.o \
+					   board-sholest-hsmmc.o \
+					   board-sholest-keypad.o \
+					   board-sholest-wifi.o \
+					   board-sholest-gpio.o \
+					   board-sholest-mmcprobe.o \
+					   board-sholest-mdtv.o
+ifeq ($(CONFIG_MACH_SHOLEST),)
 obj-$(CONFIG_MACH_MAPPHONE)		+= board-mapphone.o \
 					   board-mapphone-camera.o \
 					   board-mapphone-flash.o \
@@ -96,7 +110,9 @@ obj-$(CONFIG_MACH_MAPPHONE)		+= board-mapphone.o \
 					   board-mapphone-keypad.o \
 					   board-mapphone-wifi.o \
 					   board-mapphone-gpio.o \
-					   board-mapphone-mmcprobe.o
+					   board-mapphone-mmcprobe.o \
+obj-$(CONFIG_MOT_FEAT_MDTV)             += board-mapphone-mdtv.o
+endif
 obj-$(CONFIG_MACH_OMAP_APOLLON)		+= board-apollon.o \
 					   board-apollon-mmc.o	\
 					   board-apollon-keys.o
diff --git a/arch/arm/mach-omap2/Makefile.boot b/arch/arm/mach-omap2/Makefile.boot
index f3558b3..dd30d9e 100644
--- a/arch/arm/mach-omap2/Makefile.boot
+++ b/arch/arm/mach-omap2/Makefile.boot
@@ -2,9 +2,13 @@
 params_phys-y		:= 0x80000100
 initrd_phys-y		:= 0x80800000
 
-  zreladdr-$(CONFIG_MACH_SHOLES_UMTS)  := 0x80c08000
-params_phys-$(CONFIG_MACH_SHOLES_UMTS) := 0x80c00100
-initrd_phys-$(CONFIG_MACH_SHOLES_UMTS) := 0x81400000
+  zreladdr-$(CONFIG_MACH_SHOLES_UMTS)   := 0x80c08000
+params_phys-$(CONFIG_MACH_SHOLES_UMTS)  := 0x80c00100
+initrd_phys-$(CONFIG_MACH_SHOLES_UMTS)  := 0x81400000
+
+  zreladdr-$(CONFIG_MACH_SHOLEST)       := 0x80c08000
+params_phys-$(CONFIG_MACH_SHOLEST)      := 0x80c00100
+initrd_phys-$(CONFIG_MACH_SHOLEST)      := 0x81400000
 
   zreladdr-$(CONFIG_MACH_MAPPHONE)	:= 0x80c08000
 params_phys-$(CONFIG_MACH_MAPPHONE)	:= 0x80c00100
diff --git a/arch/arm/mach-omap2/board-mapphone-camera.c b/arch/arm/mach-omap2/board-mapphone-camera.c
index 694ffc2..7a016b3 100644
--- a/arch/arm/mach-omap2/board-mapphone-camera.c
+++ b/arch/arm/mach-omap2/board-mapphone-camera.c
@@ -44,10 +44,6 @@
 #define CAM_IOMUX_SAFE_MODE (OMAP343X_PADCONF_PULL_UP | \
 				OMAP343X_PADCONF_PUD_ENABLED | \
 				OMAP343X_PADCONF_MUXMODE7)
-#define CAM_IOMUX_SAFE_MODE_INPUT (OMAP343X_PADCONF_INPUT_ENABLED | \
-				OMAP343X_PADCONF_PULL_UP | \
-				OMAP343X_PADCONF_PUD_ENABLED | \
-				OMAP343X_PADCONF_MUXMODE7)
 #define CAM_IOMUX_FUNC_MODE (OMAP343X_PADCONF_INPUT_ENABLED | \
 				OMAP343X_PADCONF_MUXMODE0)
 
@@ -239,30 +235,18 @@ struct mt9p012_platform_data mapphone_mt9p012_platform_data = {
 
 void mapphone_camera_lines_safe_mode(void)
 {
-	omap_ctrl_writew(CAM_IOMUX_SAFE_MODE_INPUT, 0x011a);
-	omap_ctrl_writew(CAM_IOMUX_SAFE_MODE_INPUT, 0x011c);
-	omap_ctrl_writew(CAM_IOMUX_SAFE_MODE_INPUT, 0x011e);
-	omap_ctrl_writew(CAM_IOMUX_SAFE_MODE_INPUT, 0x0120);
 	omap_ctrl_writew(CAM_IOMUX_SAFE_MODE, 0x0122);
 	omap_ctrl_writew(CAM_IOMUX_SAFE_MODE, 0x0124);
 	omap_ctrl_writew(CAM_IOMUX_SAFE_MODE, 0x0126);
 	omap_ctrl_writew(CAM_IOMUX_SAFE_MODE, 0x0128);
-	omap_ctrl_writew(CAM_IOMUX_SAFE_MODE_INPUT, 0x012a);
-	omap_ctrl_writew(CAM_IOMUX_SAFE_MODE_INPUT, 0x012c);
 }
 
 void mapphone_camera_lines_func_mode(void)
 {
-	omap_ctrl_writew(CAM_IOMUX_FUNC_MODE, 0x011a);
-	omap_ctrl_writew(CAM_IOMUX_FUNC_MODE, 0x011c);
-	omap_ctrl_writew(CAM_IOMUX_FUNC_MODE, 0x011e);
-	omap_ctrl_writew(CAM_IOMUX_FUNC_MODE, 0x0120);
 	omap_ctrl_writew(CAM_IOMUX_FUNC_MODE, 0x0122);
 	omap_ctrl_writew(CAM_IOMUX_FUNC_MODE, 0x0124);
 	omap_ctrl_writew(CAM_IOMUX_FUNC_MODE, 0x0126);
 	omap_ctrl_writew(CAM_IOMUX_FUNC_MODE, 0x0128);
-	omap_ctrl_writew(CAM_IOMUX_FUNC_MODE, 0x012a);
-	omap_ctrl_writew(CAM_IOMUX_FUNC_MODE, 0x012c);
 }
 
 void __init mapphone_camera_init(void)
diff --git a/arch/arm/mach-omap2/board-mapphone-keypad.c b/arch/arm/mach-omap2/board-mapphone-keypad.c
index 32c829b..af16e68 100644
--- a/arch/arm/mach-omap2/board-mapphone-keypad.c
+++ b/arch/arm/mach-omap2/board-mapphone-keypad.c
@@ -110,34 +110,11 @@ static const unsigned short mapphone_p3_keymap[ARRAY_SIZE(mapphone_col_gpios) *
 	[KEYMAP_INDEX(7, 7)] = KEY_W,
 };
 
-#ifndef CONFIG_ARM_OF
-static const unsigned short mapphone_keymap_closed[
-	ARRAY_SIZE(mapphone_col_gpios) * ARRAY_SIZE(mapphone_row_gpios)] = {
-	[KEYMAP_INDEX(0, 3)] = KEY_VOLUMEDOWN,
-	[KEYMAP_INDEX(0, 5)] = KEY_VOLUMEUP,
-	[KEYMAP_INDEX(4, 3)] = KEY_CAMERA-1,	/* camera 1 key, steal KEY_HP*/
-	[KEYMAP_INDEX(4, 5)] = KEY_CAMERA,	/* "camera 2" key */
-};
-#else
-static const unsigned short *mapphone_keymap_closed;
-#endif
-
-static int fixup(int index)
-{
-       int slide_open = gpio_get_value(GPIO_SLIDER);
-       if (!slide_open)
-		return mapphone_keymap_closed[index];
-       return 1;
-}
-
 static struct gpio_event_matrix_info mapphone_keypad_matrix_info = {
 	.info.func = gpio_event_matrix_func,
 	.keymap = mapphone_p3_keymap,
 	.output_gpios = mapphone_col_gpios,
 	.input_gpios = mapphone_row_gpios,
-#ifndef CONFIG_ARM_OF
-	.sw_fixup = fixup,
-#endif
 	.noutputs = ARRAY_SIZE(mapphone_col_gpios),
 	.ninputs = ARRAY_SIZE(mapphone_row_gpios),
 	.settle_time.tv.nsec = 40 * NSEC_PER_USEC,
@@ -231,12 +208,6 @@ static int __init mapphone_dt_kp_init(void)
 			mapphone_keypad_matrix_info.keymap = \
 				(unsigned short *)kp_prop;
 
-		kp_prop = of_get_property(kp_node, \
-				DT_PROP_KEYPAD_CLOSED_MAPS, NULL);
-		if (kp_prop) {
-			mapphone_keymap_closed = (unsigned short *)kp_prop;
-			mapphone_keypad_matrix_info.sw_fixup = fixup;
-		}
 		of_node_put(kp_node);
 	}
 
diff --git a/arch/arm/mach-omap2/board-mapphone-spi.c b/arch/arm/mach-omap2/board-mapphone-spi.c
index fe97d3b..72a8fd4 100644
--- a/arch/arm/mach-omap2/board-mapphone-spi.c
+++ b/arch/arm/mach-omap2/board-mapphone-spi.c
@@ -155,6 +155,10 @@ struct regulator_consumer_supply cpcap_vcsi_consumers[] = {
 	REGULATOR_CONSUMER("vdds_dsi", &mapphone_dss_device.dev),
 };
 
+struct regulator_consumer_supply cpcap_vwlan1_consumers[] = {
+	REGULATOR_CONSUMER("vwlan1", NULL /* cpcap_cam_device */),
+};
+
 struct regulator_consumer_supply cpcap_vwlan2_consumers[] = {
 	REGULATOR_CONSUMER("vwlan2", NULL /* sd slot */),
 };
@@ -307,6 +311,8 @@ static struct regulator_init_data cpcap_regulator[CPCAP_NUM_REGULATORS] = {
 			.max_uV			= 1900000,
 			.valid_ops_mask		= 0,
 		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vwlan1_consumers),
+		.consumer_supplies	= cpcap_vwlan1_consumers,
 	},
 	[CPCAP_VWLAN2] = {
 		.constraints = {
diff --git a/arch/arm/mach-omap2/board-mapphone.c b/arch/arm/mach-omap2/board-mapphone.c
index 64adb1b..5102742 100644
--- a/arch/arm/mach-omap2/board-mapphone.c
+++ b/arch/arm/mach-omap2/board-mapphone.c
@@ -77,6 +77,22 @@
 #include <media/mt9p012.h>
 
 #endif
+#if defined(CONFIG_VIDEO_OV8810) || defined(CONFIG_VIDEO_OV8810_MODULE)
+#include <../drivers/media/video/ov8810.h>
+#include <../drivers/media/video/oldisp/ispcsi2.h>
+#define OV8810_CSI2_CLOCK_POLARITY	0	/* +/- pin order */
+#define OV8810_CSI2_DATA0_POLARITY	0	/* +/- pin order */
+#define OV8810_CSI2_DATA1_POLARITY	0	/* +/- pin order */
+#define OV8810_CSI2_CLOCK_LANE		1	 /* Clock lane position: 1 */
+#define OV8810_CSI2_DATA0_LANE		2	 /* Data0 lane position: 2 */
+#define OV8810_CSI2_DATA1_LANE		3	 /* Data1 lane position: 3 */
+#define OV8810_CSI2_PHY_THS_TERM	1  /* GVH */
+#define OV8810_CSI2_PHY_THS_SETTLE	21  /* GVH */
+#define OV8810_CSI2_PHY_TCLK_TERM	0
+#define OV8810_CSI2_PHY_TCLK_MISS	1
+#define OV8810_CSI2_PHY_TCLK_SETTLE	14
+#endif
+
 #ifdef CONFIG_VIDEO_OMAP3_HPLENS
 #include <../drivers/media/video/hplens.h>
 #endif
@@ -581,6 +597,12 @@ static struct i2c_board_info __initdata mapphone_i2c_bus2_board_info[] = {
 };
 
 static struct i2c_board_info __initdata mapphone_i2c_bus3_board_info[] = {
+#if defined(CONFIG_VIDEO_OV8810)
+	{
+		I2C_BOARD_INFO("ov8810", OV8810_I2C_ADDR),
+		.platform_data = &mapphone_ov8810_platform_data,
+	},
+#endif
 	{
 		I2C_BOARD_INFO("lm3554_led", 0x53),
 		.platform_data = &mapphone_camera_flash,
diff --git a/arch/arm/mach-omap2/board-sholes.c b/arch/arm/mach-omap2/board-sholes.c
old mode 100755
new mode 100644
diff --git a/arch/arm/mach-omap2/board-sholest-camera.c b/arch/arm/mach-omap2/board-sholest-camera.c
new file mode 100644
index 0000000..cbd8ab8
--- /dev/null
+++ b/arch/arm/mach-omap2/board-sholest-camera.c
@@ -0,0 +1,598 @@
+/*
+ * linux/arch/arm/mach-omap2/board-sholest-camera.c
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * Derived from mach-omap3/board-3430sdp.c
+ *
+ * Copyright (C) 2007 Texas Instruments
+ *
+ * Modified from mach-omap2/board-generic.c
+ *
+ * Initial code: Syed Mohammed Khasim
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/mm.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <mach/mux.h>
+#include <mach/board-sholest.h>
+#include <mach/omap-pm.h>
+#include <mach/control.h>
+#include <mach/resource.h>
+
+#ifdef CONFIG_VIDEO_OLDOMAP3
+#include <media/v4l2-int-device.h>
+#include <../drivers/media/video/oldomap34xxcam.h>
+#include <../drivers/media/video/oldisp/ispreg.h>
+#include <../drivers/media/video/oldisp/isp.h>
+#if defined(CONFIG_VIDEO_MT9P012) || defined(CONFIG_VIDEO_MT9P012_MODULE)
+#include <media/mt9p012.h>
+#endif
+#endif
+#if defined(CONFIG_VIDEO_OV8810) || defined(CONFIG_VIDEO_OV8810_MODULE)
+#include <../drivers/media/video/ov8810.h>
+#include <../drivers/media/video/oldisp/ispcsi2.h>
+#if defined(CONFIG_LEDS_FLASH_RESET)
+#include <linux/spi/cpcap.h>
+#include <linux/spi/cpcap-regbits.h>
+#endif
+#define OV8810_CSI2_CLOCK_POLARITY	0	/* +/- pin order */
+#define OV8810_CSI2_DATA0_POLARITY	0	/* +/- pin order */
+#define OV8810_CSI2_DATA1_POLARITY	0	/* +/- pin order */
+#define OV8810_CSI2_CLOCK_LANE		1	 /* Clock lane position: 1 */
+#define OV8810_CSI2_DATA0_LANE		2	 /* Data0 lane position: 2 */
+#define OV8810_CSI2_DATA1_LANE		3	 /* Data1 lane position: 3 */
+#define OV8810_CSI2_PHY_THS_TERM	1  /* GVH */
+#define OV8810_CSI2_PHY_THS_SETTLE	21  /* GVH */
+#define OV8810_CSI2_PHY_TCLK_TERM	0
+#define OV8810_CSI2_PHY_TCLK_MISS	1
+#define OV8810_CSI2_PHY_TCLK_SETTLE	14
+#define CPUCLK_LOCK_VAL			    0x5
+#endif
+
+#ifdef CONFIG_VIDEO_OMAP3_HPLENS
+#include <../drivers/media/video/hplens.h>
+#endif
+
+static void sholest_camera_lines_safe_mode(void);
+static void sholest_camera_lines_func_mode(void);
+
+#ifdef CONFIG_VIDEO_OMAP3_HPLENS
+static int hplens_power_set(enum v4l2_power power)
+{
+	(void)power;
+
+	return 0;
+}
+
+static int hplens_set_prv_data(void *priv)
+{
+	struct omap34xxcam_hw_config *hwc = priv;
+
+	hwc->dev_index = 0;
+	hwc->dev_minor = 0;
+	hwc->dev_type = OMAP34XXCAM_SLAVE_LENS;
+
+	return 0;
+}
+
+struct hplens_platform_data sholest_hplens_platform_data = {
+	.power_set = hplens_power_set,
+	.priv_data_set = hplens_set_prv_data,
+};
+#endif
+
+#if defined(CONFIG_VIDEO_MT9P012) || defined(CONFIG_VIDEO_MT9P012_MODULE)
+static struct omap34xxcam_sensor_config mt9p012_cam_hwc = {
+	.sensor_isp = 0,
+	.xclk = OMAP34XXCAM_XCLK_A,
+	.capture_mem = PAGE_ALIGN(2592 * 1944 * 2) * 4,
+};
+
+static int mt9p012_sensor_set_prv_data(void *priv)
+{
+	struct omap34xxcam_hw_config *hwc = priv;
+
+	hwc->u.sensor.xclk = mt9p012_cam_hwc.xclk;
+	hwc->u.sensor.sensor_isp = mt9p012_cam_hwc.sensor_isp;
+	hwc->u.sensor.capture_mem = mt9p012_cam_hwc.capture_mem;
+	hwc->dev_index = 0;
+	hwc->dev_minor = 0;
+	hwc->dev_type = OMAP34XXCAM_SLAVE_SENSOR;
+	hwc->interface_type = ISP_PARLL;
+	return 0;
+}
+
+static struct isp_interface_config mt9p012_if_config = {
+	.ccdc_par_ser = ISP_PARLL,
+	.dataline_shift = 0x1,
+	.hsvs_syncdetect = ISPCTRL_SYNC_DETECT_VSRISE,
+	.vdint0_timing = 0x0,
+	.vdint1_timing = 0x0,
+	.strobe = 0x0,
+	.prestrobe = 0x0,
+	.shutter = 0x0,
+	.wenlog = ISPCCDC_CFG_WENLOG_OR,
+	.dcsub = 42,
+	.raw_fmt_in = ISPCCDC_INPUT_FMT_GR_BG,
+	.wbal.coef0 = 0x23,
+	.wbal.coef1 = 0x20,
+	.wbal.coef2 = 0x20,
+	.wbal.coef3 = 0x30,
+	.u.par.par_bridge = 0x0,
+	.u.par.par_clk_pol = 0x0,
+};
+
+static int mt9p012_sensor_power_set(struct device* dev, enum v4l2_power power)
+{
+	static enum v4l2_power previous_power = V4L2_POWER_OFF;
+	static struct regulator *regulator;
+
+	switch (power) {
+	case V4L2_POWER_OFF:
+		/* Power Down Sequence */
+		gpio_free(GPIO_CAMERA_RESET);
+
+		/* Turn off power */
+		if (regulator != NULL) {
+			regulator_disable(regulator);
+			regulator_put(regulator);
+			regulator = NULL;
+		} else {
+			sholest_camera_lines_safe_mode();
+			pr_err("%s: Regulator for vcam is not "\
+					"initialized\n", __func__);
+			return -EIO;
+		}
+
+		/* Release pm constraints */
+		omap_pm_set_min_bus_tput(dev, OCP_INITIATOR_AGENT, 0);
+		sholest_camera_lines_safe_mode();
+	break;
+	case V4L2_POWER_ON:
+		if (previous_power == V4L2_POWER_OFF) {
+			/* Power Up Sequence */
+			sholest_camera_lines_func_mode();
+
+			/* Set min throughput to:
+			 *  2592 x 1944 x 2bpp x 30fps x 3 L3 accesses */
+			omap_pm_set_min_bus_tput(dev, OCP_INITIATOR_AGENT, 885735);
+
+			/* Configure pixel clock divider (here?) */
+			omap_writel(OMAP_MCAM_SRC_DIV, 0x48004f40);
+			isp_configure_interface(&mt9p012_if_config);
+
+			/* Request and configure gpio pins */
+			if (gpio_request(GPIO_CAMERA_RESET,
+						"mt9p012 camera reset") != 0)
+				return -EIO;
+
+			/* set to output mode */
+			gpio_direction_output(GPIO_CAMERA_RESET, 0);
+
+			/* nRESET is active LOW. set HIGH to release reset */
+			gpio_set_value(GPIO_CAMERA_RESET, 1);
+
+			/* turn on digital power */
+			if (regulator != NULL) {
+				pr_warning("%s: Already have "\
+						"regulator\n", __func__);
+			} else {
+				regulator = regulator_get(NULL, "vcam");
+				if (IS_ERR(regulator)) {
+					pr_err("%s: Cannot get vcam "\
+						"regulator, err=%ld\n",
+						__func__, PTR_ERR(regulator));
+					return PTR_ERR(regulator);
+				}
+			}
+
+			if (regulator_enable(regulator) != 0) {
+				pr_err("%s: Cannot enable vcam regulator\n",
+						__func__);
+				return -EIO;
+			}
+		}
+
+		udelay(1000);
+
+		if (previous_power == V4L2_POWER_OFF) {
+			/* trigger reset */
+			gpio_direction_output(GPIO_CAMERA_RESET, 0);
+
+			udelay(1500);
+
+			/* nRESET is active LOW. set HIGH to release reset */
+			gpio_set_value(GPIO_CAMERA_RESET, 1);
+
+			/* give sensor sometime to get out of the reset.
+			 * Datasheet says 2400 xclks. At 6 MHz, 400 usec is
+			 * enough
+			 */
+			udelay(300);
+		}
+		break;
+	case V4L2_POWER_STANDBY:
+		/* Stand By Sequence */
+		break;
+	}
+	/* Save powerstate to know what was before calling POWER_ON. */
+	previous_power = power;
+	return 0;
+}
+
+u32 mt9p012_set_xclk(u32 xclkfreq)
+{
+	return isp_set_xclk(xclkfreq, OMAP34XXCAM_XCLK_A);
+}
+
+
+struct mt9p012_platform_data sholest_mt9p012_platform_data = {
+	.power_set      = mt9p012_sensor_power_set,
+	.set_xclk	= mt9p012_set_xclk,
+	.priv_data_set  = mt9p012_sensor_set_prv_data,
+};
+
+#endif /* #ifdef CONFIG_VIDEO_MT9P012 || CONFIG_VIDEO_MT9P012_MODULE */
+
+#if defined(CONFIG_VIDEO_OV8810)
+
+static struct omap34xxcam_sensor_config ov8810_cam_hwc = {
+	.sensor_isp = 0,
+	.xclk = OMAP34XXCAM_XCLK_A,
+	.capture_mem = PAGE_ALIGN(3264 * 2448 * 2 * 2) * 4,
+};
+
+static void mapphone_lock_cpufreq(int lock){
+	static struct device *ov_dev;
+	static int flag;
+	if (lock == 1) {
+		resource_request("vdd1_opp", ov_dev, CPUCLK_LOCK_VAL);
+		flag = 1;
+	}
+	else {
+		if (flag == 1) {
+			resource_release("vdd1_opp", ov_dev);
+			flag = 0;
+		}
+	}
+}
+
+static int ov8810_sensor_set_prv_data(void *priv)
+{
+	struct omap34xxcam_hw_config *hwc = priv;
+
+	hwc->u.sensor.xclk = ov8810_cam_hwc.xclk;
+	hwc->u.sensor.sensor_isp = ov8810_cam_hwc.sensor_isp;
+	hwc->u.sensor.capture_mem = ov8810_cam_hwc.capture_mem;
+	hwc->dev_index = 0;
+	hwc->dev_minor = 0;
+	hwc->dev_type = OMAP34XXCAM_SLAVE_SENSOR;
+	hwc->interface_type = ISP_CSIA;
+
+	hwc->csi2.hw_csi2.lanes.clock.polarity = OV8810_CSI2_CLOCK_POLARITY;
+	hwc->csi2.hw_csi2.lanes.clock.position = OV8810_CSI2_CLOCK_LANE;
+	hwc->csi2.hw_csi2.lanes.data[0].polarity = OV8810_CSI2_DATA0_POLARITY;
+	hwc->csi2.hw_csi2.lanes.data[0].position = OV8810_CSI2_DATA0_LANE;
+	hwc->csi2.hw_csi2.lanes.data[1].polarity = OV8810_CSI2_DATA1_POLARITY;
+	hwc->csi2.hw_csi2.lanes.data[1].position = OV8810_CSI2_DATA1_LANE;
+	hwc->csi2.hw_csi2.phy.ths_term = OV8810_CSI2_PHY_THS_TERM;
+	hwc->csi2.hw_csi2.phy.ths_settle = OV8810_CSI2_PHY_THS_SETTLE;
+	hwc->csi2.hw_csi2.phy.tclk_term = OV8810_CSI2_PHY_TCLK_TERM;
+	hwc->csi2.hw_csi2.phy.tclk_miss = OV8810_CSI2_PHY_TCLK_MISS;
+	hwc->csi2.hw_csi2.phy.tclk_settle = OV8810_CSI2_PHY_TCLK_SETTLE;
+
+	return 0;
+}
+
+static struct isp_interface_config ov8810_if_config = {
+	.ccdc_par_ser = ISP_CSIA,
+	.dataline_shift = 0x0,
+	.hsvs_syncdetect = ISPCTRL_SYNC_DETECT_VSRISE,
+	.vdint0_timing = 0x0,
+	.vdint1_timing = 0x0,
+	.strobe = 0x0,
+	.prestrobe = 0x0,
+	.shutter = 0x0,
+	.wenlog = ISPCCDC_CFG_WENLOG_OR,
+	.dcsub = OV8810_BLACK_LEVEL_10BIT,
+	.raw_fmt_in = ISPCCDC_INPUT_FMT_BG_GR,
+	.wbal.coef0		= 0x23,
+	.wbal.coef1		= 0x20,
+	.wbal.coef2		= 0x20,
+	.wbal.coef3		= 0x39,
+	.u.csi.crc = 0x0,
+	.u.csi.mode = 0x0,
+	.u.csi.edge = 0x0,
+	.u.csi.signalling = 0x0,
+	.u.csi.strobe_clock_inv = 0x0,
+	.u.csi.vs_edge = 0x0,
+	.u.csi.channel = 0x1,
+	.u.csi.vpclk = 0x1,
+	.u.csi.data_start = 0x0,
+	.u.csi.data_size = 0x0,
+	.u.csi.format = V4L2_PIX_FMT_SGRBG10,
+};
+
+static int ov8810_sensor_power_set(struct device *dev, \
+	struct i2c_client *i2c_client, enum v4l2_power power)
+{
+
+#if defined (CONFIG_VIDEO_MIPI_INTERFACE)
+	struct isp_csi2_lanes_cfg lanecfg;
+	struct isp_csi2_phy_cfg phyconfig;
+#endif
+
+	static enum v4l2_power previous_power = V4L2_POWER_OFF;
+	static struct regulator *regulator_vcam;
+	static struct regulator *regulator_vwlan1;
+	/*Basic turn on operation is will be first one time executed.*/
+	static bool regulator_poweron = 0;
+	
+#if defined(CONFIG_LEDS_FLASH_RESET)
+	static enum detect_type {
+		FLASH_COUPLE_LINE = 0,
+		FLASH_SINGLE_LINE,
+		FLASH_NOT_DETECTED,
+	} flash_detected = FLASH_NOT_DETECTED;
+#endif
+
+	switch (power) {
+	case V4L2_POWER_OFF:
+#if defined(CONFIG_VIDEO_MIPI_INTERFACE)
+		/* Power Down Sequence */
+		isp_csi2_complexio_power(ISP_CSI2_POWER_OFF);
+#endif
+
+		/* Release pm constraints */
+		omap_pm_set_min_bus_tput(dev, OCP_INITIATOR_AGENT, 0);
+		/* Turn off power */
+		if (regulator_vcam != NULL) {
+			regulator_disable(regulator_vcam);
+			regulator_put(regulator_vcam);
+			regulator_vcam = NULL;
+		} else {
+			sholest_camera_lines_safe_mode();
+			pr_err("%s: Regulator for vcam is not "\
+					"initialized\n", __func__);
+			return -EIO;
+		}
+
+		/* Delay 6 msec for vcam to drop (4.7uF to 10uF change) */
+		msleep(6);
+
+		/* Turn off power */
+		if (regulator_vwlan1 != NULL) {
+			regulator_disable(regulator_vwlan1);
+			regulator_put(regulator_vwlan1);
+			regulator_vwlan1 = NULL;
+		} else {
+			sholest_camera_lines_safe_mode();
+			pr_err("%s: Regulator for vwlan1 is not "\
+					"initialized\n", __func__);
+			return -EIO;
+		}
+		gpio_set_value(GPIO_OV8810_RESET, 0);
+		gpio_set_value(GPIO_OV8810_STANDBY, 0);
+
+#if defined(CONFIG_LEDS_FLASH_RESET)
+		/*If Xenon flash module didn't detected,
+			FLASH_RESET pin control.*/
+		if (flash_detected == FLASH_COUPLE_LINE)
+			cpcap_direct_misc_write(CPCAP_REG_GPIO0,\
+				0, CPCAP_BIT_GPIO0DRV);
+#endif
+		gpio_free(GPIO_OV8810_RESET);
+		gpio_free(GPIO_OV8810_STANDBY);
+
+		sholest_camera_lines_safe_mode();
+	break;
+	case V4L2_POWER_ON:
+
+		sholest_camera_lines_func_mode();
+	        /* Set min throughput to:
+	         *  2592 x 1944 x 2bpp x 30fps x 3 L3 accesses */
+	         omap_pm_set_min_bus_tput(dev, OCP_INITIATOR_AGENT, 885735);
+
+#if defined (CONFIG_VIDEO_MIPI_INTERFACE)
+		printk(KERN_DEBUG "ov8810_sensor_power_set(ON)\n");
+		/*if (previous_power == V4L2_POWER_OFF)*/
+			isp_csi2_reset();
+
+		lanecfg.clk.pol = OV8810_CSI2_CLOCK_POLARITY;
+		lanecfg.clk.pos = OV8810_CSI2_CLOCK_LANE;
+		lanecfg.data[0].pol = OV8810_CSI2_DATA0_POLARITY;
+		lanecfg.data[0].pos = OV8810_CSI2_DATA0_LANE;
+		lanecfg.data[1].pol = OV8810_CSI2_DATA1_POLARITY;
+		lanecfg.data[1].pos = OV8810_CSI2_DATA1_LANE;
+		lanecfg.data[2].pol = 0;
+		lanecfg.data[2].pos = 0;
+		lanecfg.data[3].pol = 0;
+		lanecfg.data[3].pos = 0;
+		isp_csi2_complexio_lanes_config(&lanecfg);
+		isp_csi2_complexio_lanes_update(true);
+
+		phyconfig.ths_term = OV8810_CSI2_PHY_THS_TERM;
+		phyconfig.ths_settle = OV8810_CSI2_PHY_THS_SETTLE;
+		phyconfig.tclk_term = OV8810_CSI2_PHY_TCLK_TERM;
+		phyconfig.tclk_miss = OV8810_CSI2_PHY_TCLK_MISS;
+		phyconfig.tclk_settle = OV8810_CSI2_PHY_TCLK_SETTLE;
+		isp_csi2_phy_config(&phyconfig);
+		isp_csi2_phy_update(true);
+
+		isp_configure_interface(&ov8810_if_config);
+#endif
+
+		if ((previous_power == V4L2_POWER_OFF) && (regulator_poweron == 0)){
+
+			/* Disable Interface. */
+			isp_csi2_ctrl_config_if_enable(false);
+			isp_csi2_ctrl_update(false);
+
+			/* Configure pixel clock divider (here?) */
+			omap_writel(OMAP_MCAM_SRC_DIV, 0x48004f40);
+
+			/* turn on VWLAN1 power */
+			if (regulator_vwlan1 != NULL) {
+				pr_warning("%s: Already have "\
+						"regulator_vwlan1 \n", __func__);
+			} else {
+				regulator_vwlan1 = regulator_get(NULL, "vwlan1");
+				if (IS_ERR(regulator_vwlan1)) {
+					pr_err("%s: Cannot get vwlan1 "\
+						"regulator_vwlan1, err=%ld\n",
+						__func__, PTR_ERR(regulator_vwlan1));
+					return PTR_ERR(regulator_vwlan1);
+				}
+			}
+			
+			if (regulator_enable(regulator_vwlan1) != 0) {
+				pr_err("%s: Cannot enable vcam regulator_vwlan1\n",
+						__func__);
+				return -EIO;
+			}
+
+			/* turn on VCAM power */
+			if (regulator_vcam != NULL) {
+				pr_warning("%s: Already have "\
+						"regulator_vcam\n", __func__);
+			} else {
+				regulator_vcam = regulator_get(NULL, "vcam");
+				if (IS_ERR(regulator_vcam)) {
+					pr_err("%s: Cannot get vcam "\
+						"regulator_vcam, err=%ld\n",
+						__func__, PTR_ERR(regulator_vcam));
+					return PTR_ERR(regulator_vcam);
+				}
+			}
+
+			if (regulator_enable(regulator_vcam) != 0) {
+				pr_err("%s: Cannot enable vcam regulator_vcam\n",
+						__func__);
+				return -EIO;
+			}
+
+			mdelay(5);
+
+			/* Request and configure gpio pins */
+			if (gpio_request(GPIO_OV8810_STANDBY,
+						"ov8810 camera standby") != 0)
+				return -EIO;
+
+			/* set to output mode */
+			gpio_direction_output(GPIO_OV8810_STANDBY, 0);
+			gpio_set_value(GPIO_OV8810_STANDBY, 0);
+
+			if (gpio_request(GPIO_OV8810_RESET,
+						"ov8810 camera reset") != 0)
+				return -EIO;
+
+			/* trigger reset */
+			gpio_direction_output(GPIO_OV8810_RESET, 1);
+
+			/* nRESET is active LOW. set HIGH to release reset */
+			gpio_set_value(GPIO_OV8810_RESET, 1);
+			
+#if defined(CONFIG_LEDS_FLASH_RESET)
+			if (flash_detected == FLASH_NOT_DETECTED) {
+				if (bd7885_device_detection())
+					flash_detected = FLASH_SINGLE_LINE;
+				else
+					flash_detected = FLASH_COUPLE_LINE;
+			}
+			/*If Xenon flash module didn't detected,
+				FLASH_RESET pin control.*/
+			if (flash_detected == FLASH_COUPLE_LINE)
+				cpcap_direct_misc_write(CPCAP_REG_GPIO0,\
+					CPCAP_BIT_GPIO0DRV, CPCAP_BIT_GPIO0DRV);
+#endif
+			/* give sensor sometime to get out of the reset.
+			 * Datasheet says 2400 xclks. At 6 MHz, 400 usec is
+			 * enough
+			 */
+			mdelay(5);
+
+			ov8810_write_reg(i2c_client, OV8810_IMAGE_SYSTEM, 0x00);
+
+			pr_err("%s: OV8810 streaming off.\n",
+					__func__);
+
+#if defined(CONFIG_VIDEO_MIPI_INTERFACE)
+			/* Enable Interface. */
+			isp_csi2_ctrl_config_if_enable(true);
+			isp_csi2_ctrl_update(false);
+#endif
+
+                     /*Set regulator turned on.*/
+			/*regulator_poweron = 1;*/
+		}
+		break;
+	case V4L2_POWER_STANDBY:
+		/* stand by */
+		break;
+	}
+	/* Save powerstate to know what was before calling POWER_ON. */
+	previous_power = power;
+	return 0;
+}
+
+struct ov8810_platform_data sholest_ov8810_platform_data = {
+	.power_set      = ov8810_sensor_power_set,
+	.priv_data_set  = ov8810_sensor_set_prv_data,
+	.lock_cpufreq   = mapphone_lock_cpufreq,
+	.default_regs   = NULL,
+};
+
+#endif  /* #ifdef CONFIG_VIDEO_OV8810*/
+
+/* We can't change the IOMUX config after bootup
+ * with the current pad configuration architecture,
+ * the next two functions are hack to configure the
+ * camera pads at runtime to save power in standby */
+
+void sholest_camera_lines_safe_mode(void)
+{
+	omap_writew(0x0704, 0x4800207C);
+	/*omap_writew(0x0704, 0x480020D0);*/
+}
+
+void sholest_camera_lines_func_mode(void)
+{
+	omap_writew(0x0704, 0x4800207C);
+	/*omap_writew(0x061C, 0x480020D0);*/
+}
+
+void __init sholest_camera_init(void)
+{
+    omap_cfg_reg(C25_34XX_CAM_XCLKA);
+	omap_cfg_reg(C23_34XX_CAM_FLD);
+#if !defined (CONFIG_VIDEO_MIPI_INTERFACE)
+	omap_cfg_reg(AG17_34XX_CAM_D0);
+	omap_cfg_reg(AH17_34XX_CAM_D1);
+#endif
+    omap_cfg_reg(H2_34XX_GPMC_A3);
+
+#if defined (CONFIG_VIDEO_MIPI_INTERFACE)
+    omap_cfg_reg(AG17_34XX_CAM_D0);
+	omap_cfg_reg(AH17_34XX_CAM_D1);
+	omap_cfg_reg(AD17_34XX_CSI2_DX0);
+	omap_cfg_reg(AE18_34XX_CSI2_DY0);
+	omap_cfg_reg(AD16_34XX_CSI2_DX1);
+	omap_cfg_reg(AE17_34XX_CSI2_DY1);
+#endif
+
+    /*Initialize F_RDY_N pin for Xenon flash control.*/
+    if (gpio_request(36, "xenon flash ready pin") != 0)
+	pr_err("%s: Xenon flash ready pin control failure.\n",__func__);
+
+    gpio_direction_input(36);
+}
+
diff --git a/arch/arm/mach-omap2/board-sholest-flash.c b/arch/arm/mach-omap2/board-sholest-flash.c
new file mode 100644
index 0000000..e62a87c
--- /dev/null
+++ b/arch/arm/mach-omap2/board-sholest-flash.c
@@ -0,0 +1,120 @@
+/*
+ * linux/arch/arm/mach-omap2/board-sholest-flash.c
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * Modified from mach-omap2/board-3430sdp-flash.c
+ *
+ * Copyright (c) 2007 Texas Instruments
+ *
+ * Modified from mach-omap2/board-2430sdp-flash.c
+ * Author: Rohit Choraria <rohitkc@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/onenand_regs.h>
+#include <linux/types.h>
+#include <linux/io.h>
+
+#include <asm/mach/flash.h>
+#include <mach/onenand.h>
+#include <mach/board.h>
+#include <mach/gpmc.h>
+#include <mach/nand.h>
+
+#define NAND_GPMC_CS		0
+
+static struct mtd_partition sdp_nand_partitions[] = {
+	/* All the partition sizes are listed in terms of NAND block size */
+	{
+		.name		= "X-Loader-NAND",
+		.offset		= 0,
+		.size		= 4 * (64 * 2048),
+		.mask_flags	= MTD_WRITEABLE,	/* force read-only */
+	},
+	{
+		.name		= "U-Boot-NAND",
+		.offset		= MTDPART_OFS_APPEND,	/* Offset = 0x80000 */
+		.size		= 4 * (64 * 2048),
+		.mask_flags	= MTD_WRITEABLE,	/* force read-only */
+	},
+	{
+		.name		= "Boot Env-NAND",
+
+		.offset		= MTDPART_OFS_APPEND,	/* Offset = 0x100000 */
+		.size		= 2 * (64 * 2048),
+	},
+	{
+		.name		= "Kernel-NAND",
+		.offset		= MTDPART_OFS_APPEND,	/* Offset = 0x140000 */
+		.size		= 32 * (64 * 2048),
+
+
+	},
+	{
+		.name		= "File System - NAND",
+		.size		= MTDPART_SIZ_FULL,
+		.offset		= MTDPART_OFS_APPEND,	/* Offset = 0x540000 */
+	},
+};
+
+
+static struct omap_nand_platform_data sdp_nand_data = {
+	.parts		= sdp_nand_partitions,
+	.nr_parts	= ARRAY_SIZE(sdp_nand_partitions),
+	.nand_setup	= NULL,
+	.dma_channel	= -1,		/* disable DMA in OMAP NAND driver */
+	.dev_ready	= NULL,
+	.cs		= NAND_GPMC_CS,
+	.gpmc_cs_baseaddr = (void *)(OMAP34XX_GPMC_VIRT + GPMC_CS0_BASE +
+		NAND_GPMC_CS*GPMC_CS_SIZE),
+	.gpmc_baseaddr  = (void *)(OMAP34XX_GPMC_VIRT),
+};
+
+
+static struct resource sdp_nand_resource = {
+	.flags		= IORESOURCE_MEM,
+};
+
+
+static struct platform_device sdp_nand_device = {
+	.name		= "omap2-nand",
+	.id		= 0,
+	.dev		= {
+		.platform_data	= &sdp_nand_data,
+	},
+	.num_resources	= 1,
+	.resource	= &sdp_nand_resource,
+};
+
+static int omap_nand_dev_ready(struct omap_nand_platform_data *data)
+{
+	printk(KERN_INFO "RDY/BSY line is connected!\n");
+	return 0;
+}
+
+/**
+ * sholest_flash_init - Identify devices connected to GPMC and register.
+ *
+ * @return - void.
+ */
+void __init sholest_flash_init(void)
+{
+#if !defined(CONFIG_CUP2TOUCH)
+	/* We know the RDY/BSY line is connected now */
+	sdp_nand_data.dev_ready = omap_nand_dev_ready;
+#endif
+
+	if (platform_device_register(&sdp_nand_device) < 0)
+		printk(KERN_ERR "Unable to register NAND device\n");
+
+	return;
+}
diff --git a/arch/arm/mach-omap2/board-sholest-gpio.c b/arch/arm/mach-omap2/board-sholest-gpio.c
new file mode 100644
index 0000000..7133644
--- /dev/null
+++ b/arch/arm/mach-omap2/board-sholest-gpio.c
@@ -0,0 +1,304 @@
+/*
+ * board-sholest-gpio.c
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* Date	 Author	  Comment
+ * ===========  ==============  ==============================================
+ * Jun-23-2009  Motorola	Initial revision.
+ */
+
+#include <linux/module.h>
+
+#ifdef CONFIG_GPIODEV
+#include <linux/gpiodev.h>
+#endif
+
+#ifdef CONFIG_GPIO_MAPPING
+#include <linux/gpio_mapping.h>
+#endif
+
+#ifdef CONFIG_ARM_OF
+#include <mach/dt_path.h>
+#include <asm/prom.h>
+#endif
+
+#ifdef CONFIG_GPIODEV
+#define GPIO_DEVICE_SIZE 20
+#define GPIO_DEVICE_UNUSED 0xFFFF
+
+static struct gpio_device gpio_devs[GPIO_DEVICE_SIZE] = {
+	{
+		149,
+		"gps_rts",
+		GPIODEV_CONFIG_OUTPUT_LOW,
+		GPIODEV_CONFIG_INVALID,
+		GPIODEV_FLAG_CONFIGURABLE | GPIODEV_FLAG_LOWLEVELACCESS,
+	},
+	{
+		59,
+		"gps_reset",
+		GPIODEV_CONFIG_OUTPUT_LOW,
+		GPIODEV_CONFIG_INVALID,
+		GPIODEV_FLAG_CONFIGURABLE | GPIODEV_FLAG_LOWLEVELACCESS,
+	},
+	{
+		23,
+		"gps_standby",
+		GPIODEV_CONFIG_OUTPUT_LOW,
+		GPIODEV_CONFIG_INVALID,
+		GPIODEV_FLAG_CONFIGURABLE | GPIODEV_FLAG_LOWLEVELACCESS,
+	},
+	{
+		160,
+		"gps_interrupt",
+		GPIODEV_CONFIG_INPUT | GPIODEV_CONFIG_INT_REDG,
+		GPIODEV_CONFIG_INVALID,
+		GPIODEV_FLAG_CONFIGURABLE | GPIODEV_FLAG_LOWLEVELACCESS,
+	},
+	{
+		GPIO_DEVICE_UNUSED,
+	},
+};
+
+static struct gpio_device_platform_data gpio_device_data = {
+	.name = "mapphone-gpiodev",
+	.info = gpio_devs,
+};
+
+static struct platform_device sholest_gpiodev_device = {
+	.name = GPIO_DEVICE_DEV_NAME,
+	.id = 0,
+	.dev = {
+		.platform_data = &gpio_device_data,
+	},
+};
+
+#ifdef CONFIG_ARM_OF
+/**
+ * Below structure definition should strictly comform to corresponding
+ * HW device tree format
+ */
+struct omap_gpiodev_entry {
+	u32 pin_num;				/* GPIO pin number  */
+	char name[GPIO_DEVICE_NAME_LEN];	/* GPIODev name */
+	u32 setting;				/* GPIO pin setting */
+} __attribute__ ((__packed__));
+
+static void gpiodev_devs_init(void *p_data)
+{
+	struct omap_gpiodev_entry *p = p_data;
+	struct gpio_device *p_devs = gpio_devs;
+	int i = 0;
+
+	while ((i < GPIO_DEVICE_NAME_LEN) && (' ' != p->name[i]))
+		i++;
+	p->name[i] = '\0';
+
+	for (i = 0; i < GPIO_DEVICE_SIZE; i++) {
+		if (p_devs[i].pin_nr == GPIO_DEVICE_UNUSED) {
+			p_devs[i].pin_nr = p->pin_num;
+			strcpy(p_devs[i].device_name, p->name);
+			p_devs[i].init_config = p->setting;
+			p_devs[i].current_config = GPIODEV_CONFIG_INVALID;
+			p_devs[i].flags = GPIODEV_FLAG_CONFIGURABLE |
+						GPIODEV_FLAG_LOWLEVELACCESS;
+
+			if (i != (GPIO_DEVICE_SIZE - 1))
+				p_devs[i + 1].pin_nr = GPIO_DEVICE_UNUSED;
+
+			printk(KERN_INFO "GPIODev: Add new device [%s] setting!\n",
+					p->name);
+			return;
+		}
+
+		if (strncmp(p_devs[i].device_name, p->name,
+			GPIO_DEVICE_NAME_LEN) == 0) {
+			p_devs[i].pin_nr = p->pin_num;
+			p_devs[i].init_config = p->setting;
+			p_devs[i].current_config = GPIODEV_CONFIG_INVALID;
+			p_devs[i].flags = GPIODEV_FLAG_CONFIGURABLE |
+						GPIODEV_FLAG_LOWLEVELACCESS;
+
+			printk(KERN_INFO "GPIODev: Overwrite device [%s] setting!\n",
+					p->name);
+			return;
+		}
+
+		if (i == (GPIO_DEVICE_SIZE - 1))
+			printk(KERN_ERR "GPIODev: Too big gpiodev count!\n");
+	}
+}
+
+static void gpio_devs_of_init(void)
+{
+	int size, unit_size, i, count;
+	struct device_node *node;
+	const void *prop;
+
+	node = of_find_node_by_path(DT_PATH_GPIOGEV);
+	if (node == NULL) {
+		printk(KERN_ERR
+				"Unable to read node %s from device tree!\n",
+				DT_PATH_GPIOGEV);
+		return;
+	}
+
+	unit_size = sizeof(struct omap_gpiodev_entry);
+	prop = of_get_property(node, DT_PROP_GPIODEV_INIT, &size);
+	if ((!prop) || (size % unit_size)) {
+		printk(KERN_ERR "Read property %s error!\n",
+				DT_PROP_GPIODEV_INIT);
+		of_node_put(node);
+		return;
+	}
+
+	count = size / unit_size;
+	printk(KERN_INFO "gpio_dev_size = %d\n", count);
+
+	for (i = 0; i < count; i++)
+		gpiodev_devs_init((struct omap_gpiodev_entry *)prop + i);
+
+	of_node_put(node);
+	return;
+}
+#endif
+
+static int __init sholest_init_gpiodev(void)
+{
+	int i;
+
+#ifdef CONFIG_ARM_OF
+	gpio_devs_of_init();
+#endif
+
+	for (i = 0; i < GPIO_DEVICE_SIZE; i++) {
+		if (gpio_devs[i].pin_nr == GPIO_DEVICE_UNUSED)
+			break;
+	}
+	gpio_device_data.info_count = i;
+
+	return platform_device_register(&sholest_gpiodev_device);
+}
+device_initcall(sholest_init_gpiodev);
+#endif
+
+#ifdef CONFIG_GPIO_MAPPING
+#define GPIO_MAP_SIZE 50
+
+static struct gpio_mapping gpio_map_table[GPIO_MAP_SIZE] = {
+	{1, 27, "lcd_panel_reset"},
+	{1, 41, "lcd_panel_sd"},
+	{1, 149, "usb_ipc_phy_reset"},
+	{1, 164, "touch_panel_reset"},
+	{1, 163, "mmc_detect"},
+	{1, 110, "slider_data"},
+	{1, 65, "wlan_host_wake"},
+};
+
+#ifdef CONFIG_ARM_OF
+struct omap_gpio_map_entry {
+	u32 pin_num;
+	char name[GPIO_MAP_NAME_SIZE];
+} __attribute__ ((__packed__));
+
+void trim_gpio_map_string(char *s)
+{
+	int i;
+
+	/* ignore all characters behind space key */
+	for (i = 0; i < GPIO_MAP_NAME_SIZE; i++) {
+		if (' ' == s[i]) {
+			s[i] = '\0';
+			return;
+		}
+	}
+
+	printk(KERN_ERR "Too long gpio map string name!\n");
+}
+#endif
+#endif
+
+void __init sholest_gpio_mapping_init(void)
+{
+#ifdef CONFIG_GPIO_MAPPING
+#ifdef CONFIG_ARM_OF
+	struct device_node *node;
+	const void *prop;
+	int i, j, size, unit_size;
+	char name[GPIO_MAP_NAME_SIZE];
+
+	node = of_find_node_by_path(DT_PATH_GPIO);
+	if (node == NULL) {
+		printk(KERN_ERR
+				"Unable to read node %s from device tree!\n",
+				DT_PATH_GPIO);
+		return;
+	}
+
+	unit_size = sizeof(struct omap_gpio_map_entry);
+	prop = of_get_property(node, DT_PROP_GPIO_MAP, &size);
+	if ((!prop) || (size % unit_size)) {
+		printk(KERN_ERR "Read property %s error!\n",
+				DT_PROP_GPIO_MAP);
+		of_node_put(node);
+		return;
+	}
+
+	for (i = 0; i < size / unit_size; i++) {
+		struct omap_gpio_map_entry *p =
+				(struct omap_gpio_map_entry *) prop;
+
+		memcpy((void *) name, p->name, GPIO_MAP_NAME_SIZE);
+		trim_gpio_map_string(name);
+
+		for (j = 0; j < GPIO_MAP_SIZE; j++) {
+			if (gpio_map_table[j].used == 0) {
+				gpio_map_table[j].used = 1;
+				gpio_map_table[j].pin_num = p->pin_num;
+				strncpy(gpio_map_table[j].name, name,
+						GPIO_MAP_NAME_SIZE);
+				break;
+			} else if (strncmp(gpio_map_table[j].name, name,
+					GPIO_MAP_NAME_SIZE) == 0) {
+				gpio_map_table[j].pin_num = p->pin_num;
+				break;
+			}
+		}
+
+		if (j == GPIO_MAP_SIZE)
+			printk(KERN_ERR "Unable to write gpio_map_table\n");
+		else
+			printk(KERN_INFO "GPIO mapping write: pin = %d, name = %s\n",
+						gpio_map_table[j].pin_num,
+						gpio_map_table[j].name);
+
+		prop += unit_size;
+	}
+
+	of_node_put(node);
+	printk(KERN_INFO "DT overwrite GPIO Mapping done!\n");
+#else
+	printk(KERN_INFO "GPIO Mapping: Using no-dt configuration!\n");
+#endif
+	gpio_mapping_init(gpio_map_table, GPIO_MAP_SIZE);
+	printk(KERN_INFO "GPIO Mapping init done!\n");
+#else
+	printk(KERN_INFO "GPIO Mapping unused!\n");
+#endif
+}
diff --git a/arch/arm/mach-omap2/board-sholest-hsmmc.c b/arch/arm/mach-omap2/board-sholest-hsmmc.c
new file mode 100644
index 0000000..ae0282e
--- /dev/null
+++ b/arch/arm/mach-omap2/board-sholest-hsmmc.c
@@ -0,0 +1,350 @@
+/*
+ * linux/arch/arm/mach-omap2/board-sholest-hsmm.c
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * Derived from linux/arch/arm/mach-omap2/board-sdp-hsmmc.c
+ *
+ * Copyright (C) 2007-2008 Texas Instruments
+ * Copyright (C) 2008 Nokia Corporation
+ * Author: Texas Instruments
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/regulator/consumer.h>
+
+#include <mach/hardware.h>
+#include <mach/control.h>
+#include <mach/mmc.h>
+#include <mach/board.h>
+#include <mach/gpio.h>
+#include <mach/mux.h>
+
+#define GPIO_SIGNAL_MMC_DET 163
+
+static const int mmc2_cd_gpio = OMAP_MAX_GPIO_LINES + 1;
+
+static int hsmmc_card_detect(int irq)
+{
+	return !gpio_get_value_cansleep(GPIO_SIGNAL_MMC_DET);
+}
+
+#ifdef CONFIG_OMAP_HS_MMC2
+extern int sholest_wifi_status(int irq);
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+extern int sholest_wifi_status_register(void (*callback)(int card_present,
+						void *dev_id), void *dev_id);
+#endif
+
+static int hsmmc2_card_detect(int irq)
+{
+	return sholest_wifi_status(irq);
+}
+#endif
+
+/*
+ * MMC Slot Initialization.
+ */
+static struct regulator *hsmmc_regulator;
+static unsigned char hsmmc_regulator_is_on;
+DEFINE_MUTEX(regulator_lock);
+
+static int hsmmc_late_init(struct device *dev)
+{
+	int ret = 0;
+
+	/*
+	 * Configure GPIO parameters for MMC hotplug irq
+	 */
+	ret = gpio_request(GPIO_SIGNAL_MMC_DET, "mmc_detect");
+	if (ret < 0)
+		goto err;
+	ret = gpio_direction_input(GPIO_SIGNAL_MMC_DET);
+	if (ret < 0)
+		goto err2;
+
+	hsmmc_regulator = regulator_get(NULL, "vwlan2");
+	if (IS_ERR(hsmmc_regulator)) {
+		dev_dbg(dev, "vwlan2 regulator missing\n");
+		ret = PTR_ERR(hsmmc_regulator);
+		goto err2;
+	}
+
+	return ret;
+err2:
+	gpio_free(GPIO_SIGNAL_MMC_DET);
+err:
+	dev_err(dev, "Failed to configure GPIO MMC_DET\n");
+	return ret;
+}
+
+static void hsmmc_cleanup(struct device *dev)
+{
+	gpio_free(GPIO_SIGNAL_MMC_DET);
+	if (hsmmc_regulator)
+		regulator_put(hsmmc_regulator);
+}
+
+#ifdef CONFIG_PM
+/*
+ * To mask and unmask MMC Card Detect Interrupt
+ * mask : 1
+ * unmask : 0
+ */
+static int mask_cd_interrupt(int mask)
+{
+	return 0;
+}
+
+static int hsmmc_suspend(struct device *dev, int slot)
+{
+	int ret = 0;
+
+	disable_irq(gpio_to_irq(GPIO_SIGNAL_MMC_DET));
+	ret = mask_cd_interrupt(1);
+
+	return ret;
+}
+
+static int hsmmc_resume(struct device *dev, int slot)
+{
+	int ret = 0;
+
+	enable_irq(gpio_to_irq(GPIO_SIGNAL_MMC_DET));
+	ret = mask_cd_interrupt(0);
+
+	return ret;
+}
+#endif
+
+static int hsmmc_set_power(struct device *dev, int slot, int power_on,
+				int vdd)
+{
+	u32 reg;
+	int ret = 0;
+
+	if (power_on) {
+		reg = omap_ctrl_readl(OMAP2_CONTROL_DEVCONF0);
+		reg |= OMAP2_MMCSDIO1ADPCLKISEL;
+		omap_ctrl_writel(reg, OMAP2_CONTROL_DEVCONF0);
+
+		reg = omap_ctrl_readl(OMAP343X_CONTROL_PBIAS_LITE);
+		reg &= ~OMAP2_PBIASSPEEDCTRL0;
+		reg &= ~OMAP2_PBIASLITEPWRDNZ0;
+		omap_ctrl_writel(reg, OMAP343X_CONTROL_PBIAS_LITE);
+
+		mutex_lock(&regulator_lock);
+		if (!hsmmc_regulator_is_on) {
+			hsmmc_regulator_is_on = 1;
+			regulator_enable(hsmmc_regulator);
+			msleep(4);
+		}
+		mutex_unlock(&regulator_lock);
+
+		reg = omap_ctrl_readl(OMAP343X_CONTROL_PBIAS_LITE);
+		reg |= OMAP2_PBIASLITEPWRDNZ0;
+		if ((1 << vdd) <= MMC_VDD_165_195)
+			reg &= ~OMAP2_PBIASLITEVMODE0;
+		else
+			reg |= OMAP2_PBIASLITEVMODE0;
+		omap_ctrl_writel(reg, OMAP343X_CONTROL_PBIAS_LITE);
+
+		return ret;
+	} else {
+		reg = omap_ctrl_readl(OMAP343X_CONTROL_PBIAS_LITE);
+		reg &= ~OMAP2_PBIASLITEPWRDNZ0;
+		omap_ctrl_writel(reg, OMAP343X_CONTROL_PBIAS_LITE);
+
+		mutex_lock(&regulator_lock);
+		if (hsmmc_regulator_is_on) {
+			hsmmc_regulator_is_on = 0;
+			regulator_disable(hsmmc_regulator);
+			msleep(20);
+		}
+		mutex_unlock(&regulator_lock);
+
+		reg = omap_ctrl_readl(OMAP343X_CONTROL_PBIAS_LITE);
+		reg |= (OMAP2_PBIASLITEPWRDNZ0 | OMAP2_PBIASLITEVMODE0);
+		omap_ctrl_writel(reg, OMAP343X_CONTROL_PBIAS_LITE);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_MMC_TST
+int ex_hsmmc_set_power(struct device *dev, int slot, int power_on,
+						int vdd)
+{
+    hsmmc_set_power(dev, slot, power_on, vdd);
+    return 0;
+}
+EXPORT_SYMBOL(ex_hsmmc_set_power);
+#endif
+
+#if defined(CONFIG_OMAP_HS_MMC2)
+static int hsmmc2_late_init(struct device *dev)
+{
+	return 0;
+}
+
+static void hsmmc2_cleanup(struct device *dev)
+{
+}
+
+static int hsmmc2_set_power(struct device *dev, int slot, int power_on,
+				int vdd)
+{
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int hsmmc2_suspend(struct device *dev, int slot)
+{
+	int ret = 0;
+	return ret;
+}
+
+static int hsmmc2_resume(struct device *dev, int slot)
+{
+	int ret = 0;
+	return ret;
+}
+#endif
+#endif
+
+#if defined(CONFIG_OMAP_HS_MMC3)
+static int hsmmc3_set_power(struct device *dev, int slot, int power_on,
+				int vdd)
+{
+	/* Power to the slot is hard wired */
+	return 0;
+}
+#endif
+
+static struct omap_mmc_platform_data mmc1_data = {
+	.nr_slots			= 1,
+	.init				= hsmmc_late_init,
+	.cleanup			= hsmmc_cleanup,
+#ifdef CONFIG_PM
+	.suspend			= hsmmc_suspend,
+	.resume				= hsmmc_resume,
+#endif
+	.dma_mask			= 0xffffffff,
+	.slots[0] = {
+		.wires			= 8,
+		.set_power		= hsmmc_set_power,
+		.ocr_mask		= MMC_VDD_32_33 | MMC_VDD_33_34 |
+						MMC_VDD_165_195,
+		.name			= "first slot",
+		/* we get car_detect_irq later */
+		.card_detect_irq	= 0,
+		.card_detect            = hsmmc_card_detect,
+	},
+};
+
+#if defined(CONFIG_OMAP_HS_MMC2)
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+static struct sdio_embedded_func wifi_func_array[] = {
+	{
+		.f_class        = SDIO_CLASS_NONE,
+		.f_maxblksize   = 0,
+	},
+	{
+		.f_class        = SDIO_CLASS_WLAN,
+		.f_maxblksize   = 512,
+	},
+};
+
+static struct embedded_sdio_data sholest_wifi_emb_data = {
+	.cis    = {
+		.vendor         = 0x104c,
+		.device         = 0x9066,
+		.blksize        = 512,
+		.max_dtr        = 24000000,
+	},
+	.cccr   = {
+		.multi_block    = 1,
+		.low_speed      = 0,
+		.wide_bus       = 1,
+		.high_power     = 0,
+		.high_speed     = 0,
+	},
+	.funcs  = wifi_func_array,
+	.num_funcs = 2,
+};
+#endif
+
+static struct omap_mmc_platform_data mmc2_data = {
+	.nr_slots			= 1,
+	.init				= hsmmc2_late_init,
+	.cleanup			= hsmmc2_cleanup,
+#ifdef CONFIG_PM
+	.suspend			= hsmmc2_suspend,
+	.resume				= hsmmc2_resume,
+#endif
+	.dma_mask			= 0xffffffff,
+#ifndef CONFIG_MMC_EMBEDDED_SDIO
+	.name				= "TIWLAN_SDIO",
+#endif
+	.slots[0] = {
+		.wires			= 4,
+		.set_power		= hsmmc2_set_power,
+		.ocr_mask		= MMC_VDD_32_33 | MMC_VDD_33_34 |
+						MMC_VDD_165_195,
+		.name			= "first slot",
+		.internal_clock		= 1,
+		.card_detect_irq        = 0,
+		.card_detect            = hsmmc2_card_detect,
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+		.embedded_sdio		= &sholest_wifi_emb_data,
+		.register_status_notify	= &sholest_wifi_status_register,
+#endif
+	},
+};
+#endif
+
+#if defined(CONFIG_OMAP_HS_MMC3)
+static struct omap_mmc_platform_data mmc3_data = {
+	.nr_slots			= 1,
+	.init				= NULL,
+	.cleanup			= NULL,
+	.dma_mask			= 0xffffffff,
+	.slots[0] = {
+		.wires			= 4,
+		.set_power		= hsmmc3_set_power,
+		.ocr_mask		= MMC_VDD_32_33 | MMC_VDD_33_34,
+		.name			= "first slot",
+
+		.card_detect_irq        = 0,
+		.card_detect            = NULL,
+	},
+};
+#endif
+
+static struct omap_mmc_platform_data *hsmmc_data[OMAP34XX_NR_MMC];
+
+void __init sholest_hsmmc_init(void)
+{
+	hsmmc_data[0] = &mmc1_data;
+
+	mmc1_data.slots[0].card_detect_irq = gpio_to_irq(GPIO_SIGNAL_MMC_DET);
+
+#if defined(CONFIG_OMAP_HS_MMC2)
+	hsmmc_data[1] = &mmc2_data;
+#endif
+#if defined(CONFIG_OMAP_HS_MMC3)
+	hsmmc_data[2] = &mmc3_data;
+#endif
+	omap2_init_mmc(hsmmc_data, OMAP34XX_NR_MMC);
+}
diff --git a/arch/arm/mach-omap2/board-sholest-keypad.c b/arch/arm/mach-omap2/board-sholest-keypad.c
new file mode 100644
index 0000000..b3af0a8
--- /dev/null
+++ b/arch/arm/mach-omap2/board-sholest-keypad.c
@@ -0,0 +1,158 @@
+/*
+ * arch/arm/mach-omap2/board-sholest-keypad.c
+ *
+ * Copyright (C) 2009 Google, Inc.
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/gpio_event.h>
+
+#include <mach/mux.h>
+#include <mach/gpio.h>
+#include <mach/keypad.h>
+#include <mach/board-sholest.h>
+
+#ifdef CONFIG_ARM_OF
+#include <mach/dt_path.h>
+#include <asm/prom.h>
+#endif
+
+static unsigned int sholest_col_gpios[] = { 43, 56, 57 };
+static unsigned int sholest_row_gpios[] = { 37, 39 };
+
+#define KEYMAP_INDEX(col, row) ((col)*ARRAY_SIZE(sholest_row_gpios) + (row))
+
+static const unsigned short sholest_keymap[ARRAY_SIZE(sholest_col_gpios) *
+                                           ARRAY_SIZE(sholest_row_gpios)] = {
+	[KEYMAP_INDEX(0, 0)] = KEY_VOLUMEDOWN,
+    [KEYMAP_INDEX(0, 1)] = KEY_VOLUMEUP,
+	
+	[KEYMAP_INDEX(1, 0)] = KEY_CAMERA-1,    /* camera 1 key, steal KEY_HP*/
+	[KEYMAP_INDEX(1, 1)] = KEY_CAMERA,      /* "camera 2" key */
+
+	[KEYMAP_INDEX(2, 0)] = KEY_RESERVED,
+	[KEYMAP_INDEX(2, 1)] = KEY_MACRO
+};
+
+static struct gpio_event_matrix_info sholest_keypad_matrix_info = {
+	.info.func = gpio_event_matrix_func,
+	.keymap = sholest_keymap,
+	.output_gpios = sholest_col_gpios,
+	.input_gpios = sholest_row_gpios,
+#ifndef CONFIG_ARM_OF
+	.sw_fixup = fixup,
+#endif
+	.noutputs = ARRAY_SIZE(sholest_col_gpios),
+	.ninputs = ARRAY_SIZE(sholest_row_gpios),
+	.settle_time.tv.nsec = 40 * NSEC_PER_USEC,
+	.poll_time.tv.nsec = 20 * NSEC_PER_MSEC,
+	.flags = GPIOKPF_LEVEL_TRIGGERED_IRQ | GPIOKPF_REMOVE_PHANTOM_KEYS |
+		 GPIOKPF_PRINT_UNMAPPED_KEYS /*| GPIOKPF_PRINT_MAPPED_KEYS*/
+};
+
+static struct gpio_event_direct_entry sholest_keypad_switch_map[] = {
+	{ GPIO_SILENCE_KEY,	SW_HEADPHONE_INSERT }
+};
+
+static struct gpio_event_input_info sholest_keypad_switch_info = {
+	.info.func = gpio_event_input_func,
+	.flags = 0,
+	.type = EV_SW,
+	.keymap = sholest_keypad_switch_map,
+	.keymap_size = ARRAY_SIZE(sholest_keypad_switch_map)
+};
+
+static struct gpio_event_info *sholest_keypad_info[] = {
+	&sholest_keypad_matrix_info.info,
+	&sholest_keypad_switch_info.info,
+};
+
+static struct gpio_event_platform_data sholest_keypad_data = {
+	.name = "sholes-keypad",
+	.info = sholest_keypad_info,
+	.info_count = ARRAY_SIZE(sholest_keypad_info)
+};
+
+static struct platform_device sholest_keypad_device = {
+	.name = GPIO_EVENT_DEV_NAME,
+	.id = 0,
+	.dev		= {
+		.platform_data	= &sholest_keypad_data,
+	},
+};
+
+#ifdef CONFIG_ARM_OF
+static int __init sholest_dt_kp_init(void)
+{
+	struct device_node *kp_node;
+	const void *kp_prop;
+
+	if ((kp_node = of_find_node_by_path(DT_PATH_KEYPAD))) {
+		if ((kp_prop = of_get_property(kp_node, \
+				DT_PROP_KEYPAD_ROWS, NULL)))
+			sholest_keypad_matrix_info.ninputs = \
+				*(int *)kp_prop;
+
+		if ((kp_prop = of_get_property(kp_node, \
+				DT_PROP_KEYPAD_COLS, NULL)))
+			sholest_keypad_matrix_info.noutputs = \
+				*(int *)kp_prop;
+
+		if ((kp_prop = of_get_property(kp_node, \
+				DT_PROP_KEYPAD_ROWREG, NULL)))
+			sholest_keypad_matrix_info.input_gpios = \
+				(int *)kp_prop;
+
+		if ((kp_prop = of_get_property(kp_node, \
+				DT_PROP_KEYPAD_COLREG, NULL)))
+			sholest_keypad_matrix_info.output_gpios = \
+				(int *)kp_prop;
+
+		if ((kp_prop = of_get_property(kp_node, \
+				DT_PROP_KEYPAD_MAPS, NULL)))
+			sholest_keypad_matrix_info.keymap = \
+				(unsigned short *)kp_prop;
+
+		of_node_put(kp_node);
+	}
+
+	return kp_node ? 0 : -ENODEV;
+}
+#endif
+
+static int __init sholest_init_keypad(void)
+{
+#ifdef CONFIG_ARM_OF
+	if (sholest_dt_kp_init())
+		printk(KERN_INFO "Keypad: using non-dt configuration\n");
+#endif
+
+	/* keypad rows */
+	omap_cfg_reg(K4_34XX_GPIO37);
+	omap_cfg_reg(R3_34XX_GPIO39);
+
+	/* keypad columns */
+	omap_cfg_reg(K3_34XX_GPIO43_OUT);
+	omap_cfg_reg(R8_34XX_GPIO56_OUT);
+	omap_cfg_reg(P8_34XX_GPIO57_OUT);
+
+	/* switches */
+	omap_cfg_reg(AB2_34XX_GPIO177);
+	omap_cfg_reg(AH17_34XX_GPIO100);
+
+	return platform_device_register(&sholest_keypad_device);
+}
+
+device_initcall(sholest_init_keypad);
diff --git a/arch/arm/mach-omap2/board-sholest-mdtv.c b/arch/arm/mach-omap2/board-sholest-mdtv.c
new file mode 100644
index 0000000..1c26d28
--- /dev/null
+++ b/arch/arm/mach-omap2/board-sholest-mdtv.c
@@ -0,0 +1,109 @@
+/*
+ * linux/arch/arm/mach-omap2/board-MAPPHONE-sensors.c
+ *
+ * Copyright (C) 2009 Google, Inc.
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+#include <linux/regulator/consumer.h>
+
+#include <mach/mux.h>
+#include <mach/gpio.h>
+#include <mach/keypad.h>
+
+#include "linux/i2c/lp3907_i2c.h"
+
+#define SHOLEST_MDTV_INT_GPIO			38
+#define SHOLEST_MDTV_PWDN_GPIO			53
+#define SHOLEST_MDTV_RESET_N_GPIO		54
+#define SHOLEST_MDTV_REG_EN_GPIO		21
+
+static int sholest_lp3907_init(void)
+{
+	printk(KERN_INFO "sholest_lp3907_init()");
+	return 0;
+}
+
+static void sholest_lp3907_exit(void)
+{
+	/*regulator_put(sholest_akm8973_regulator);*/
+}
+
+static int sholest_lp3907_power_on(void)
+{
+	/* EN_T is high */
+	gpio_set_value(SHOLEST_MDTV_REG_EN_GPIO, 1);
+	mdelay(6);	/* stable time */
+
+	/* SPI pin control */
+	/*omap_cfg_reg(F1_34XX_MDTV_INT_ON);*/
+	omap_cfg_reg(AC3_34XX_MDTV_SIMO_ON);
+	omap_cfg_reg(AD4_34XX_MDTV_SOMI_ON);
+	omap_cfg_reg(AD3_34XX_MDTV_CS_ON);
+	omap_cfg_reg(AA3_34XX_MDTV_CLK_ON);
+	mdelay(5);
+
+	printk(KERN_INFO "sholest_lp3907_power_on()");
+	return 0;
+}
+
+static int sholest_lp3907_power_off(void)
+{
+	/* SPI pin control */
+	/*omap_cfg_reg(F1_34XX_MDTV_INT_OFF);*/
+	omap_cfg_reg(AC3_34XX_MDTV_SIMO_OFF);
+	omap_cfg_reg(AD4_34XX_MDTV_SOMI_OFF);
+	omap_cfg_reg(AD3_34XX_MDTV_CS_OFF);
+	omap_cfg_reg(AA3_34XX_MDTV_CLK_OFF);
+
+	/* EN_T is low */
+	gpio_set_value(SHOLEST_MDTV_REG_EN_GPIO, 0);
+	mdelay(6); /* stable time */
+
+	printk(KERN_INFO "sholest_lp3907_power_off()");
+	return 0;
+}
+
+struct lp3907_platform_data sholest_lp3907_data = {
+	.init = sholest_lp3907_init,
+	.exit = sholest_lp3907_exit,
+	.power_on = sholest_lp3907_power_on,
+	.power_off = sholest_lp3907_power_off,
+};
+
+/*
+*	TDMB module initialize.
+*/
+void __init sholest_mdtv_init(void)
+{
+	/* MTV_INT pin */
+	gpio_request(SHOLEST_MDTV_INT_GPIO, "sms1130 int");
+	gpio_direction_input(SHOLEST_MDTV_INT_GPIO);
+	omap_cfg_reg(T3_34XX_GPIO38);
+
+	/* MTV_PWDN pin - low */
+	gpio_request(SHOLEST_MDTV_PWDN_GPIO, "sms1130 pwdn");
+	gpio_direction_output(SHOLEST_MDTV_PWDN_GPIO, 0);
+	omap_cfg_reg(V8_34XX_GPIO53_OUT);
+
+	/* MTV_RST_N pin - low */
+	gpio_request(SHOLEST_MDTV_RESET_N_GPIO, "sms1130 reset");
+	gpio_direction_output(SHOLEST_MDTV_RESET_N_GPIO, 0);
+	omap_cfg_reg(U8_34XX_GPIO54_OUT);
+
+	/* MTV_REG_EN pin - low */
+	gpio_request(SHOLEST_MDTV_REG_EN_GPIO, "lp3907 en");
+	gpio_direction_output(SHOLEST_MDTV_REG_EN_GPIO, 0);
+	omap_cfg_reg(V8_34XX_GPIO53_OUT);
+
+	printk(KERN_INFO "[TDMB] sholest_mdtv_init()\n");
+}
diff --git a/arch/arm/mach-omap2/board-sholest-mmcprobe.c b/arch/arm/mach-omap2/board-sholest-mmcprobe.c
new file mode 100644
index 0000000..adf6c11
--- /dev/null
+++ b/arch/arm/mach-omap2/board-sholest-mmcprobe.c
@@ -0,0 +1,78 @@
+/*
+ * arch/arm/mach-omap2/board-sholest-mmcprobe.c
+ *
+ * Copyright (C) 2007-2009 Google Inc.
+ * Copyright (C) 2009 Motorola Inc.
+ *
+ * San Mehat (san@android.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/err.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+#include <linux/reboot.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/setup.h>
+
+#include <mach/board-sholest.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+#include <mach/mux.h>
+#include <mach/board.h>
+#include <mach/common.h>
+#include <mach/control.h>
+#include <linux/delay.h>
+
+#define CH_BASE_GPIO 120
+
+void sholest_mmcprobe_strobe(int ch, int rpt)
+{
+	int i;
+
+	for (i = 0; i < rpt; i++) {
+		gpio_direction_output(CH_BASE_GPIO + ch, 1);
+		udelay(10);
+		gpio_direction_output(CH_BASE_GPIO + ch, 0);
+		udelay(10);
+	}
+}
+
+void sholest_mmcprobe_set(int ch, int lvl)
+{
+	gpio_direction_output(CH_BASE_GPIO + ch, lvl);
+}
+
+void __init sholest_mmcprobe_init(void)
+{
+	int i;
+
+	printk(KERN_INFO "sholest_mmcprobe: MMC subsystem ganked for debug\n");
+
+	omap_ctrl_writew(0x04, 0x144); /* MMC1_CLK/GPIO120 */
+	omap_ctrl_writew(0x04, 0x146); /* MMC1_CMD/GPIO121 */
+	omap_ctrl_writew(0x04, 0x148); /* MMC1_DAT0/GPIO122 */
+	omap_ctrl_writew(0x04, 0x14a); /* MMC1_DAT1/GPIO123 */
+	omap_ctrl_writew(0x04, 0x14c); /* MMC1_DAT2/GPIO124 */
+	omap_ctrl_writew(0x04, 0x14e); /* MMC1_DAT3/GPIO125 */
+
+	gpio_request(120, "mmcprobe-ch1");
+	gpio_request(121, "mmcprobe-ch2");
+	gpio_request(122, "mmcprobe-ch3");
+	gpio_request(123, "mmcprobe-ch4");
+	gpio_request(124, "mmcprobe-ch5");
+	gpio_request(125, "mmcprobe-ch6");
+
+	for (i = 0; i < 5; i++)
+		sholest_mmcprobe_strobe(i, 1 + i);
+}
diff --git a/arch/arm/mach-omap2/board-sholest-padconf.c b/arch/arm/mach-omap2/board-sholest-padconf.c
new file mode 100644
index 0000000..b6942ab
--- /dev/null
+++ b/arch/arm/mach-omap2/board-sholest-padconf.c
@@ -0,0 +1,1837 @@
+/*
+ * board-sholest-padconf.c
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+
+#include <mach/hardware.h>
+#ifdef CONFIG_ARM_OF
+#include <mach/dt_path.h>
+#include <asm/prom.h>
+#endif
+#ifdef CONFIG_EMU_UART_DEBUG
+#include <mach/board-mapphone-emu_uart.h>
+#endif
+
+struct iomux_range {
+	unsigned int start;
+	unsigned int end;
+};
+
+static struct iomux_range iomux_range_base[] = {
+	{OMAP343X_PADCONF_CORE_CTRL_BASE, OMAP343X_PADCONF_CORE_CTRL_TOP},
+	{OMAP343X_PADCONF_CORE_ETK_BASE, OMAP343X_PADCONF_CORE_ETK_TOP},
+	{OMAP343X_PADCONF_CORE_D2D_BASE, OMAP343X_PADCONF_CORE_D2D_TOP},
+	{OMAP343X_PADCONF_WKUP_BASE, OMAP343X_PADCONF_WKUP_TOP},
+	{OMAP343X_PADCONF_WKUP_D2D_BASE, OMAP343X_PADCONF_WKUP_D2D_TOP}
+};
+
+inline bool is_omap343x_padconf_register(uint16_t offset)
+{
+	unsigned long addr = offset + OMAP343X_CTRL_BASE;
+	unsigned int i;
+
+	if  ((offset & 0x1) != 0x0)
+		return 0;
+
+	for (i = 0; i < ARRAY_SIZE(iomux_range_base); i++)
+		if (addr >= iomux_range_base[i].start &&
+			 addr <= iomux_range_base[i].end)
+			return 1;
+
+	return 0;
+}
+
+static __initdata struct {
+	uint16_t offset;
+	uint16_t setting;
+} padconf_settings[] = {
+	/* SDRC_D0 */
+	{
+	0x0030,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D1 */
+	{
+	0x0032,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D2 */
+	{
+	0x0034,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D3 */
+	{
+	0x0036,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D4 */
+	{
+	0x0038,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D5 */
+	{
+	0x003A,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D6 */
+	{
+	0x003C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D7 */
+	{
+	0x003E,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D8 */
+	{
+	0x0040,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D9 */
+	{
+	0x0042,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D10 */
+	{
+	0x0044,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D11 */
+	{
+	0x0046,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D12 */
+	{
+	0x0048,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D13 */
+	{
+	0x004A,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D14 */
+	{
+	0x004C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D15 */
+	{
+	0x004E,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D16 */
+	{
+	0x0050,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D17 */
+	{
+	0x0052,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D18 */
+	{
+	0x0054,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D19 */
+	{
+	0x0056,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D20 */
+	{
+	0x0058,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D21 */
+	{
+	0x005A,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D22 */
+	{
+	0x005C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D23 */
+	{
+	0x005E,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D24 */
+	{
+	0x0060,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D25 */
+	{
+	0x0062,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D26 */
+	{
+	0x0064,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D27 */
+	{
+	0x0066,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D28 */
+	{
+	0x0068,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D29 */
+	{
+	0x006A,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D30 */
+	{
+	0x006C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D31 */
+	{
+	0x006E,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_CLK */
+	{
+	0x0070,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_DQS0 */
+	{
+	0x0072,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_DQS1 */
+	{
+	0x0074,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_DQS2 */
+	{
+	0x0076,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_DQS3 */
+	{
+	0x0078,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_A1 */
+	{
+	0x007A,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_A2 */
+	{
+	0x007C,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_A3 */
+	{
+	0x007E,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_A4 */
+	{
+	0x0080,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_A5 */
+	{
+	0x0082,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_A6 */
+	{
+	0x0084,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_A7 */
+	{
+	0x0086,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_A8 */
+	{
+	0x0088,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_A9 */
+	{
+	0x008A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE7},
+	    /* GPMC_A10 */
+	{
+	0x008C, OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_D0 */
+	{
+	0x008E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D1 */
+	{
+	0x0090,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D2 */
+	{
+	0x0092,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D3 */
+	{
+	0x0094,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D4 */
+	{
+	0x0096,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D5 */
+	{
+	0x0098,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D6 */
+	{
+	0x009A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D7 */
+	{
+	0x009C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D8 */
+	{
+	0x009E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D9 */
+	{
+	0x00A0,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D10 */
+	{
+	0x00A2,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D11 */
+	{
+	0x00A4,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D12 */
+	{
+	0x00A6,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D13 */
+	{
+	0x00A8,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D14 */
+	{
+	0x00AA,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D15 */
+	{
+	0x00AC,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_NCS0 */
+	{
+	0x00AE,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_NCS1 */
+	{
+	0x00B0,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_NCS2 */
+	{
+	0x00B2, OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_NCS3 */
+	{
+	0x00B4, OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_NCS4 */
+	{
+	0x00B6, OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_NCS5 */
+	{
+	0x00B8, OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_NCS6 */
+	{
+	0x00BA, OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_NCS7 */
+	{
+	0x00BC, OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_CLK */
+	{
+	0x00BE,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_NADV_ALE */
+	{
+	0x00C0,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_NOE */
+	{
+	0x00C2,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_NWE */
+	{
+	0x00C4,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_NBE0_CLE */
+	{
+	0x00C6,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_NBE1 */
+	{
+	0x00C8,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_NWP */
+	{
+	0x00CA,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_WAIT0 */
+	{
+	0x00CC,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_WAIT1 */
+	{
+	0x00CE, OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_WAIT2 */
+	{
+	0x00D0, OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_WAIT3 */
+	{
+	0x00D2,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* DSS_PCLK */
+	{
+	0x00D4, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_HSYNC */
+	{
+	0x00D6, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_VSYNC */
+	{
+	0x00D8, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_ACBIAS */
+	{
+	0x00DA, OMAP343X_PADCONF_MUXMODE4},
+	    /* DSS_DATA0 */
+	{
+	0x00DC,
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_MUXMODE1},
+	    /* DSS_DATA1 */
+	{
+	0x00DE,
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_MUXMODE1},
+	    /* DSS_DATA2 */
+	{
+	0x00E0,
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_MUXMODE1},
+	    /* DSS_DATA3 */
+	{
+	0x00E2,
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_MUXMODE1},
+	    /* DSS_DATA4 */
+	{
+	0x00E4,
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_MUXMODE1},
+	    /* DSS_DATA5 */
+	{
+	0x00E6,
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_MUXMODE1},
+	    /* DSS_DATA6 */
+	{
+	0x00E8, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA7 */
+	{
+	0x00EA, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA8 */
+	{
+	0x00EC, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA9 */
+	{
+	0x00EE, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA10 */
+	{
+	0x00F0, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA11 */
+	{
+	0x00F2, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA12 */
+	{
+	0x00F4, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA13 */
+	{
+	0x00F6, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA14 */
+	{
+	0x00F8, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA15 */
+	{
+	0x00FA, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA16 */
+	{
+	0x00FC, OMAP343X_PADCONF_MUXMODE4},
+	    /* DSS_DATA17 */
+	{
+	0x00FE,
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* DSS_DATA18 */
+	{
+	0x0100,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* DSS_DATA19 */
+	{
+	0x0102, OMAP343X_PADCONF_MUXMODE2},
+	    /* DSS_DATA20 */
+	{
+	0x0104,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* DSS_DATA21 */
+	{
+	0x0106, OMAP343X_PADCONF_MUXMODE2},
+	    /* DSS_DATA22 */
+	{
+	0x0108,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* DSS_DATA23 */
+	{
+	0x010A, OMAP343X_PADCONF_MUXMODE4},
+	    /* CAM_HS */
+	{
+	0x010C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_VS */
+	{
+	0x010E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_XCLKA */
+	{
+	0x0110, OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_PCLK */
+	{
+	0x0112,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_FLD */
+	{
+	0x0114, OMAP343X_PADCONF_MUXMODE4},
+	    /* CAM_D0 */
+	{
+	0x0116,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* CAM_D1 */
+	{
+	0x0118,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* CAM_D2 */
+	{
+	0x011A,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_D3 */
+	{
+	0x011C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_D4 */
+	{
+	0x011E,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_D5 */
+	{
+	0x0120,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_D6 */
+	{
+	0x0122,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_D7 */
+	{
+	0x0124,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_D8 */
+	{
+	0x0126,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_D9 */
+	{
+	0x0128,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_D10 */
+	{
+	0x012A,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_D11 */
+	{
+	0x012C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_XCLKB */
+	{
+	0x012E,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* CAM_WEN */
+	{
+	0x0130, OMAP343X_PADCONF_MUXMODE2},
+	    /* CAM_STROBE */
+	{
+	0x0132, OMAP343X_PADCONF_MUXMODE0},
+	    /* CSI2_DX0 */
+	{
+	0x0134,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE7},
+	    /* CSI2_DY0 */
+	{
+	0x0136,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE7},
+	    /* CSI2_DX1 */
+	{
+	0x0138,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE7},
+	    /* CSI2_DY1 */
+	{
+	0x013A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE7},
+	    /* MCBSP2_FSX */
+	{
+	0x013C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MCBSP2_CLKX */
+	{
+	0x013E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MCBSP2_DR */
+	{
+	0x0140,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MCBSP2_DX */
+	{
+	0x0142,
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC1_CLK */
+	{
+	0x0144, OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC1_CMD */
+	{
+	0x0146,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC1_DAT0 */
+	{
+	0x0148,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC1_DAT1 */
+	{
+	0x014A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC1_DAT2 */
+	{
+	0x014C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC1_DAT3 */
+	{
+	0x014E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC1_DAT4 */
+	{
+	0x0150,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* MMC1_DAT5 */
+	{
+	0x0152,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* MMC1_DAT6 */
+	{
+	0x0154,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* MMC1_DAT7 */
+	{
+	0x0156,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* MMC2_CLK */
+	{
+	0x0158,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC2_CMD */
+	{
+	0x015A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC2_DAT0 */
+	{
+	0x015C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC2_DAT1 */
+	{
+	0x015E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC2_DAT2 */
+	{
+	0x0160,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC2_DAT3 */
+	{
+	0x0162,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC2_DAT4 */
+	{
+	0x0164, OMAP343X_PADCONF_MUXMODE4},
+	    /* MMC2_DAT5 */
+	{
+	0x0166,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MMC2_DAT6 */
+	{
+	0x0168,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MMC2_DAT7 */
+	{
+	0x016A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MCBSP3_DX */
+	{
+	0x016C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MCBSP3_DR */
+	{
+	0x016E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MCBSP3_CLKX */
+	{
+	0x0170,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MCBSP3_FSX */
+	{
+	0x0172,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* UART2_CTS */
+	{
+	0x0174,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* UART2_RTS */
+	{
+	0x0176, OMAP343X_PADCONF_MUXMODE0},
+	    /* UART2_TX */
+	{
+	0x0178, OMAP343X_PADCONF_MUXMODE0},
+	    /* UART2_RX */
+	{
+	0x017A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* UART1_TX */
+	{
+	0x017C, OMAP343X_PADCONF_MUXMODE0},
+	    /* UART1_RTS */
+	{
+	0x017E, OMAP343X_PADCONF_MUXMODE0},
+	    /* UART1_CTS */
+	{
+	0x0180,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* UART1_RX */
+	{
+	0x0182,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MCBSP4_CLKX */
+	{
+	0x0184,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MCBSP4_DR */
+	{
+	0x0186,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MCBSP4_DX */
+	{
+	0x0188,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MCBSP4_FSX */
+	{
+	0x018A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MCBSP1_CLKR */
+	{
+	0x018C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* MCBSP1_FSR */
+	{
+	0x018E, OMAP343X_PADCONF_MUXMODE4},
+	    /* MCBSP1_DX */
+	{
+	0x0190,
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* MCBSP1_DR */
+	{
+	0x0192,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* MCBSP_CLKS */
+	{
+	0x0194,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* MCBSP1_FSX */
+	{
+	0x0196,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* MCBSP1_CLKX */
+	{
+	0x0198,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* UART3_CTS_RCTX */
+	{
+	0x019A,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* UART3_RTS_SD */
+	{
+	0x019C,
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* UART3_RX_IRRX */
+	{
+	0x019E,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_OFF_PULL_DOWN |
+		    OMAP343X_PADCONF_OFF_PUD_ENABLED |
+		    OMAP343X_PADCONF_OFF_OUTPUT_LOW |
+		    OMAP343X_PADCONF_OFF_OUTPUT_ENABLED |
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* UART3_TX_IRTX */
+	{
+	0x01A0, OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_CLK */
+	{
+	0x01A2,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_STP */
+	{
+	0x01A4,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_DIR */
+	{
+	0x01A6,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_NXT */
+	{
+	0x01A8,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_DATA0 */
+	{
+	0x01AA,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_DATA1 */
+	{
+	0x01AC,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_DATA2 */
+	{
+	0x01AE,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_DATA3 */
+	{
+	0x01B0,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_DATA4 */
+	{
+	0x01B2,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_DATA5 */
+	{
+	0x01B4,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_DATA6 */
+	{
+	0x01B6,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_DATA7 */
+	{
+	0x01B8,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* I2C1_SCL */
+	{
+	0x01BA,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* I2C1_SDA */
+	{
+	0x01BC,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* I2C2_SCL */
+	{
+	0x01BE,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* I2C2_SDA */
+	{
+	0x01C0,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* I2C3_SCL */
+	{
+	0x01C2,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* I2C3_SDA */
+	{
+	0x01C4,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HDQ_SIO */
+	{
+	0x01C6,
+		    OMAP343X_PADCONF_OFF_OUTPUT_LOW |
+		    OMAP343X_PADCONF_OFF_OUTPUT_ENABLED |
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MCSPI1_CLK */
+	{
+	0x01C8,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MCSPI1_SIMO */
+	{
+	0x01CA, OMAP343X_PADCONF_MUXMODE0},
+	    /* MCSPI1_SOMI */
+	{
+	0x01CC,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MCSPI1_CS0 */
+	{
+	0x01CE, OMAP343X_PADCONF_MUXMODE0},
+	    /* MCSPI1_CS1 */
+	{
+	0x01D0,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PUD_DISABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* MCSPI1_CS2 */
+	{
+	0x01D2,
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* MCSPI1_CS3 */
+	{
+	0x01D4,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* MCSPI2_CLK */
+	{
+	0x01D6,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* MCSPI2_SIMO */
+	{
+	0x01D8, OMAP343X_PADCONF_MUXMODE4},
+	    /* MCSPI2_SOMI */
+	{
+	0x01DA,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* MCSPI2_CS0 */
+	{
+	0x01DC, OMAP343X_PADCONF_MUXMODE4},
+	    /* MCSPI2_CS1 */
+	{
+	0x01DE,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE3},
+	    /* SYS_NIRQ */
+	{
+	0x01E0,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_OFF_PULL_DOWN |
+		    OMAP343X_PADCONF_OFF_PUD_ENABLED |
+		    OMAP343X_PADCONF_OFF_OUTPUT_LOW |
+		    OMAP343X_PADCONF_OFF_OUTPUT_ENABLED |
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* SYS_CLKOUT2 */
+	{
+	0x01E2, OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_CLK */
+	{
+	0x05D8,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_CTL */
+	{
+	0x05DA,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D0 */
+	{
+	0x05DC,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D1 */
+	{
+	0x05DE,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D2 */
+	{
+	0x05E0,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D3 */
+	{
+	0x05E2,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D4 */
+	{
+	0x05E4,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D5 */
+	{
+	0x05E6,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D6 */
+	{
+	0x05E8,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D7 */
+	{
+	0x05EA,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D8 */
+	{
+	0x05EC, OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D9 */
+	{
+	0x05EE, OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D10 */
+	{
+	0x05F0, OMAP343X_PADCONF_MUXMODE3},
+	    /* ETK_D11 */
+	{
+	0x05F2,
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE3},
+	    /* ETK_D12 */
+	{
+	0x05F4,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE3},
+	    /* ETK_D13 */
+	{
+	0x05F6,
+		    OMAP343X_PADCONF_PULL_UP | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D14 */
+	{
+	0x05F8,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D15 */
+	{
+	0x05FA,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE3},
+	    /* SAD2D_MCAD0 */
+	{
+	0x01E4,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD1 */
+	{
+	0x01E6,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD2 */
+	{
+	0x01E8,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD3 */
+	{
+	0x01EA,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD4 */
+	{
+	0x01EC,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD5 */
+	{
+	0x01EE,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD6 */
+	{
+	0x01F0,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD7 */
+	{
+	0x01F2,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD8 */
+	{
+	0x01F4,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD9 */
+	{
+	0x01F6,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD10 */
+	{
+	0x01F8,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD11 */
+	{
+	0x01FA,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD12 */
+	{
+	0x01FC,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD13 */
+	{
+	0x01FE,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD14 */
+	{
+	0x0200,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD15 */
+	{
+	0x0202,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD16 */
+	{
+	0x0204,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD17 */
+	{
+	0x0206,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD18 */
+	{
+	0x0208,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD19 */
+	{
+	0x020A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD20 */
+	{
+	0x020C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD21 */
+	{
+	0x020E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD22 */
+	{
+	0x0210,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD23 */
+	{
+	0x0212,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD24 */
+	{
+	0x0214,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD25 */
+	{
+	0x0216,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD26 */
+	{
+	0x0218,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD27 */
+	{
+	0x021A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD28 */
+	{
+	0x021C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD29 */
+	{
+	0x021E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD30 */
+	{
+	0x0220,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD31 */
+	{
+	0x0222,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD32 */
+	{
+	0x0224,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD33 */
+	{
+	0x0226,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD34 */
+	{
+	0x0228,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD35 */
+	{
+	0x022A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD36 */
+	{
+	0x022C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_CLK26MI */
+	{
+	0x022E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_NRESPWRON */
+	{
+	0x0230,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_NRESWARM */
+	{
+	0x0232,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_ARMNIRQ */
+	{
+	0x0234,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_UMAFIQ */
+	{
+	0x0236,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_SPINT */
+	{
+	0x0238,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_FRINT */
+	{
+	0x023A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PUD_DISABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_DMAREQ0 */
+	{
+	0x023C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_DMAREQ1 */
+	{
+	0x023E,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_DMAREQ2 */
+	{
+	0x0240,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_DMAREQ3 */
+	{
+	0x0242,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_NTRST */
+	{
+	0x0244,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_TDI */
+	{
+	0x0246,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_TDO */
+	{
+	0x0248,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_TMS */
+	{
+	0x024A,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_TCK */
+	{
+	0x024C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_RTCK */
+	{
+	0x024E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MSTDBY */
+	{
+	0x0250,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_IDLEREQ */
+	{
+	0x0252,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_IDLEACK */
+	{
+	0x0254,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MWRITE */
+	{
+	0x0256,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_SWRITE */
+	{
+	0x0258,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MREAD */
+	{
+	0x025A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_SREAD */
+	{
+	0x025C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MBUSFLAG */
+	{
+	0x025E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PUD_DISABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_SBUSFLAG */
+	{
+	0x0260,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_CKE0 */
+	{
+	0x0262,
+		    OMAP343X_PADCONF_PUD_DISABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_CKE1 */
+	{
+	0x0264,
+			OMAP343X_PADCONF_INPUT_ENABLED |
+			OMAP343X_PADCONF_PULL_UP |
+			OMAP343X_PADCONF_PUD_ENABLED |
+			OMAP343X_PADCONF_MUXMODE7},
+	    /* I2C4_SCL */
+	{
+	0x0A00,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* I2C4_SDA */
+	{
+	0x0A02,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_32K */
+	{
+	0x0A04,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_CLKREQ */
+	{
+	0x0A06,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_NRESWARM */
+	{
+	0x0A08,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_BOOT0 */
+	{
+	0x0A0A,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_OFF_PULL_DOWN |
+		    OMAP343X_PADCONF_OFF_PUD_ENABLED |
+		    OMAP343X_PADCONF_OFF_OUTPUT_LOW |
+		    OMAP343X_PADCONF_OFF_OUTPUT_ENABLED |
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PUD_DISABLED |
+			OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_BOOT1 */
+	{
+	0x0A0C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_BOOT2 */
+	{
+	0x0A0E,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_BOOT3 */
+	{
+	0x0A10,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_BOOT4 */
+	{
+	0x0A12,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_BOOT5 */
+	{
+	0x0A14,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_BOOT6 */
+	{
+	0x0A16, OMAP343X_PADCONF_MUXMODE4},
+	    /* SYS_OFF_MODE */
+	{
+	0x0A18,
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* SYS_CLKOUT1 */
+	{
+	0x0A1A,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* JTAG_NTRST */
+	{
+	0x0A1C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* JTAG_TCK */
+	{
+	0x0A1E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* JTAG_TMS_TMSC */
+	{
+	0x0A20,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* JTAG_TDI */
+	{
+	0x0A22,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* JTAG_EMU0 */
+	{
+	0x0A24,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* JTAG_EMU1 */
+	{
+	0x0A26,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_SWAKEUP */
+	{
+	0x0A4C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* JTAG_RTCK */
+	{
+	0x0A4E, OMAP343X_PADCONF_MUXMODE0},
+	    /* JTAG_TDO */
+	{
+	0x0A50, OMAP343X_PADCONF_MUXMODE0},};
+
+#ifdef CONFIG_ARM_OF
+static void __init mux_pad_callback(const void *p_data)
+{
+	struct mux_conf_entry *p = (struct mux_conf_entry *)p_data;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(padconf_settings); i++) {
+		if (padconf_settings[i].offset == p->offset) {
+			padconf_settings[i].setting &= (~(OMAP343X_PAD_MASK));
+
+			padconf_settings[i].setting |=
+			    (MAKE_OMAP343X_PAD_VALUE
+			     (p->mode, p->input_en, p->pull_type));
+
+			return;
+		}
+	}
+
+	printk(KERN_ERR "padconf override failed, offset = 0x%04x\n",
+			p->offset);
+}
+
+static void __init mux_offmode_callback(const void *p_data)
+{
+	struct mux_offmode_conf_entry *p =
+	    (struct mux_offmode_conf_entry *)p_data;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(padconf_settings); i++) {
+		if (padconf_settings[i].offset == p->offset) {
+			padconf_settings[i].setting &=
+			    (~(OMAP343X_OFFMODE_MASK));
+
+			padconf_settings[i].setting |=
+			    (MAKE_OMAP343X_OFFMODE_VALUE
+			     (p->offmode_en, p->offout_type, p->offpull_type,
+			      p->offwkup_en));
+
+			return;
+		}
+	}
+
+	printk(KERN_ERR "padconf offmode override failed, offset = 0x%04x\n",
+	       p->offset);
+}
+
+void dt_prop_or_init(struct dt_operation *op)
+{
+	struct device_node *node;
+	const void *prop;
+	int i, size;
+
+	node = of_find_node_by_path(op->path);
+	if (node == NULL) {
+		printk(KERN_ERR "Unable to read node %s from device tree!\n",
+		       op->path);
+		return;
+	}
+
+	prop = of_get_property(node, op->prop, &size);
+	if ((!prop) || (size % op->prop_unit_size)) {
+		printk(KERN_ERR "Read property %s error!\n", op->prop);
+	} else {
+		for (i = 0; i < size / op->prop_unit_size; i++) {
+			(*op->callback) (prop);
+			prop += op->prop_unit_size;
+		}
+	}
+
+	of_node_put(node);
+	printk(KERN_INFO "Device tree prop %s override done\n", op->prop);
+}
+
+void __init mux_setting_init(void)
+{
+	struct dt_operation op;
+
+	/* Read and implement MUX pad setting for pad registers */
+	op.path = DT_PATH_MUX;
+	op.prop = DT_PROP_MUX_PAD;
+	op.prop_unit_size = sizeof(struct mux_conf_entry);
+	op.callback = mux_pad_callback;
+	op.name_size = 2;
+	dt_prop_or_init(&op);
+
+	/* Read and implement MUX pad setting for pad wakeups registers */
+	op.path = DT_PATH_MUX;
+	op.prop = DT_PROP_MUX_PADWKUPS;
+	op.prop_unit_size = sizeof(struct mux_conf_entry);
+	op.callback = mux_pad_callback;
+	op.name_size = 2;
+	dt_prop_or_init(&op);
+
+	/* Read and implement MUX off mode setting for pad registers */
+	op.path = DT_PATH_MUX;
+	op.prop = DT_PROP_MUX_OFFMODE;
+	op.prop_unit_size = sizeof(struct mux_offmode_conf_entry);
+	op.callback = mux_offmode_callback;
+	op.name_size = 2;
+	dt_prop_or_init(&op);
+
+	/* Read and implement MUX off mode setting for pad wakeups registers */
+	op.path = DT_PATH_MUX;
+	op.prop = DT_PROP_MUX_OFFMODEWKUPS;
+	op.prop_unit_size = sizeof(struct mux_offmode_conf_entry);
+	op.callback = mux_offmode_callback;
+	op.name_size = 2;
+	dt_prop_or_init(&op);
+}
+#endif
+
+void __init sholest_padconf_init(void)
+{
+	int i;
+
+#ifdef CONFIG_ARM_OF
+	mux_setting_init();
+#endif
+
+	for (i = 0; i < ARRAY_SIZE(padconf_settings); i++) {
+		if (is_omap343x_padconf_register(padconf_settings[i].offset)) {
+			unsigned long addr = padconf_settings[i].offset
+			    + OMAP343X_CTRL_BASE;
+			/*
+			   despite the w, omap_readw actual reads a short which
+			   is a half word on this architecture
+			 */
+			unsigned short val = omap_readw(addr);
+#ifdef CONFIG_EMU_UART_DEBUG
+			if (is_emu_uart_iomux_reg(padconf_settings[i].offset)) {
+				printk(KERN_ERR "padconf ignored, offset = 0x%04x\n",
+						padconf_settings[i].offset);
+				continue;
+			}
+#endif
+			val &= ~(OMAP343X_PADCONF_SETTING_MASK);
+			val |= padconf_settings[i].setting;
+
+			omap_writew(val, addr);
+		} else {
+			printk(KERN_ERR "padconf check failed, offset = 0x%04x\n",
+						padconf_settings[i].offset);
+		}
+	}
+
+	return;
+}
diff --git a/arch/arm/mach-omap2/board-sholest-panel.c b/arch/arm/mach-omap2/board-sholest-panel.c
new file mode 100644
index 0000000..f1996e2
--- /dev/null
+++ b/arch/arm/mach-omap2/board-sholest-panel.c
@@ -0,0 +1,202 @@
+/*
+ * linux/arch/arm/mach-omap2/board-sholest-panel.c
+ *
+ * Copyright (C) 2009 Google, Inc.
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/regulator/consumer.h>
+#include <linux/err.h>
+#include <linux/omapfb.h>
+
+#include <mach/display.h>
+#include <mach/gpio.h>
+#include <mach/mux.h>
+#include <mach/resource.h>
+
+#define SHOLEST_DISPLAY_RESET_GPIO	136
+
+#ifdef CONFIG_PANEL_HDTV /* charlotte */
+#define SHOLEST_HDMI_MUX_ENABLE_N_GPIO 69
+#define SHOLEST_HDMI_MUX_SELECT_GPIO     7
+#endif
+
+struct regulator *display_regulator;
+
+static int sholest_panel_enable(struct omap_dss_device *dssdev)
+{
+	if (!display_regulator) {
+		display_regulator = regulator_get(NULL, "vhvio");
+		if (IS_ERR(display_regulator)) {
+			printk(KERN_ERR "failed to get regulator for display");
+			return PTR_ERR(display_regulator);
+		}
+#ifndef CONFIG_FB_OMAP2_MTD_LOGO
+		regulator_enable(display_regulator);
+		return 0;
+#endif
+	}
+
+	regulator_enable(display_regulator);
+	msleep(1);
+	gpio_request(SHOLEST_DISPLAY_RESET_GPIO, "display reset");
+	gpio_direction_output(SHOLEST_DISPLAY_RESET_GPIO, 1);
+	msleep(5);
+	gpio_set_value(SHOLEST_DISPLAY_RESET_GPIO, 0);
+	msleep(12); // low pulse width 5 -> 12
+	gpio_set_value(SHOLEST_DISPLAY_RESET_GPIO, 1);
+	msleep(12); // power stabilize 10 -> 12
+	return 0;
+}
+
+static void sholest_panel_disable(struct omap_dss_device *dssdev)
+{
+	gpio_direction_output(SHOLEST_DISPLAY_RESET_GPIO, 1);
+	gpio_set_value(SHOLEST_DISPLAY_RESET_GPIO, 0);
+	msleep(1);
+	regulator_disable(display_regulator);
+}
+
+static struct omapfb_platform_data sholest_fb_data = {
+	.mem_desc = {
+		.region_cnt = 1,
+		.region = {
+			{
+				.format = OMAPFB_COLOR_ARGB32,
+				.format_used = 1,
+			},
+		},
+	},
+};
+
+
+static struct omap_dss_device sholest_lcd_device = {
+	.type = OMAP_DISPLAY_TYPE_DSI,
+	.name = "lcd",
+	.driver_name = "sholes-panel",
+	.phy.dsi.clk_lane = 3,
+	.phy.dsi.clk_pol = 0,
+	.phy.dsi.data1_lane = 1,
+	.phy.dsi.data1_pol = 0,
+	.phy.dsi.data2_lane = 2,
+	.phy.dsi.data2_pol = 0,
+	.phy.dsi.ddr_clk_hz = 160000000,
+	.phy.dsi.lp_clk_hz = 4000000,
+	.reset_gpio = SHOLEST_DISPLAY_RESET_GPIO,
+	.platform_enable = sholest_panel_enable,
+	.platform_disable = sholest_panel_disable,
+};
+
+#ifdef CONFIG_PANEL_HDTV /* charlotte */
+static int sholest_panel_enable_hdtv(struct omap_dss_device *dssdev)
+{
+	printk(KERN_INFO "%s IN\n", __func__);
+
+	omap_cfg_reg(AG22_34XX_DSS_DATA0);
+	omap_cfg_reg(AH22_34XX_DSS_DATA1);
+	omap_cfg_reg(AG23_34XX_DSS_DATA2);
+	omap_cfg_reg(AH23_34XX_DSS_DATA3);
+	omap_cfg_reg(AG24_34XX_DSS_DATA4);
+	omap_cfg_reg(AH24_34XX_DSS_DATA5);
+
+	gpio_request(SHOLEST_HDMI_MUX_ENABLE_N_GPIO, "HDMI-mux-enable");
+	gpio_direction_output(SHOLEST_HDMI_MUX_ENABLE_N_GPIO, 0);
+	gpio_set_value(SHOLEST_HDMI_MUX_ENABLE_N_GPIO, 0);
+
+	gpio_request(SHOLEST_HDMI_MUX_SELECT_GPIO, "HDMI-mux-select");
+	gpio_direction_output(SHOLEST_HDMI_MUX_SELECT_GPIO, 0);
+	gpio_set_value(SHOLEST_HDMI_MUX_SELECT_GPIO, 1);
+
+	printk(KERN_INFO "%s OUT\n", __func__);
+	/* backlight enable? */
+	return 0;
+}
+
+static void sholest_panel_disable_hdtv(struct omap_dss_device *dssdev)
+{
+	printk(KERN_INFO "%s IN\n", __func__);
+
+	omap_cfg_reg(AG22_34XX_DSI_DX0);
+	omap_cfg_reg(AH22_34XX_DSI_DY0);
+	omap_cfg_reg(AG23_34XX_DSI_DX1);
+	omap_cfg_reg(AH23_34XX_DSI_DY1);
+	omap_cfg_reg(AG24_34XX_DSI_DX2);
+	omap_cfg_reg(AH24_34XX_DSI_DY2);
+
+	gpio_request(SHOLEST_HDMI_MUX_SELECT_GPIO, "HDMI-mux-select");
+	gpio_direction_output(SHOLEST_HDMI_MUX_SELECT_GPIO, 0);
+	gpio_set_value(SHOLEST_HDMI_MUX_SELECT_GPIO, 0);
+
+	printk(KERN_INFO "%s OUT\n", __func__);
+}
+
+static struct omap_dss_device sholest_hdtv_device = {
+	.type = OMAP_DISPLAY_TYPE_DPI,
+	.name = "hdtv",
+	.driver_name = "hdtv-panel",
+
+	.phy.dpi.data_lines = 24,
+
+	.panel.config = OMAP_DSS_LCD_TFT,
+
+	.platform_enable = sholest_panel_enable_hdtv,
+	.platform_disable = sholest_panel_disable_hdtv,
+};
+#endif
+
+static struct omap_dss_device *sholest_dss_devices[] = {
+	&sholest_lcd_device,
+#ifdef CONFIG_PANEL_HDTV /* charlotte */
+	&sholest_hdtv_device,
+#endif
+};
+
+static struct omap_dss_board_info sholest_dss_data = {
+	.num_devices = ARRAY_SIZE(sholest_dss_devices),
+	.devices = sholest_dss_devices,
+	.default_device = &sholest_lcd_device,
+};
+
+struct platform_device sholest_dss_device = {
+	.name = "omapdss",
+	.id = -1,
+	.dev = {
+		.platform_data = &sholest_dss_data,
+	},
+};
+
+void __init sholest_panel_init(void)
+{
+	int ret;
+
+	omap_cfg_reg(AG22_34XX_DSI_DX0);
+	omap_cfg_reg(AH22_34XX_DSI_DY0);
+	omap_cfg_reg(AG23_34XX_DSI_DX1);
+	omap_cfg_reg(AH23_34XX_DSI_DY1);
+	omap_cfg_reg(AG24_34XX_DSI_DX2);
+	omap_cfg_reg(AH24_34XX_DSI_DY2);
+	/* disp reset b */
+	omap_cfg_reg(AE4_34XX_GPIO136_OUT);
+
+	omapfb_set_platform_data(&sholest_fb_data);
+
+	ret = gpio_request(SHOLEST_DISPLAY_RESET_GPIO, "display reset");
+	if (ret) {
+		printk(KERN_ERR "failed to get display reset gpio\n");
+		goto error;
+	}
+
+	platform_device_register(&sholest_dss_device);
+	return;
+
+error:
+	gpio_free(SHOLEST_DISPLAY_RESET_GPIO);
+}
diff --git a/arch/arm/mach-omap2/board-sholest-sensors.c b/arch/arm/mach-omap2/board-sholest-sensors.c
new file mode 100644
index 0000000..ec1d402
--- /dev/null
+++ b/arch/arm/mach-omap2/board-sholest-sensors.c
@@ -0,0 +1,382 @@
+/*
+ * linux/arch/arm/mach-omap2/board-sholest-sensors.c
+ *
+ * Copyright (C) 2009 Google, Inc.
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/sfh7743.h>
+#include <linux/bu52014hfv.h>
+#ifdef CONFIG_SENSORS_LIS331DLH
+#include <linux/lis331dlh.h>
+#endif
+#include <linux/delay.h>
+#include <linux/regulator/consumer.h>
+#include <linux/vib-gpio.h>
+#ifdef CONFIG_VIB_PWM
+#include <linux/vib-pwm.h>
+#endif
+
+#ifdef CONFIG_ARM_OF
+#include <mach/dt_path.h>
+#include <asm/prom.h>
+#endif
+
+#include <mach/mux.h>
+#include <mach/gpio.h>
+#include <mach/keypad.h>
+#ifdef CONFIG_VIB_PWM
+#include <mach/dmtimer.h>
+#endif
+
+#define SHOLEST_PROX_INT_GPIO		180
+#define SHOLEST_HF_NORTH_GPIO		10
+#define SHOLEST_HF_SOUTH_GPIO		111
+#define SHOLEST_AKM8973_INT_GPIO	175
+#define SHOLEST_AKM8973_RESET_GPIO	28
+#define SHOLEST_VIBRATOR_GPIO		181
+#ifdef CONFIG_VIB_PWM
+#define SHOLEST_VIBRATOR_EN_GPIO	9
+#define SHOLEST_LVIBRATOR_PERIOD	5714
+#define SHOLEST_LVIBRATOR_DUTY		2857
+#endif
+
+static struct regulator *sholest_vibrator_regulator;
+static int sholest_vibrator_initialization(void)
+{
+	struct regulator *reg;
+	reg = regulator_get(NULL, "vvib");
+	if (IS_ERR(reg))
+		return PTR_ERR(reg);
+	sholest_vibrator_regulator = reg;
+	return 0;
+}
+
+static void sholest_vibrator_exit(void)
+{
+	regulator_put(sholest_vibrator_regulator);
+}
+
+static int sholest_vibrator_power_on(void)
+{
+	regulator_set_voltage(sholest_vibrator_regulator, 3000000, 3000000);
+	return regulator_enable(sholest_vibrator_regulator);
+}
+
+static int sholest_vibrator_power_off(void)
+{
+	if (sholest_vibrator_regulator)
+		return regulator_disable(sholest_vibrator_regulator);
+	return 0;
+}
+
+static struct vib_gpio_platform_data sholest_vib_gpio_data = {
+	.gpio = SHOLEST_VIBRATOR_GPIO,
+	.max_timeout = 15000,
+	.active_low = 0,
+	.initial_vibrate = 0,
+
+	.init = sholest_vibrator_initialization,
+	.exit = sholest_vibrator_exit,
+	.power_on = sholest_vibrator_power_on,
+	.power_off = sholest_vibrator_power_off,
+};
+
+static struct platform_device sholest_vib_gpio = {
+	.name           = VIB_GPIO_NAME,
+	.id             = -1,
+	.dev            = {
+		.platform_data  = &sholest_vib_gpio_data,
+    },
+};
+
+#ifdef CONFIG_VIB_PWM
+static struct omap_dm_timer *vib_pwm_timer;
+static int sholest_lvibrator_initialization(void)
+{
+	unsigned long load_reg, cmp_reg;
+	uint32_t timer_rate = 0;
+	int ret = 0;
+	vib_pwm_timer = omap_dm_timer_request_specific(11);
+	if (vib_pwm_timer == NULL)
+		ret = -ENODEV;
+	timer_rate = clk_get_rate(omap_dm_timer_get_fclk(vib_pwm_timer));
+	load_reg = timer_rate * SHOLEST_LVIBRATOR_PERIOD / 1000000;
+	cmp_reg = timer_rate * (SHOLEST_LVIBRATOR_PERIOD -
+				SHOLEST_LVIBRATOR_DUTY) / 1000000;
+	omap_dm_timer_set_source(vib_pwm_timer, OMAP_TIMER_SRC_32_KHZ);
+	omap_dm_timer_set_load(vib_pwm_timer, 1, -load_reg);
+	omap_dm_timer_set_match(vib_pwm_timer, 1, -cmp_reg);
+	omap_dm_timer_set_pwm(vib_pwm_timer, 0, 1,
+			      OMAP_TIMER_TRIGGER_OVERFLOW_AND_COMPARE);
+	omap_dm_timer_write_counter(vib_pwm_timer, -2);
+	return 0;
+}
+
+static void sholest_lvibrator_exit(void)
+{
+	omap_dm_timer_stop(vib_pwm_timer);
+	omap_dm_timer_disable(vib_pwm_timer);
+}
+
+static void sholest_lvibrator_power_on(void)
+{
+#ifdef CONFIG_VIB_PWM
+	gpio_set_value(SHOLEST_VIBRATOR_EN_GPIO, 1);
+#endif
+	if (vib_pwm_timer == NULL)
+		sholest_lvibrator_initialization();
+	omap_dm_timer_enable(vib_pwm_timer);
+	omap_dm_timer_start(vib_pwm_timer);
+}
+
+static void sholest_lvibrator_power_off(void)
+{
+#ifdef CONFIG_VIB_PWM
+	gpio_set_value(SHOLEST_VIBRATOR_EN_GPIO, 0);
+#endif
+	omap_dm_timer_stop(vib_pwm_timer);
+	omap_dm_timer_disable(vib_pwm_timer);
+}
+
+static struct vib_pwm_platform_data sholest_vib_pwm_data = {
+	.initial_vibrate = 500,
+	.init = sholest_lvibrator_initialization,
+	.exit = sholest_lvibrator_exit,
+	.power_on = sholest_lvibrator_power_on,
+	.power_off = sholest_lvibrator_power_off,
+};
+
+static struct platform_device sholest_vib_pwm = {
+	.name = VIB_PWM_NAME,
+	.id = -1,
+	.dev = {
+		.platform_data = &sholest_vib_pwm_data,
+	},
+};
+#endif
+
+static struct regulator *sholest_sfh7743_regulator;
+static int sholest_sfh7743_initialization(void)
+{
+	struct regulator *reg;
+	reg = regulator_get(NULL, "vsdio");
+	if (IS_ERR(reg))
+		return PTR_ERR(reg);
+	sholest_sfh7743_regulator = reg;
+	return 0;
+}
+
+static void sholest_sfh7743_exit(void)
+{
+	regulator_put(sholest_sfh7743_regulator);
+}
+
+static int sholest_sfh7743_power_on(void)
+{
+	return regulator_enable(sholest_sfh7743_regulator);
+}
+
+static int sholest_sfh7743_power_off(void)
+{
+	if (sholest_sfh7743_regulator)
+		return regulator_disable(sholest_sfh7743_regulator);
+	return 0;
+}
+
+static struct sfh7743_platform_data sholest_sfh7743_data = {
+	.init = sholest_sfh7743_initialization,
+	.exit = sholest_sfh7743_exit,
+	.power_on = sholest_sfh7743_power_on,
+	.power_off = sholest_sfh7743_power_off,
+
+	.gpio = SHOLEST_PROX_INT_GPIO,
+};
+
+static void __init sholest_sfh7743_init(void)
+{
+	gpio_request(SHOLEST_PROX_INT_GPIO, "sfh7743 proximity int");
+	gpio_direction_input(SHOLEST_PROX_INT_GPIO);
+	omap_cfg_reg(Y3_34XX_GPIO180);
+}
+
+static struct bu52014hfv_platform_data bu52014hfv_platform_data = {
+	.docked_north_gpio = SHOLEST_HF_NORTH_GPIO,
+	.docked_south_gpio = SHOLEST_HF_SOUTH_GPIO,
+	.north_is_desk = 1,
+};
+
+#ifdef CONFIG_SENSORS_LIS331DLH
+struct lis331dlh_platform_data sholest_lis331dlh_data;
+static void __init sholest_lis331dlh_init(void)
+{
+#ifdef CONFIG_ARM_OF
+	struct device_node *lis331dlh_node;
+	const void *lis331dlh_prop;
+	int len = 0;
+
+	lis331dlh_node = of_find_node_by_path(DT_PATH_LIS331DLH);
+	if (lis331dlh_node) {
+		lis331dlh_prop = of_get_property(lis331dlh_node, \
+						"axis_map_x", &len);
+		if (lis331dlh_prop && len)
+			sholest_lis331dlh_data.axis_map_x = \
+						*(u8 *)lis331dlh_prop;
+		lis331dlh_prop = of_get_property(lis331dlh_node, \
+						"axis_map_y", &len);
+		if (lis331dlh_prop && len)
+			sholest_lis331dlh_data.axis_map_y = \
+						*(u8 *)lis331dlh_prop;
+		lis331dlh_prop = of_get_property(lis331dlh_node, \
+						"axis_map_z", &len);
+		if (lis331dlh_prop && len)
+			sholest_lis331dlh_data.axis_map_z = \
+						*(u8 *)lis331dlh_prop;
+		lis331dlh_prop = of_get_property(lis331dlh_node, \
+						"negate_x", &len);
+		if (lis331dlh_prop && len)
+			sholest_lis331dlh_data.negate_x = \
+						*(u8 *)lis331dlh_prop;
+		lis331dlh_prop = of_get_property(lis331dlh_node, \
+						"negate_x", &len);
+		if (lis331dlh_prop && len)
+			sholest_lis331dlh_data.negate_x = \
+						*(u8 *)lis331dlh_prop;
+		lis331dlh_prop = of_get_property(lis331dlh_node, \
+						"negate_z", &len);
+		if (lis331dlh_prop && len)
+			sholest_lis331dlh_data.negate_z = \
+						*(u8 *)lis331dlh_prop;
+		of_node_put(lis331dlh_node);
+	}
+#endif
+}
+
+static struct regulator *sholest_lis331dlh_regulator;
+static int sholest_lis331dlh_initialization(void)
+{
+	struct regulator *reg;
+	reg = regulator_get(NULL, "vhvio");
+	if (IS_ERR(reg))
+		return PTR_ERR(reg);
+	sholest_lis331dlh_regulator = reg;
+	return 0;
+}
+
+static void sholest_lis331dlh_exit(void)
+{
+	regulator_put(sholest_lis331dlh_regulator);
+}
+
+static int sholest_lis331dlh_power_on(void)
+{
+	return regulator_enable(sholest_lis331dlh_regulator);
+}
+
+static int sholest_lis331dlh_power_off(void)
+{
+	if (sholest_lis331dlh_regulator)
+		return regulator_disable(sholest_lis331dlh_regulator);
+	return 0;
+}
+
+struct lis331dlh_platform_data sholest_lis331dlh_data = {
+	.init = sholest_lis331dlh_initialization,
+	.exit = sholest_lis331dlh_exit,
+	.power_on = sholest_lis331dlh_power_on,
+	.power_off = sholest_lis331dlh_power_off,
+
+	.min_interval	= 1,
+	.poll_interval	= 200,
+
+	.g_range	= LIS331DLH_G_8G,
+
+	.axis_map_x	= 0,
+	.axis_map_y	= 1,
+	.axis_map_z	= 2,
+
+	.negate_x	= 0,
+	.negate_y	= 1,
+	.negate_z	= 1,
+};
+#endif
+
+static void __init sholest_akm8973_init(void)
+{
+	gpio_request(SHOLEST_AKM8973_RESET_GPIO, "akm8973 reset");
+	gpio_direction_output(SHOLEST_AKM8973_RESET_GPIO, 1);
+	omap_cfg_reg(AB10_34XX_GPIO28_OUT);
+
+	gpio_request(SHOLEST_AKM8973_INT_GPIO, "akm8973 irq");
+	gpio_direction_input(SHOLEST_AKM8973_INT_GPIO);
+	omap_cfg_reg(AC3_34XX_GPIO175);
+}
+
+struct platform_device sfh7743_platform_device = {
+	.name = "sfh7743",
+	.id = -1,
+	.dev = {
+		.platform_data = &sholest_sfh7743_data,
+	},
+};
+
+static struct platform_device omap3430_hall_effect_dock = {
+	.name	= BU52014HFV_MODULE_NAME,
+	.id	= -1,
+	.dev	= {
+		.platform_data  = &bu52014hfv_platform_data,
+	},
+};
+
+static void sholest_vibrator_init(void)
+{
+	gpio_request(SHOLEST_VIBRATOR_GPIO, "vibrator");
+	gpio_direction_output(SHOLEST_VIBRATOR_GPIO, 0);
+	omap_cfg_reg(Y4_34XX_GPIO181);
+
+#ifdef CONFIG_VIB_PWM
+	gpio_request(SHOLEST_VIBRATOR_EN_GPIO, "vibrator en");
+	gpio_direction_output(SHOLEST_VIBRATOR_EN_GPIO, 0);
+	omap_cfg_reg(AF22_34XX_GPIO9_OUT);
+#endif
+}
+
+static struct platform_device *sholest_sensors[] __initdata = {
+	&sfh7743_platform_device,
+	&omap3430_hall_effect_dock,
+	&sholest_vib_gpio,
+#ifdef CONFIG_VIB_PWM
+	&sholest_vib_pwm,
+#endif
+};
+
+static void sholest_hall_effect_init(void)
+{
+	gpio_request(SHOLEST_HF_NORTH_GPIO, "mapphone dock north");
+	gpio_direction_input(SHOLEST_HF_NORTH_GPIO);
+	omap_cfg_reg(AG25_34XX_GPIO10);
+
+	gpio_request(SHOLEST_HF_SOUTH_GPIO, "mapphone dock south");
+	gpio_direction_input(SHOLEST_HF_SOUTH_GPIO);
+	omap_cfg_reg(B26_34XX_GPIO111);
+}
+
+void __init sholest_sensors_init(void)
+{
+	sholest_sfh7743_init();
+	sholest_vibrator_init();
+	sholest_akm8973_init();
+#ifdef CONFIG_SENSORS_LIS331DLH
+	sholest_lis331dlh_init();
+#endif
+	platform_add_devices(sholest_sensors, ARRAY_SIZE(sholest_sensors));
+}
diff --git a/arch/arm/mach-omap2/board-sholest-spi.c b/arch/arm/mach-omap2/board-sholest-spi.c
new file mode 100644
index 0000000..fa2b079
--- /dev/null
+++ b/arch/arm/mach-omap2/board-sholest-spi.c
@@ -0,0 +1,698 @@
+/*
+ * arch/arm/mach-omap2/board-sholest-spi.c
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/irq.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/regulator/consumer.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/spi/cpcap.h>
+#include <linux/spi/spi.h>
+#include <mach/mcspi.h>
+#include <mach/gpio.h>
+#include <mach/mux.h>
+#include <mach/resource.h>
+#include <mach/omap34xx.h>
+
+#ifdef CONFIG_ARM_OF
+#include <mach/dt_path.h>
+#include <asm/prom.h>
+#endif
+
+extern struct platform_device cpcap_disp_button_led;
+extern struct platform_device cpcap_rgb_led;
+#ifdef CONFIG_LEDS_AF_LED
+extern struct platform_device cpcap_af_led;
+#endif
+
+struct cpcap_spi_init_data sholest_cpcap_spi_init[CPCAP_REG_SIZE + 1] = {
+	{CPCAP_REG_ASSIGN1,   0x0101},
+	{CPCAP_REG_ASSIGN2,   0x0000},
+	{CPCAP_REG_ASSIGN3,   0x0000},
+	{CPCAP_REG_ASSIGN4,   0x0000},
+	{CPCAP_REG_ASSIGN5,   0x0000},
+	{CPCAP_REG_ASSIGN6,   0x0000},
+	{CPCAP_REG_UCC1,      0x0000},
+	{CPCAP_REG_PC1,       0x010A},
+	{CPCAP_REG_PC2,       0x0150},
+	{CPCAP_REG_PGC,       0x0000},
+	{CPCAP_REG_SDVSPLL,   0xDB14},
+	{CPCAP_REG_SI2CC1,    0x0281},
+	{CPCAP_REG_Si2CC2,    0x00C4},
+	{CPCAP_REG_S1C1,      0x6438},
+	{CPCAP_REG_S1C2,      0x3838},
+	{CPCAP_REG_S2C1,      0x6434},
+	{CPCAP_REG_S2C2,      0x3C14},
+	{CPCAP_REG_S3C,       0x0539},
+	{CPCAP_REG_S4C1,      0x0000},
+	{CPCAP_REG_S4C2,      0x0000},
+	{CPCAP_REG_S6C,       0x0000},
+	{CPCAP_REG_VWLAN2C,   0x0001},
+	{CPCAP_REG_VUSBINT1C, 0x0029},
+	{CPCAP_REG_VUSBINT2C, 0x0029},
+	{CPCAP_REG_VAUDIOC,   0x0060},
+	{CPCAP_REG_ADCC1,     0x9000},
+	{CPCAP_REG_ADCC2,     0x4136},
+	{CPCAP_REG_USBC1,     0x1201},
+	{CPCAP_REG_USBC3,     0x7DFB},
+	{CPCAP_REG_UIER2,     0x001F},
+	{CPCAP_REG_UIEF2,     0x001F},
+	{CPCAP_REG_OWDC,      0x0003},
+	{CPCAP_REG_GPIO0,     0x3004},
+	{CPCAP_REG_GPIO1,     0x3000},
+	{CPCAP_REG_GPIO2,     0x3204},
+	{CPCAP_REG_GPIO3,     0x3008},
+	{CPCAP_REG_GPIO4,     0x3204},
+	{CPCAP_REG_GPIO5,     0x3008},
+	{CPCAP_REG_GPIO6,     0x3004},
+	{CPCAP_REG_MDLC,      0x0000},
+	{CPCAP_REG_KLC,       0x0000},
+	{CPCAP_REG_UNUSED,    0x0000},
+};
+
+unsigned short cpcap_regulator_mode_values[CPCAP_NUM_REGULATORS] = {
+	[CPCAP_SW5]      = 0x0022,
+	[CPCAP_VCAM]     = 0x0003,
+	[CPCAP_VCSI]     = 0x0043,
+	[CPCAP_VDAC]     = 0x0003,
+	[CPCAP_VDIG]     = 0x0082,
+	[CPCAP_VFUSE]    = 0x0080,
+	[CPCAP_VHVIO]    = 0x0003,
+	[CPCAP_VSDIO]    = 0x0003,
+	[CPCAP_VPLL]     = 0x0042,
+	[CPCAP_VRF1]     = 0x0024,
+	[CPCAP_VRF2]     = 0x0001,
+	[CPCAP_VRFREF]   = 0x0023,
+	[CPCAP_VWLAN1]   = 0x0003,
+	[CPCAP_VWLAN2]   = 0x000C,
+	[CPCAP_VSIM]     = 0x0003,
+	[CPCAP_VSIMCARD] = 0x1E00,
+	[CPCAP_VVIB]     = 0x0001,
+	[CPCAP_VUSB]     = 0x000C,
+	[CPCAP_VAUDIO]   = 0x0014,
+};
+
+unsigned short cpcap_regulator_off_mode_values[CPCAP_NUM_REGULATORS] = {
+	[CPCAP_SW5]      = 0x0000,
+	[CPCAP_VCAM]     = 0x0000,
+	[CPCAP_VCSI]     = 0x0041,
+	[CPCAP_VDAC]     = 0x0000,
+	[CPCAP_VDIG]     = 0x0000,
+	[CPCAP_VFUSE]    = 0x0000,
+	[CPCAP_VHVIO]    = 0x0000,
+	[CPCAP_VSDIO]    = 0x0000,
+	[CPCAP_VPLL]     = 0x0000,
+	[CPCAP_VRF1]     = 0x0000,
+	[CPCAP_VRF2]     = 0x0000,
+	[CPCAP_VRFREF]   = 0x0000,
+	[CPCAP_VWLAN1]   = 0x0000,
+	[CPCAP_VWLAN2]   = 0x0000,
+	[CPCAP_VSIM]     = 0x0000,
+	[CPCAP_VSIMCARD] = 0x0000,
+	[CPCAP_VVIB]     = 0x0000,
+	[CPCAP_VUSB]     = 0x0000,
+	[CPCAP_VAUDIO]   = 0x0000,
+};
+
+#define CPCAP_GPIO 0
+
+#define REGULATOR_CONSUMER(name, device) { .supply = name, .dev = device, }
+
+struct regulator_consumer_supply cpcap_sw5_consumers[] = {
+	REGULATOR_CONSUMER("sw5", &cpcap_disp_button_led.dev),
+	REGULATOR_CONSUMER("sw5", &cpcap_rgb_led.dev),
+#ifdef CONFIG_LEDS_AF_LED
+	REGULATOR_CONSUMER("sw5", &cpcap_af_led.dev),
+#endif
+};
+
+struct regulator_consumer_supply cpcap_vcam_consumers[] = {
+	REGULATOR_CONSUMER("vcam", NULL /* cpcap_cam_device */),
+};
+
+extern struct platform_device sholest_dss_device;
+
+struct regulator_consumer_supply cpcap_vhvio_consumers[] = {
+	REGULATOR_CONSUMER("vhvio", NULL /* lighting_driver */),
+#if 0
+	REGULATOR_CONSUMER("vhvio", NULL /* lighting_driver */),
+	REGULATOR_CONSUMER("vhvio", NULL /* magnetometer */),
+	REGULATOR_CONSUMER("vhvio", NULL /* light sensor */),
+	REGULATOR_CONSUMER("vhvio", NULL /* accelerometer */),
+	REGULATOR_CONSUMER("vhvio", NULL /* display */),
+#endif
+};
+
+struct regulator_consumer_supply cpcap_vsdio_consumers[] = {
+	REGULATOR_CONSUMER("vsdio", NULL),
+};
+
+struct regulator_consumer_supply cpcap_vcsi_consumers[] = {
+	REGULATOR_CONSUMER("vdds_dsi", &sholest_dss_device.dev),
+};
+
+struct regulator_consumer_supply cpcap_vwlan1_consumers[] = {
+	REGULATOR_CONSUMER("vwlan1", NULL /* cpcap_cam_device */),
+};
+
+struct regulator_consumer_supply cpcap_vwlan2_consumers[] = {
+	REGULATOR_CONSUMER("vwlan2", NULL /* sd slot */),
+};
+
+struct regulator_consumer_supply cpcap_vsim_consumers[] = {
+	REGULATOR_CONSUMER("vsim", NULL),
+};
+
+struct regulator_consumer_supply cpcap_vsimcard_consumers[] = {
+	REGULATOR_CONSUMER("vsimcard", NULL),
+};
+
+struct regulator_consumer_supply cpcap_vvib_consumers[] = {
+	REGULATOR_CONSUMER("vvib", NULL /* vibrator */),
+};
+
+struct regulator_consumer_supply cpcap_vaudio_consumers[] = {
+	REGULATOR_CONSUMER("vaudio", NULL /* mic opamp */),
+};
+
+struct regulator_consumer_supply cpcap_vfuse_consumers[] = {
+    REGULATOR_CONSUMER("vfuse", NULL),
+};
+
+
+
+
+static struct regulator_init_data cpcap_regulator[CPCAP_NUM_REGULATORS] = {
+	[CPCAP_SW5] = {
+		.constraints = {
+			.min_uV			= 5050000,
+			.max_uV			= 5050000,
+			.valid_ops_mask		= REGULATOR_CHANGE_STATUS,
+			.apply_uV		= 1,
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_sw5_consumers),
+		.consumer_supplies	= cpcap_sw5_consumers,
+	},
+	[CPCAP_VCAM] = {
+		.constraints = {
+			.min_uV			= 2800000,
+			.max_uV			= 2800000,
+			.valid_ops_mask		= REGULATOR_CHANGE_STATUS,
+			.apply_uV		= 1,
+
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vcam_consumers),
+		.consumer_supplies	= cpcap_vcam_consumers,
+	},
+	[CPCAP_VCSI] = {
+		.constraints = {
+			.min_uV			= 1800000,
+			.max_uV			= 1800000,
+			.valid_ops_mask		= REGULATOR_CHANGE_STATUS,
+			.boot_on		= 1,
+			.apply_uV		= 1,
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vcsi_consumers),
+		.consumer_supplies	= cpcap_vcsi_consumers,
+	},
+	[CPCAP_VDAC] = {
+		.constraints = {
+			.min_uV			= 1800000,
+			.max_uV			= 1800000,
+			.valid_ops_mask		= REGULATOR_CHANGE_STATUS,
+			.apply_uV		= 1,
+		},
+	},
+	[CPCAP_VDIG] = {
+		.constraints = {
+			.min_uV			= 1875000,
+			.max_uV			= 1875000,
+			.valid_ops_mask		= REGULATOR_CHANGE_VOLTAGE,
+			.always_on		= 1,
+			.apply_uV		= 1,
+		},
+	},
+	[CPCAP_VFUSE] = {
+		.constraints = {
+			.min_uV			= 1500000,
+			.max_uV			= 3150000,
+			.valid_ops_mask		= (REGULATOR_CHANGE_VOLTAGE |
+						   REGULATOR_CHANGE_STATUS),
+		},
+		.num_consumer_supplies  = ARRAY_SIZE(cpcap_vfuse_consumers),
+		.consumer_supplies      = cpcap_vfuse_consumers,
+	},
+	[CPCAP_VHVIO] = {
+		.constraints = {
+			.min_uV			= 2775000,
+			.max_uV			= 2775000,
+			.valid_ops_mask		= REGULATOR_CHANGE_STATUS,
+			.always_on		= 1,
+			.apply_uV		= 1,
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vhvio_consumers),
+		.consumer_supplies	= cpcap_vhvio_consumers,
+	},
+	[CPCAP_VSDIO] = {
+		.constraints = {
+			.min_uV			= 2900000,
+			.max_uV			= 2900000,
+			.valid_ops_mask		= REGULATOR_CHANGE_STATUS,
+			.apply_uV		= 1,
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vsdio_consumers),
+		.consumer_supplies	= cpcap_vsdio_consumers,
+	},
+	[CPCAP_VPLL] = {
+		.constraints = {
+			.min_uV			= 1800000,
+			.max_uV			= 1800000,
+			.valid_ops_mask		= 0,
+			.always_on		= 1,
+			.apply_uV		= 1,
+		},
+	},
+	[CPCAP_VRF1] = {
+		.constraints = {
+			.min_uV			= 2775000,
+			.max_uV			= 2775000,
+			.valid_ops_mask		= (REGULATOR_CHANGE_STATUS |
+						   REGULATOR_CHANGE_VOLTAGE),
+			.always_on		= 1,
+			.apply_uV		= 1,
+		},
+	},
+	[CPCAP_VRF2] = {
+		.constraints = {
+			.min_uV			= 2775000,
+			.max_uV			= 2775000,
+			.valid_ops_mask		= (REGULATOR_CHANGE_STATUS |
+						   REGULATOR_CHANGE_VOLTAGE),
+			.always_on		= 1,
+			.apply_uV		= 1,
+		},
+	},
+	[CPCAP_VRFREF] = {
+		.constraints = {
+			.min_uV			= 2775000,
+			.max_uV			= 2775000,
+			.valid_ops_mask		= (REGULATOR_CHANGE_STATUS |
+						   REGULATOR_CHANGE_VOLTAGE),
+			.always_on		= 1,
+			.apply_uV		= 1,
+		},
+	},
+	[CPCAP_VWLAN1] = {
+		.constraints = {
+			.min_uV			= 1800000,
+			.max_uV			= 1900000,
+			.valid_ops_mask		= 0,
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vwlan1_consumers),
+		.consumer_supplies	= cpcap_vwlan1_consumers,
+	},
+	[CPCAP_VWLAN2] = {
+		.constraints = {
+			.min_uV			= 3000000,
+			.max_uV			= 3000000,
+			.valid_ops_mask		= REGULATOR_CHANGE_STATUS,
+			.apply_uV		= 1,
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vwlan2_consumers),
+		.consumer_supplies	= cpcap_vwlan2_consumers,
+	},
+	[CPCAP_VSIM] = {
+		.constraints = {
+			.min_uV			= 1800000,
+			.max_uV			= 2900000,
+			.valid_ops_mask		= (REGULATOR_CHANGE_STATUS |
+						   REGULATOR_CHANGE_VOLTAGE),
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vsim_consumers),
+		.consumer_supplies	= cpcap_vsim_consumers,
+	},
+	[CPCAP_VSIMCARD] = {
+		.constraints = {
+			.min_uV			= 1800000,
+			.max_uV			= 2900000,
+			.valid_ops_mask		= (REGULATOR_CHANGE_STATUS |
+						   REGULATOR_CHANGE_VOLTAGE),
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vsimcard_consumers),
+		.consumer_supplies	= cpcap_vsimcard_consumers,
+	},
+	[CPCAP_VVIB] = {
+		.constraints = {
+			.min_uV			= 1300000,
+			.max_uV			= 3000000,
+			.valid_ops_mask		= (REGULATOR_CHANGE_VOLTAGE |
+						   REGULATOR_CHANGE_STATUS),
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vvib_consumers),
+		.consumer_supplies	= cpcap_vvib_consumers,
+	},
+	[CPCAP_VUSB] = {
+		.constraints = {
+			.min_uV			= 3300000,
+			.max_uV			= 3300000,
+			.valid_ops_mask		= REGULATOR_CHANGE_STATUS,
+			.apply_uV		= 1,
+		},
+	},
+	[CPCAP_VAUDIO] = {
+		.constraints = {
+			.min_uV			= 2775000,
+			.max_uV			= 2775000,
+			.valid_modes_mask	= (REGULATOR_MODE_NORMAL |
+						   REGULATOR_MODE_STANDBY),
+			.valid_ops_mask		= REGULATOR_CHANGE_MODE,
+			.always_on		= 1,
+			.apply_uV		= 1,
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vaudio_consumers),
+		.consumer_supplies	= cpcap_vaudio_consumers,
+	},
+};
+
+static struct cpcap_adc_ato sholest_cpcap_adc_ato = {
+	.ato_in = 0x0480,
+	.atox_in = 0,
+	.adc_ps_factor_in = 0x0200,
+	.atox_ps_factor_in = 0,
+	.ato_out = 0,
+	.atox_out = 0,
+	.adc_ps_factor_out = 0,
+	.atox_ps_factor_out = 0,
+};
+
+static void ac_changed(struct power_supply *ac,
+		       struct cpcap_batt_ac_data *ac_state)
+{
+	static char requested;
+	int ret = 0;
+
+	if (!ac || !ac_state)
+		return;
+
+	if (ac_state->online) {
+		/* To reduce OMAP Vdd1 DC/DC converter output voltage dips as
+		 * much as possible, limit Vdd1 to OPP3-OPP5 when the phone is
+		 * connected to a charger. */
+		if (!requested)
+			ret = resource_request("vdd1_opp", ac->dev, VDD1_OPP3);
+
+		if (!ret)
+			requested = 1;
+	} else if (requested) {
+		ret = resource_release("vdd1_opp", ac->dev);
+
+		if (!ret)
+			requested = 0;
+	}
+}
+
+static void batt_changed(struct power_supply *batt,
+			 struct cpcap_batt_data *batt_state)
+{
+	static char requested;
+	int ret = 0;
+
+	if (!batt || !batt_state)
+		return;
+
+	if (batt_state->batt_temp < 0) {
+		/* To reduce OMAP Vdd1 DC/DC converter output voltage dips as
+		 * much as possible, limit Vdd1 to OPP3-OPP5 when the
+		 * temperature is below 0 degrees C. */
+		if (!requested)
+			ret = resource_request("vdd1_opp", batt->dev, \
+					       VDD1_OPP3);
+
+		if (!ret)
+			requested = 1;
+	} else if (requested) {
+		ret = resource_release("vdd1_opp", batt->dev);
+
+		if (!ret)
+			requested = 0;
+	}
+}
+
+
+static struct cpcap_platform_data sholest_cpcap_data = {
+	.init = sholest_cpcap_spi_init,
+	.regulator_mode_values = cpcap_regulator_mode_values,
+	.regulator_off_mode_values = cpcap_regulator_off_mode_values,
+	.regulator_init = cpcap_regulator,
+	.adc_ato = &sholest_cpcap_adc_ato,
+	.ac_changed = ac_changed,
+	.batt_changed = batt_changed,
+	.usb_changed = NULL,
+};
+
+static struct spi_board_info sholest_spi_board_info[] __initdata = {
+	{
+		.modalias = "cpcap",
+		.bus_num = 1,
+		.chip_select = 0,
+		.max_speed_hz = 20000000,
+		.controller_data = &sholest_cpcap_data,
+		.mode = SPI_CS_HIGH,
+	},
+#ifdef CONFIG_MOT_FEAT_SPI_SMS1130
+	{
+		.modalias = "smsmdtv", /* should match device driver name */
+		.bus_num  = 3,
+		.chip_select = 0,
+		.max_speed_hz = 6000000,
+		/*.mode = SPI_CS_LOW*/
+	},
+#endif
+};
+
+#ifdef CONFIG_ARM_OF
+struct omap_spi_init_entry {
+	u32 reg;
+	u32 data;
+} __attribute__ ((__packed__));
+
+struct omap_rgt_mode_entry {
+	u32 id;
+	u16 data;
+} __attribute__ ((__packed__));
+
+struct omap_rgt_init_entry {
+	u32 id;
+	u32 min_uV;
+	u32 max_uV;
+	u32 valid_ops_mask;
+	u8 always_on;
+	u8 boot_on;
+	u8 apply_uV;
+} __attribute__ ((__packed__));
+
+static void regulator_init(void *p_data)
+{
+	struct omap_rgt_init_entry *p = p_data;
+	struct regulator_init_data *p_devs = cpcap_regulator;
+
+	if (p->id < CPCAP_NUM_REGULATORS) {
+		p_devs[p->id].constraints.min_uV = p->min_uV;
+		p_devs[p->id].constraints.max_uV = p->max_uV;
+		p_devs[p->id].constraints.valid_ops_mask = p->valid_ops_mask;
+		p_devs[p->id].constraints.always_on = p->always_on;
+		p_devs[p->id].constraints.boot_on = p->boot_on;
+		p_devs[p->id].constraints.apply_uV = p->apply_uV;
+		printk(KERN_INFO "CPCAP: Overwrite regulator init [%d]!\n",
+				p->id);
+	} else {
+		printk(KERN_ERR "CPCAP: Too big cpcap regulator count!\n");
+	}
+}
+
+static void regulator_mode_init(void *p_data)
+{
+	struct omap_rgt_mode_entry *p = p_data;
+	unsigned short *p_devs = cpcap_regulator_mode_values;
+
+	if (p->id < CPCAP_NUM_REGULATORS) {
+		p_devs[p->id] = p->data;
+		printk(KERN_INFO "CPCAP: Overwrite regulator mode [%d]!\n",
+				p->id);
+	} else {
+		printk(KERN_ERR "CPCAP: Too big cpcap regulator count!\n");
+	}
+}
+
+static void regulator_off_mode_init(void *p_data)
+{
+	struct omap_rgt_mode_entry *p = p_data;
+	unsigned short *p_devs = cpcap_regulator_off_mode_values;
+
+	if (p->id < CPCAP_NUM_REGULATORS) {
+		p_devs[p->id] = p->data;
+		printk(KERN_INFO "CPCAP: Overwrite regulator off mode [%d]!\n",
+				p->id);
+	} else {
+		printk(KERN_ERR "CPCAP: Too big cpcap regulator count!\n");
+	}
+}
+
+static void cpcap_spi_init(void *p_data)
+{
+	struct omap_spi_init_entry *p = p_data;
+	struct cpcap_spi_init_data *p_devs = sholest_cpcap_spi_init;
+	int i = 0;
+
+	for (i = 0; i < CPCAP_REG_SIZE + 1; i++) {
+		if (p_devs[i].reg == CPCAP_REG_UNUSED) {
+			p_devs[i].reg = p->reg;
+			p_devs[i].data = p->data;
+
+			if (i != CPCAP_REG_SIZE)
+				p_devs[i + 1].reg = CPCAP_REG_UNUSED;
+
+			printk(KERN_INFO "CPCAP: Add new reg [%d] setting!\n",
+					p->reg);
+			return;
+		}
+
+		if (p_devs[i].reg == p->reg) {
+			p_devs[i].data = p->data;
+
+			printk(KERN_INFO "CPCAP: Overwrite reg [%d] setting!\n",
+					p->reg);
+			return;
+		}
+
+		if (i == CPCAP_REG_SIZE)
+			printk(KERN_ERR "CPCAP: Too big cpcap reg count!\n");
+	}
+}
+
+static void __init cpcap_of_init(void)
+{
+	int size, unit_size, i, count;
+	struct device_node *node;
+	const void *prop;
+
+	node = of_find_node_by_path(DT_PATH_CPCAP);
+	if (node == NULL) {
+		printk(KERN_ERR
+				"Unable to read node %s from device tree!\n",
+				DT_PATH_CPCAP);
+		return;
+	}
+
+	unit_size = sizeof(struct omap_spi_init_entry);
+	prop = of_get_property(node, DT_PROP_CPCAP_SPIINIT, &size);
+	if ((!prop) || (size % unit_size)) {
+		printk(KERN_ERR "Read property %s error!\n",
+				DT_PROP_CPCAP_SPIINIT);
+		of_node_put(node);
+		return;
+	}
+
+	count = size / unit_size;
+	printk(KERN_INFO "cpcap init size = %d\n", count);
+
+	for (i = 0; i < count; i++)
+		cpcap_spi_init((struct omap_spi_init_entry *)prop + i);
+
+#if 0 /* Temporary FOTA workaround:Do not allow the device tree to
+	 overwrite the board file regulator mode settings. */
+	unit_size = sizeof(struct omap_rgt_init_entry);
+	prop = of_get_property(node, DT_PROP_CPCAP_RGTINIT, &size);
+	if ((!prop) || (size % unit_size)) {
+		printk(KERN_ERR "Read property %s error!\n",
+				DT_PROP_CPCAP_RGTINIT);
+		of_node_put(node);
+		return;
+	}
+
+	count = size / unit_size;
+	printk(KERN_INFO "cpcap init size = %d\n", count);
+
+	for (i = 0; i < count; i++)
+		regulator_init((struct omap_rgt_init_entry *)prop + i);
+
+	unit_size = sizeof(struct omap_rgt_mode_entry);
+	prop = of_get_property(node, DT_PROP_CPCAP_RGTMODE, &size);
+	if ((!prop) || (size % unit_size)) {
+		printk(KERN_ERR "Read property %s error!\n",
+				DT_PROP_CPCAP_RGTMODE);
+		of_node_put(node);
+		return;
+	}
+
+	count = size / unit_size;
+	printk(KERN_INFO "cpcap init size = %d\n", count);
+
+	for (i = 0; i < count; i++)
+		regulator_mode_init((struct omap_rgt_mode_entry *)prop + i);
+
+	unit_size = sizeof(struct omap_rgt_mode_entry);
+	prop = of_get_property(node, DT_PROP_CPCAP_RGTOFFMODE, &size);
+	if ((!prop) || (size % unit_size)) {
+		printk(KERN_ERR "Read property %s error!\n",
+				DT_PROP_CPCAP_RGTOFFMODE);
+		of_node_put(node);
+		return;
+	}
+
+	count = size / unit_size;
+	printk(KERN_INFO "cpcap init size = %d\n", count);
+
+	for (i = 0; i < count; i++)
+		regulator_off_mode_init((struct omap_rgt_mode_entry *)prop + i);
+#endif
+	of_node_put(node);
+	return;
+}
+#endif
+
+void __init sholest_spi_init(void)
+{
+	int irq;
+	int ret;
+	int i;
+
+#ifdef CONFIG_ARM_OF
+	cpcap_of_init();
+#endif
+
+	for (i = 0; i < CPCAP_REG_SIZE; i++) {
+		if (sholest_cpcap_spi_init[i].reg == CPCAP_REG_UNUSED)
+			break;
+	}
+	sholest_cpcap_data.init_len = i;
+
+	ret = gpio_request(CPCAP_GPIO, "cpcap-irq");
+	if (ret)
+		return;
+	ret = gpio_direction_input(CPCAP_GPIO);
+	if (ret) {
+		gpio_free(CPCAP_GPIO);
+		return;
+	}
+
+	irq = gpio_to_irq(CPCAP_GPIO);
+	set_irq_type(irq, IRQ_TYPE_EDGE_RISING);
+	omap_cfg_reg(AF26_34XX_GPIO0);
+
+	sholest_spi_board_info[0].irq = irq;
+	spi_register_board_info(sholest_spi_board_info,
+				ARRAY_SIZE(sholest_spi_board_info));
+
+	/* regulator_has_full_constraints(); */
+}
diff --git a/arch/arm/mach-omap2/board-sholest-wifi.c b/arch/arm/mach-omap2/board-sholest-wifi.c
new file mode 100644
index 0000000..eec8778
--- /dev/null
+++ b/arch/arm/mach-omap2/board-sholest-wifi.c
@@ -0,0 +1,202 @@
+/* linux/arch/arm/mach-omap2/board-sholest-wifi.c
+*/
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/err.h>
+
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <linux/wifi_tiwlan.h>
+
+#include <linux/debugfs.h>
+
+#define SHOLEST_WIFI_PMENA_GPIO	186
+#define SHOLEST_WIFI_IRQ_GPIO	65
+
+static int sholest_wifi_cd = 0;		/* WIFI virtual 'card detect' status */
+static void (*wifi_status_cb)(int card_present, void *dev_id);
+static void *wifi_status_cb_devid;
+
+int sholest_wifi_status_register(void (*callback)(int card_present,
+						void *dev_id), void *dev_id)
+{
+	if (wifi_status_cb)
+		return -EAGAIN;
+	wifi_status_cb = callback;
+	wifi_status_cb_devid = dev_id;
+	return 0;
+}
+
+int sholest_wifi_status(int irq)
+{
+	return sholest_wifi_cd;
+}
+
+int sholest_wifi_set_carddetect(int val)
+{
+	printk("%s: %d\n", __func__, val);
+	sholest_wifi_cd = val;
+	if (wifi_status_cb) {
+		wifi_status_cb(val, wifi_status_cb_devid);
+	} else
+		printk(KERN_WARNING "%s: Nobody to notify\n", __func__);
+	return 0;
+}
+#ifndef CONFIG_WIFI_CONTROL_FUNC
+EXPORT_SYMBOL(sholest_wifi_set_carddetect);
+#endif
+
+static int sholest_wifi_power_state;
+
+int sholest_wifi_power(int on)
+{
+	printk("%s: %d\n", __func__, on);
+	gpio_set_value(SHOLEST_WIFI_PMENA_GPIO, on);
+	sholest_wifi_power_state = on;
+	return 0;
+}
+#ifndef CONFIG_WIFI_CONTROL_FUNC
+EXPORT_SYMBOL(sholest_wifi_power);
+#endif
+
+static int sholest_wifi_reset_state;
+int sholest_wifi_reset(int on)
+{
+	printk("%s: %d\n", __func__, on);
+	sholest_wifi_reset_state = on;
+	return 0;
+}
+#ifndef CONFIG_WIFI_CONTROL_FUNC
+EXPORT_SYMBOL(sholest_wifi_reset);
+#endif
+
+struct wifi_platform_data sholest_wifi_control = {
+        .set_power	= sholest_wifi_power,
+	.set_reset	= sholest_wifi_reset,
+	.set_carddetect	= sholest_wifi_set_carddetect,
+};
+
+#ifdef CONFIG_WIFI_CONTROL_FUNC
+static struct resource sholest_wifi_resources[] = {
+	[0] = {
+		.name		= "device_wifi_irq",
+		.start		= OMAP_GPIO_IRQ(SHOLEST_WIFI_IRQ_GPIO),
+		.end		= OMAP_GPIO_IRQ(SHOLEST_WIFI_IRQ_GPIO),
+		.flags          = IORESOURCE_IRQ | IORESOURCE_IRQ_LOWEDGE,
+	},
+};
+
+static struct platform_device sholest_wifi_device = {
+        .name           = "device_wifi",
+        .id             = 1,
+        .num_resources  = ARRAY_SIZE(sholest_wifi_resources),
+        .resource       = sholest_wifi_resources,
+        .dev            = {
+                .platform_data = &sholest_wifi_control,
+        },
+};
+#endif
+
+static int __init sholest_wifi_init(void)
+{
+	int ret;
+
+	printk("%s: start\n", __func__);
+	ret = gpio_request(SHOLEST_WIFI_IRQ_GPIO, "wifi_irq");
+	if (ret < 0) {
+		printk(KERN_ERR "%s: can't reserve GPIO: %d\n", __func__,
+			SHOLEST_WIFI_IRQ_GPIO);
+		goto out;
+	}
+	ret = gpio_request(SHOLEST_WIFI_PMENA_GPIO, "wifi_pmena");
+	if (ret < 0) {
+		printk(KERN_ERR "%s: can't reserve GPIO: %d\n", __func__,
+			SHOLEST_WIFI_PMENA_GPIO);
+		gpio_free(SHOLEST_WIFI_IRQ_GPIO);
+		goto out;
+	}
+	gpio_direction_input(SHOLEST_WIFI_IRQ_GPIO);
+	gpio_direction_output(SHOLEST_WIFI_PMENA_GPIO, 0);
+#ifdef CONFIG_WIFI_CONTROL_FUNC
+	ret = platform_device_register(&sholest_wifi_device);
+#endif
+out:
+        return ret;
+}
+
+device_initcall(sholest_wifi_init);
+
+#if defined(CONFIG_DEBUG_FS)
+
+static int sholestmmc_dbg_wifi_reset_set(void *data, u64 val)
+{
+	sholest_wifi_reset((int) val);
+	return 0;
+}
+
+static int sholestmmc_dbg_wifi_reset_get(void *data, u64 *val)
+{
+	*val = sholest_wifi_reset_state;
+	return 0;
+}
+
+static int sholestmmc_dbg_wifi_cd_set(void *data, u64 val)
+{
+	sholest_wifi_set_carddetect((int) val);
+	return 0;
+}
+
+static int sholestmmc_dbg_wifi_cd_get(void *data, u64 *val)
+{
+	*val = sholest_wifi_cd;
+	return 0;
+}
+
+static int sholestmmc_dbg_wifi_pwr_set(void *data, u64 val)
+{
+	sholest_wifi_power((int) val);
+	return 0;
+}
+
+static int sholestmmc_dbg_wifi_pwr_get(void *data, u64 *val)
+{
+	*val = sholest_wifi_power_state;
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(sholestmmc_dbg_wifi_reset_fops,
+			sholestmmc_dbg_wifi_reset_get,
+			sholestmmc_dbg_wifi_reset_set, "%llu\n");
+
+DEFINE_SIMPLE_ATTRIBUTE(sholestmmc_dbg_wifi_cd_fops,
+			sholestmmc_dbg_wifi_cd_get,
+			sholestmmc_dbg_wifi_cd_set, "%llu\n");
+
+DEFINE_SIMPLE_ATTRIBUTE(sholestmmc_dbg_wifi_pwr_fops,
+			sholestmmc_dbg_wifi_pwr_get,
+			sholestmmc_dbg_wifi_pwr_set, "%llu\n");
+
+static int __init sholestmmc_dbg_init(void)
+{
+	struct dentry *dent;
+
+	dent = debugfs_create_dir("mapphone_mmc_dbg", 0);
+	if (IS_ERR(dent))
+		return PTR_ERR(dent);
+
+	debugfs_create_file("wifi_reset", 0644, dent, NULL,
+			    &sholestmmc_dbg_wifi_reset_fops);
+	debugfs_create_file("wifi_cd", 0644, dent, NULL,
+			    &sholestmmc_dbg_wifi_cd_fops);
+	debugfs_create_file("wifi_pwr", 0644, dent, NULL,
+			    &sholestmmc_dbg_wifi_pwr_fops);
+	return 0;
+}
+
+device_initcall(sholestmmc_dbg_init);
+#endif
diff --git a/arch/arm/mach-omap2/board-sholest.c b/arch/arm/mach-omap2/board-sholest.c
new file mode 100644
index 0000000..2842de5
--- /dev/null
+++ b/arch/arm/mach-omap2/board-sholest.c
@@ -0,0 +1,1820 @@
+/*
+ * linux/arch/arm/mach-omap2/board-sholest.c
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * Modified from mach-omap3/board-mapphone.c
+ *
+ * Copyright (C) 2007 Texas Instruments
+ *
+ * Modified from mach-omap2/board-generic.c
+ *
+ * Initial code: Syed Mohammed Khasim
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+#include <linux/reboot.h>
+#include <linux/qtouch_obp_ts.h>
+#include <linux/led-cpcap-lm3554.h>
+#include <linux/led-lm3530.h>
+#include <linux/usb/omap.h>
+#include <linux/wl127x-rfkill.h>
+#include <linux/wl127x-test.h>
+#include <linux/omap_mdm_ctrl.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/setup.h>
+
+#include <mach/board-sholest.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+#include <mach/mux.h>
+#include <mach/board.h>
+#include <mach/common.h>
+#include <mach/gpmc.h>
+#include <mach/usb.h>
+#include <linux/delay.h>
+#include <mach/control.h>
+#include <mach/hdq.h>
+#include <mach/system.h>
+#include <linux/usb/android.h>
+#include <linux/wakelock.h>
+
+#include "cm-regbits-34xx.h"
+
+#ifdef CONFIG_ARM_OF
+#include <mach/dt_path.h>
+#include <asm/prom.h>
+#endif
+
+#include "pm.h"
+#include "prm-regbits-34xx.h"
+#include "smartreflex.h"
+#include "omap3-opp.h"
+#include "sdram-toshiba-hynix-numonyx.h"
+#include "prcm-common.h"
+#include "cm.h"
+#include "clock.h"
+
+#ifdef CONFIG_VIDEO_OLDOMAP3
+#include <media/v4l2-int-device.h>
+#if defined(CONFIG_VIDEO_MT9P012) || defined(CONFIG_VIDEO_MT9P012_MODULE)
+#include <media/mt9p012.h>
+
+#endif
+#if defined(CONFIG_VIDEO_OV8810) || defined(CONFIG_VIDEO_OV8810_MODULE)
+#include <../drivers/media/video/ov8810.h>
+#include <../drivers/media/video/oldisp/ispcsi2.h>
+#define OV8810_CSI2_CLOCK_POLARITY	0	/* +/- pin order */
+#define OV8810_CSI2_DATA0_POLARITY	0	/* +/- pin order */
+#define OV8810_CSI2_DATA1_POLARITY	0	/* +/- pin order */
+#define OV8810_CSI2_CLOCK_LANE		1	 /* Clock lane position: 1 */
+#define OV8810_CSI2_DATA0_LANE		2	 /* Data0 lane position: 2 */
+#define OV8810_CSI2_DATA1_LANE		3	 /* Data1 lane position: 3 */
+#define OV8810_CSI2_PHY_THS_TERM	1  /* GVH */
+#define OV8810_CSI2_PHY_THS_SETTLE	21  /* GVH */
+#define OV8810_CSI2_PHY_TCLK_TERM	0
+#define OV8810_CSI2_PHY_TCLK_MISS	1
+#define OV8810_CSI2_PHY_TCLK_SETTLE	14
+#endif
+
+#if defined(CONFIG_LEDS_BD7885)
+#include <linux/leds-bd7885.h>
+#endif
+#if defined(CONFIG_LEDS_BU9847)
+#include <linux/leds-bu9847.h>
+#endif
+
+#ifdef CONFIG_VIDEO_OMAP3_HPLENS
+#include <../drivers/media/video/hplens.h>
+#endif
+#endif
+
+#define SHOLEST_IPC_USB_SUSP_GPIO	142
+#define SHOLEST_AP_TO_BP_FLASH_EN_GPIO	157
+#define SHOLEST_TOUCH_RESET_N_GPIO	164
+#define SHOLEST_TOUCH_INT_GPIO		109
+#define SHOLEST_LM_3530_INT_GPIO	41
+#define SHOLEST_AKM8973_INT_GPIO	175
+#define SHOLEST_WL1271_NSHUTDOWN_GPIO	179
+#define SHOLEST_WL1271_WAKE_GPIO    8
+#define SHOLEST_WL1271_HOSTWAKE_GPIO    178
+#define SHOLEST_AUDIO_PATH_GPIO	    143
+#define SHOLEST_BP_READY_AP_GPIO	141
+#define SHOLEST_BP_READY2_AP_GPIO	59
+#define SHOLEST_BP_RESOUT_GPIO		139
+#define SHOLEST_BP_PWRON_GPIO		137
+#define SHOLEST_AP_TO_BP_PSHOLD_GPIO	138
+#define SHOLEST_AP_TO_BP_FLASH_EN_GPIO	157
+#define SHOLEST_POWER_OFF_GPIO		176
+#define SHOLEST_BPWAKE_STROBE_GPIO	157
+#define SHOLEST_APWAKE_TRIGGER_GPIO	141
+#define DIE_ID_REG_BASE			(L4_WK_34XX_PHYS + 0xA000)
+#define DIE_ID_REG_OFFSET		0x218
+#define MAX_USB_SERIAL_NUM		17
+#define MAPPHONE_VENDOR_ID		0x22B8
+#define MAPPHONE_PRODUCT_ID		0x41D9
+#define MAPPHONE_ADB_PRODUCT_ID		0x41DB
+#define FACTORY_PRODUCT_ID		0x41E3
+#define FACTORY_ADB_PRODUCT_ID		0x41E2
+
+#define SHOLEST_MMCPROBE_ENABLED 0
+
+static char device_serial[MAX_USB_SERIAL_NUM];
+char *bp_model = "UMTS";
+
+static struct omap_opp sholest_mpu_rate_table[] = {
+	{0, 0, 0},
+	/*OPP1*/
+	{S125M, VDD1_OPP1, 0x20},
+	/*OPP2*/
+	{S250M, VDD1_OPP2, 0x27},
+	/*OPP3*/
+	{S500M, VDD1_OPP3, 0x32},
+	/*OPP4*/
+	{S550M, VDD1_OPP4, 0x38},
+	/*OPP5*/
+	{S600M, VDD1_OPP5, 0x3E},
+};
+
+#define S80M 80000000
+#define S160M 160000000
+
+static struct omap_opp sholest_l3_rate_table[] = {
+	{0, 0, 0},
+	/*OPP1*/
+	{0, VDD2_OPP1, 0x20},
+	/*OPP2*/
+	{S80M, VDD2_OPP2, 0x27},
+	/*OPP3*/
+	{S160M, VDD2_OPP3, 0x2E},
+};
+
+static struct omap_opp sholest_dsp_rate_table[] = {
+	{0, 0, 0},
+	/*OPP1*/
+	{S90M, VDD1_OPP1, 0x20},
+	/*OPP2*/
+	{S180M, VDD1_OPP2, 0x27},
+	/*OPP3*/
+	{S360M, VDD1_OPP3, 0x32},
+	/*OPP4*/
+	{S400M, VDD1_OPP4, 0x38},
+	/*OPP5*/
+	{S430M, VDD1_OPP5, 0x3E},
+};
+
+static void __init sholest_init_irq(void)
+{
+	omap2_init_common_hw(JEDEC_JESD209A_sdrc_params,
+			sholest_mpu_rate_table, sholest_dsp_rate_table,
+			sholest_l3_rate_table);
+	omap_init_irq();
+#ifdef CONFIG_OMAP3_PM
+	scm_clk_init();
+#endif
+	omap_gpio_init();
+}
+
+#define BOOT_MODE_MAX_LEN 30
+static char boot_mode[BOOT_MODE_MAX_LEN+1];
+int __init board_boot_mode_init(char *s)
+
+{
+	strncpy(boot_mode, s, BOOT_MODE_MAX_LEN);
+
+	printk(KERN_INFO "boot_mode=%s\n", boot_mode);
+
+	return 1;
+}
+__setup("androidboot.mode=", board_boot_mode_init);
+
+
+
+static struct android_usb_platform_data andusb_plat = {
+	.vendor_id      = 0x22b8,
+	.product_id     = 0x41DA,
+	.adb_product_id = 0x41DA,
+	.product_name   = "XT701",
+	.manufacturer_name	= "Motorola",
+	.serial_number		= device_serial,
+};
+
+static struct platform_device androidusb_device = {
+	.name	= "android_usb",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &andusb_plat,
+	},
+};
+
+static struct usb_mass_storage_platform_data usbms_plat = {
+	.vendor			= "Motorola",
+	.product		= "XT701",
+	.release		= 1,
+};
+
+static struct platform_device usb_mass_storage_device = {
+	.name	= "usb_mass_storage",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &usbms_plat,
+	},
+};
+
+static int cpcap_usb_connected_probe(struct platform_device *pdev)
+{
+	android_usb_set_connected(1);
+	return 0;
+}
+
+static int cpcap_usb_connected_remove(struct platform_device *pdev)
+{
+	android_usb_set_connected(0);
+	return 0;
+}
+
+static struct platform_driver cpcap_usb_connected_driver = {
+	.probe		= cpcap_usb_connected_probe,
+	.remove		= cpcap_usb_connected_remove,
+	.driver		= {
+		.name	= "cpcap_usb_connected",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static void sholest_gadget_init(void)
+{
+	unsigned int val[2];
+	unsigned int reg;
+
+	reg = DIE_ID_REG_BASE + DIE_ID_REG_OFFSET;
+	val[0] = omap_readl(reg);
+	val[1] = omap_readl(reg + 4);
+
+	snprintf(device_serial, MAX_USB_SERIAL_NUM, "%08X%08X", val[1], val[0]);
+
+	if (!strcmp(boot_mode, "factorycable"))
+		andusb_plat.factory_enabled = 1;
+	else
+		andusb_plat.factory_enabled = 0;
+
+	andusb_plat.vendor_id = MAPPHONE_VENDOR_ID;
+
+	/* check powerup reason - To be added once kernel support is available*/
+	if (andusb_plat.factory_enabled) {
+		andusb_plat.product_id = FACTORY_PRODUCT_ID;
+		andusb_plat.adb_product_id = FACTORY_ADB_PRODUCT_ID;
+	} else {
+		andusb_plat.product_id = MAPPHONE_PRODUCT_ID;
+		andusb_plat.adb_product_id = MAPPHONE_ADB_PRODUCT_ID;
+	}
+	platform_device_register(&androidusb_device);
+	platform_device_register(&usb_mass_storage_device);
+	platform_driver_register(&cpcap_usb_connected_driver);
+}
+
+static void sholest_audio_init(void)
+{
+	gpio_request(SHOLEST_AUDIO_PATH_GPIO, "mapphone audio path");
+
+	omap_cfg_reg(P21_OMAP34XX_MCBSP2_FSX);
+	omap_cfg_reg(N21_OMAP34XX_MCBSP2_CLKX);
+	omap_cfg_reg(R21_OMAP34XX_MCBSP2_DR);
+	omap_cfg_reg(M21_OMAP34XX_MCBSP2_DX);
+	omap_cfg_reg(K26_OMAP34XX_MCBSP3_FSX);
+	omap_cfg_reg(W21_OMAP34XX_MCBSP3_CLKX);
+	omap_cfg_reg(U21_OMAP34XX_MCBSP3_DR);
+	omap_cfg_reg(V21_OMAP34XX_MCBSP3_DX);
+
+	gpio_direction_output(SHOLEST_AUDIO_PATH_GPIO, 1);
+	omap_cfg_reg(AE5_34XX_GPIO143);
+}
+
+static struct omap_uart_config sholest_uart_config __initdata = {
+	.enabled_uarts = ((1 << 0) | (1 << 1) | (1 << 2)),
+};
+
+static struct omap_board_config_kernel sholest_config[] __initdata = {
+	{OMAP_TAG_UART,		&sholest_uart_config },
+};
+
+static int sholest_touch_reset(void)
+{
+	gpio_direction_output(SHOLEST_TOUCH_RESET_N_GPIO, 1);
+	msleep(1);
+	gpio_set_value(SHOLEST_TOUCH_RESET_N_GPIO, 0);
+	msleep(20);
+	gpio_set_value(SHOLEST_TOUCH_RESET_N_GPIO, 1);
+	msleep(45);
+
+	return 0;
+}
+
+static struct qtouch_ts_platform_data sholest_ts_platform_data;
+
+static ssize_t sholest_virtual_keys_show(struct kobject *kobj,
+					struct kobj_attribute *attr, char *buf)
+{
+	int key_num;
+	int string_loc = 0;
+	int num_chars;
+
+	for (key_num = 0; key_num < sholest_ts_platform_data.vkeys.count; key_num++) {
+		if (key_num != 0) {
+			num_chars = sprintf((buf + string_loc), ":");
+			string_loc += num_chars;
+		}
+
+		num_chars = sprintf((buf + string_loc),
+			__stringify(EV_KEY) ":%d:%d:%d:%d:%d",
+			sholest_ts_platform_data.vkeys.keys[key_num].code,
+			sholest_ts_platform_data.vkeys.keys[key_num].center_x,
+			sholest_ts_platform_data.vkeys.keys[key_num].center_y,
+			sholest_ts_platform_data.vkeys.keys[key_num].width,
+			sholest_ts_platform_data.vkeys.keys[key_num].height);
+		string_loc += num_chars;
+	}
+
+	sprintf((buf + string_loc), "\n");
+
+	return string_loc;
+}
+
+static struct kobj_attribute sholest_virtual_keys_attr = {
+	.attr = {
+		.name = "virtualkeys.qtouch-touchscreen",
+		.mode = S_IRUGO,
+	},
+	.show = &sholest_virtual_keys_show,
+};
+
+static struct attribute *sholest_properties_attrs[] = {
+	&sholest_virtual_keys_attr.attr,
+	NULL,
+};
+
+static struct attribute_group sholest_properties_attr_group = {
+	.attrs = sholest_properties_attrs,
+};
+
+static struct i2c_board_info __initdata sholest_i2c_bus1_board_info[];
+
+static void sholest_touch_init(void)
+{
+#ifdef CONFIG_ARM_OF
+	struct device_node *touch_node;
+	const void *touch_prop;
+	int len = 0;
+	const uint32_t *touch_val;
+
+	if ((touch_node = of_find_node_by_path(DT_PATH_TOUCH))) {
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_KEYMAP, &len)) \
+			&& len && (0 == len % sizeof(struct vkey))) {
+			sholest_ts_platform_data.vkeys.count = len / sizeof(struct vkey);
+			sholest_ts_platform_data.vkeys.keys = (struct vkey *)touch_prop;
+		}
+
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_I2C_ADDRESS, &len))) {
+			sholest_i2c_bus1_board_info[0].addr = *((int *)touch_prop);
+		}
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_FLAGS, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.flags = *touch_val;
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_ABS_MIN_X, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.abs_min_x = *touch_val;
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_ABS_MAX_X, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.abs_max_x = *touch_val;
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_ABS_MIN_Y, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.abs_min_y = *touch_val;
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_ABS_MAX_Y, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.abs_max_y = *touch_val;
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_ABS_MIN_P, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.abs_min_p = *touch_val;
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_ABS_MAX_P, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.abs_max_p = *touch_val;
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_ABS_MIN_W, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.abs_min_w = *touch_val;
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_ABS_MAX_W, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.abs_max_w = *touch_val;
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_FUZZ_X, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.fuzz_x = *touch_val;
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_FUZZ_Y, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.fuzz_y = *touch_val;
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_FUZZ_P, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.fuzz_p = *touch_val;
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_FUZZ_W, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.fuzz_w = *touch_val;
+
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_T15, &len))) {
+			sholest_ts_platform_data.key_array.cfg = (struct qtm_touch_keyarray_cfg *)touch_prop;
+		}
+
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_KEY_ARRAY_MAP, &len))) {
+			sholest_ts_platform_data.key_array.keys = (struct qtouch_key *)touch_prop;
+		}
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_KEY_ARRAY_COUNT, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.key_array.num_keys = *touch_val;
+
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_T7, &len))) {
+			sholest_ts_platform_data.power_cfg = *(struct qtm_gen_power_cfg *)touch_prop;
+		}
+
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_T8, &len))) {
+			sholest_ts_platform_data.acquire_cfg = *(struct qtm_gen_acquire_cfg *)touch_prop;
+		}
+
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_T9, &len))) {
+			sholest_ts_platform_data.multi_touch_cfg = *(struct qtm_touch_multi_cfg *)touch_prop;
+		}
+
+ 		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_T17, &len))) {
+			sholest_ts_platform_data.linear_tbl_cfg
+				= *(struct  qtm_proci_linear_tbl_cfg*)touch_prop;
+		}
+
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_T19, &len))) {
+			sholest_ts_platform_data.gpio_pwm_cfg
+				= *(struct  qtm_spt_gpio_pwm_cfg*)touch_prop;
+		}
+
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_T20, &len))) {
+			sholest_ts_platform_data.grip_suppression_cfg
+				= *(struct  qtm_proci_grip_suppression_cfg*)touch_prop;
+		}
+
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_T22, &len))) {
+			sholest_ts_platform_data.noise_suppression_cfg
+				= *(struct  qtm_procg_noise_suppression_cfg*)touch_prop;
+		}
+
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_T24, &len))) {
+			sholest_ts_platform_data.one_touch_gesture_proc_cfg
+				= *(struct  qtm_proci_one_touch_gesture_proc_cfg*)touch_prop;
+		}
+
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_T25, &len))) {
+			sholest_ts_platform_data.self_test_cfg
+				= *(struct  qtm_spt_self_test_cfg*)touch_prop;
+		}
+
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_T27, &len))) {
+			sholest_ts_platform_data.two_touch_gesture_proc_cfg
+				= *(struct  qtm_proci_two_touch_gesture_proc_cfg*)touch_prop;
+		}
+
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_T28, &len))) {
+			sholest_ts_platform_data.cte_config_cfg = *(struct  qtm_spt_cte_config_cfg*)touch_prop;
+		}
+
+		of_node_put(touch_node);
+	}
+#endif
+
+	gpio_request(SHOLEST_TOUCH_RESET_N_GPIO, "mapphone touch reset");
+	gpio_direction_output(SHOLEST_TOUCH_RESET_N_GPIO, 1);
+	omap_cfg_reg(H19_34XX_GPIO164_OUT);
+
+	gpio_request(SHOLEST_TOUCH_INT_GPIO, "mapphone touch irq");
+	gpio_direction_input(SHOLEST_TOUCH_INT_GPIO);
+	omap_cfg_reg(D25_34XX_GPIO109);
+}
+
+static void sholest_als_init(void)
+{
+	printk(KERN_INFO "%s:Initializing\n", __func__);
+	gpio_request(SHOLEST_LM_3530_INT_GPIO, "mapphone als int");
+	gpio_direction_input(SHOLEST_LM_3530_INT_GPIO);
+	omap_cfg_reg(AC27_34XX_GPIO92);
+}
+
+static struct vkey sholest_touch_vkeys[] = {
+	{
+		.code		= KEY_MENU,
+		.center_x	= 32,
+		.center_y	= 906,
+		.width		= 63,
+		.height		= 57,
+	},
+	{
+		.code		= KEY_HOME,
+		.center_x	= 168,
+		.center_y	= 906,
+		.width		= 89,
+		.height		= 57,
+	},
+	{
+		.code		= KEY_BACK,
+		.center_x	= 314,
+		.center_y	= 906,
+		.width		= 89,
+		.height		= 57,
+	},
+	{
+		.code		= KEY_SEARCH,
+		.center_x	= 449,
+		.center_y	= 906,
+		.width		= 63,
+		.height		= 57,
+	},
+};
+
+static struct qtm_touch_keyarray_cfg sholest_key_array_data[] = {
+	{
+		.ctrl		= 0,
+		.x_origin	= 0,
+		.y_origin	= 0,
+		.x_size		= 0,
+		.y_size		= 0,
+		.aks_cfg	= 0,
+		.burst_len	= 0,
+		.tch_det_thr	= 0,
+		.tch_det_int	= 0,
+		.rsvd1		= 0,
+		.rsvd2		= 0,
+	},
+	{
+		.ctrl		= 0,
+		.x_origin	= 0,
+		.y_origin	= 0,
+		.x_size		= 0,
+		.y_size		= 0,
+		.aks_cfg	= 0,
+		.burst_len	= 0,
+		.tch_det_thr	= 0,
+		.tch_det_int	= 0,
+		.rsvd1		= 0,
+		.rsvd2		= 0,
+	},
+};
+
+static struct qtouch_ts_platform_data sholest_ts_platform_data = {
+	.flags		= (QTOUCH_SWAP_XY |
+			   QTOUCH_USE_MULTITOUCH |
+			   QTOUCH_CFG_BACKUPNV |
+			   QTOUCH_EEPROM_CHECKSUM),
+	.irqflags	= (IRQF_TRIGGER_FALLING | IRQF_TRIGGER_LOW),
+	.abs_min_x	= 0,
+	.abs_max_x	= 1024,
+	.abs_min_y	= 0,
+	.abs_max_y	= 960,
+	.abs_min_p	= 0,
+	.abs_max_p	= 255,
+	.abs_min_w	= 0,
+	.abs_max_w	= 15,
+        .x_delta        = 400,
+        .y_delta        = 250,
+	.nv_checksum	= 0xf429,
+	.fuzz_x		= 0,
+	.fuzz_y		= 0,
+	.fuzz_p		= 2,
+	.fuzz_w		= 2,
+	.hw_reset	= sholest_touch_reset,
+	.key_array = {
+		.cfg		= sholest_key_array_data,
+		.keys		= NULL,
+		.num_keys	= 0,
+	},
+	.power_cfg	= {
+		.idle_acq_int	= 0x0a,
+		.active_acq_int	= 0xff,
+		.active_idle_to	= 0x32,
+	},
+	.acquire_cfg	= {
+		.charge_time	= 0x08,
+		.reserve0	= 0x00,
+		.touch_drift	= 0x0a,
+		.drift_susp	= 0x01,
+		.touch_autocal	= 0x32,
+		.sync		= 0,
+		.anti_cal_susp	= 0x01,
+		.anti_cal_sthr	= 0x00,
+	},
+	.multi_touch_cfg	= {
+		.ctrl		= 0x0b,
+		.x_origin	= 0,
+		.y_origin	= 0,
+		.x_size		= 0x12,
+		.y_size		= 0x0a,
+		.aks_cfg	= 0,
+		.burst_len	= 0x11,
+		.tch_det_thr	= 0x24,
+		.tch_det_int	= 0x02,
+		.orient		= 0,
+		.mrg_to		= 0x19,
+		.mov_hyst_init	= 0x14,
+		.mov_hyst_next	= 0x05,
+		.mov_filter	= 0x30,
+		.num_touch	= 0x02,
+		.merge_hyst	= 0x05,
+		.merge_thresh	= 0x05,
+		.amp_hyst	= 0,
+		.x_res		= 0x0000,
+		.y_res		= 0x0000,
+		.x_low_clip	= 0x05,
+		.x_high_clip	= 0x00,
+		.y_low_clip	= 0x00,
+		.y_high_clip	= 0x05,
+		.x_edge_ori	= 0x00,
+		.x_edge_cdist	= 0x00,
+		.y_edge_ori	= 0x00,
+		.y_edge_cdist	= 0x00,
+	},
+	.linear_tbl_cfg = {
+		.ctrl = 0x00,
+		.x_offset = 0x0000,
+		.x_segment = {
+			0x00, 0x00, 0x00 , 0x00,
+			0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00
+		},
+		.y_offset = 0x0000,
+		.y_segment = {
+			0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00
+		},
+	},
+	.gpio_pwm_cfg = {
+		.ctrl			= 0,
+		.report_mask		= 0,
+		.pin_direction		= 0,
+		.internal_pullup	= 0,
+		.output_value		= 0,
+		.wake_on_change		= 0,
+		.pwm_enable		= 0,
+		.pwm_period		= 0,
+		.duty_cycle_0		= 0,
+		.duty_cycle_1		= 0,
+		.duty_cycle_2		= 0,
+		.duty_cycle_3		= 0,
+		.trigger_0              = 0,
+		.trigger_1              = 0,
+		.trigger_2              = 0,
+		.trigger_3              = 0,
+	},
+	.com_cfg = {
+		.ctrl		= 0x00,
+		.cmd		= 0x00,
+	},
+	.grip_suppression_cfg = {
+		.ctrl		= 0x00,
+		.xlogrip	= 0x00,
+		.xhigrip	= 0x00,
+		.ylogrip	= 0x00,
+		.yhigrip	= 0x00,
+		.maxtchs	= 0x00,
+		.reserve0	= 0x00,
+		.szthr1		= 0x00,
+		.szthr2		= 0x00,
+		.shpthr1	= 0x00,
+		.shpthr2	= 0x00,
+	},
+	.noise_suppression_cfg = {
+		.ctrl			= 0x05,
+		.reserve0		= 0x0000,
+		.gcaf_upper_limit	= 0x0019,
+		.gcaf_lower_limit	= 0xffe7,
+		.gcaf_num_active	= 0x04,
+		.noise_threshold	= 0x12,
+		.reserve1		= 0,
+		.freq_hop_scale		= 0x01,
+		.burst_freq_0		= 0x06,
+		.burst_freq_1		= 0x0b,
+		.burst_freq_2		= 0x0f,
+		.burst_freq_3		= 0x13,
+		.burst_freq_4		= 0x15,
+		.gcaf_num_idle		= 0x04,
+	},
+	.one_touch_gesture_proc_cfg = {
+		.ctrl			= 0,
+		.reserve0		= 0,
+		.gesture_enable		= 0,
+		.pres_proc		= 0,
+		.tap_time_out		= 0,
+		.flick_time_out		= 0,
+		.drag_time_out		= 0,
+		.short_press_time_out	= 0,
+		.long_press_time_out	= 0,
+		.repeat_press_time_out	= 0,
+		.flick_threshold	= 0,
+		.drag_threshold		= 0,
+		.tap_threshold		= 0,
+		.throw_threshold	= 0,
+	},
+	.self_test_cfg = {
+		.ctrl			= 0,
+		.command		= 0,
+		.high_signal_limit_0	= 0,
+		.low_signal_limit_0	= 0,
+		.high_signal_limit_1	= 0,
+		.low_signal_limit_1	= 0,
+	},
+	.two_touch_gesture_proc_cfg = {
+		.ctrl			= 0,
+		.reserved0		= 0,
+		.reserved1		= 0,
+		.gesture_enable		= 0,
+		.rotate_threshold	= 0,
+		.zoom_threshold		= 0,
+	},
+	.cte_config_cfg = {
+		.ctrl			= 1,
+		.command		= 0,
+		.mode			= 3,
+		.idle_gcaf_depth	= 4,
+		.active_gcaf_depth	= 0x20,
+		.voltage		= 0x1e,
+	},
+	.noise1_suppression_cfg = {
+		.ctrl		= 0x00,
+		.reserved	= 0x00,
+		.atchthr	= 0x00,
+		.duty_cycle	= 0x00,
+	},
+	.userdata = {
+		.data_0		= 0x49,
+		.data_1		= 0x00,
+		.data_2		= 0x4C,
+		.data_3		= 0x00,
+		.data_4		= 0x48,
+		.data_5		= 0x00,
+		.data_6		= 0x4A,
+		.data_7		= 0x00,
+	},
+	.vkeys			= {
+		.count		= ARRAY_SIZE(sholest_touch_vkeys),
+		.keys		= sholest_touch_vkeys,
+	},
+};
+
+static struct lm3530_platform_data omap3430_als_light_data = {
+	.power_up_gen_config = 0x0b,
+	.gen_config = 0x33,
+	.als_config = 0x7B,
+	.brightness_ramp = 0x36,
+	.als_zone_info = 0x00,
+	.als_resistor_sel = 0x22,
+	.brightness_control = 0x00,
+	.zone_boundary_0 = 0x07,
+	.zone_boundary_1 = 0x29,
+	.zone_boundary_2 = 0x48,
+	.zone_boundary_3 = 0x94,
+	.zone_target_0 = 0x12,
+	.zone_target_1 = 0x1F,
+	.zone_target_2 = 0x28,
+	.zone_target_3 = 0x31,
+	.zone_target_4 = 0x3A,
+	.manual_current = 0x33,
+	.upper_curr_sel = 5,
+	.lower_curr_sel = 2,
+	.lens_loss_coeff = 6,
+};
+
+static struct lm3554_platform_data sholest_camera_flash = {
+	.torch_brightness_def = 0xa0,
+	.flash_brightness_def = 0x78,
+	.flash_duration_def = 0x28,
+	.config_reg_1_def = 0xe0,
+	.config_reg_2_def = 0xf0,
+	.vin_monitor_def = 0x03,
+	.gpio_reg_def = 0x0,
+};
+
+static struct i2c_board_info __initdata sholest_i2c_bus1_board_info[] = {
+	{
+		I2C_BOARD_INFO(QTOUCH_TS_NAME, 0x4A),
+		.platform_data = &sholest_ts_platform_data,
+		.irq = OMAP_GPIO_IRQ(SHOLEST_TOUCH_INT_GPIO),
+	},
+	{
+		I2C_BOARD_INFO(LD_LM3530_NAME, 0x38),
+		.platform_data = &omap3430_als_light_data,
+		.irq = OMAP_GPIO_IRQ(SHOLEST_LM_3530_INT_GPIO),
+	},
+};
+
+#ifdef CONFIG_SENSORS_LIS331DLH
+extern struct lis331dlh_platform_data sholest_lis331dlh_data;
+#endif
+#ifdef CONFIG_MOT_FEAT_LP3907
+extern struct lp3907_platform_data sholest_lp3907_data;
+#endif
+
+static struct i2c_board_info __initdata sholest_i2c_bus2_board_info[] = {
+	{
+		I2C_BOARD_INFO("akm8973", 0x1C),
+		.irq = OMAP_GPIO_IRQ(SHOLEST_AKM8973_INT_GPIO),
+	},
+#ifdef CONFIG_SENSORS_LIS331DLH
+	{
+		I2C_BOARD_INFO("lis331dlh", 0x19),
+		.platform_data = &sholest_lis331dlh_data,
+	},
+#endif
+#ifdef CONFIG_MOT_FEAT_LP3907
+	{
+		I2C_BOARD_INFO("lp3907", 0x61),
+		.platform_data = &sholest_lp3907_data,
+	},
+#endif
+};
+
+static struct i2c_board_info __initdata sholest_i2c_bus3_board_info[] = {
+	{
+		I2C_BOARD_INFO("lm3554_led", 0x53),
+		.platform_data = &sholest_camera_flash,
+	},
+#if defined(CONFIG_VIDEO_MT9P012) || defined(CONFIG_VIDEO_MT9P012_MODULE)
+	{
+		I2C_BOARD_INFO("mt9p012", 0x36),
+		.platform_data = &sholest_mt9p012_platform_data,
+	},
+#endif
+#if defined(CONFIG_VIDEO_OV8810)
+	{
+		I2C_BOARD_INFO("ov8810", OV8810_I2C_ADDR),
+		.platform_data = &sholest_ov8810_platform_data,
+	},
+#endif
+#ifdef CONFIG_VIDEO_OMAP3_HPLENS
+	{
+		I2C_BOARD_INFO("HP_GEN_LENS", 0x04),
+		.platform_data = &sholest_hplens_platform_data,
+	},
+#endif
+	{
+		I2C_BOARD_INFO("tda19989", 0x70),
+	},
+#if defined(CONFIG_LEDS_BD7885)
+	{
+		I2C_BOARD_INFO(BD7885_DEVICE_NAME, BD7885_SLAVE_ADDR),
+	},
+#endif	/* CONFIG_LEDS_BD7885 */
+#if defined(CONFIG_LEDS_BU9847)
+	{
+		I2C_BOARD_INFO(BU9847_DEVICE_NAME, BU9847_SLAVE_ADDR),
+	},
+#endif/*CONFIG_LEDS_BU9847*/
+};
+
+static int __init sholest_i2c_init(void)
+{
+	omap_register_i2c_bus(1, 400, sholest_i2c_bus1_board_info,
+			      ARRAY_SIZE(sholest_i2c_bus1_board_info));
+	omap_register_i2c_bus(2, 400, sholest_i2c_bus2_board_info,
+			      ARRAY_SIZE(sholest_i2c_bus2_board_info));
+	omap_register_i2c_bus(3, 400, sholest_i2c_bus3_board_info,
+			      ARRAY_SIZE(sholest_i2c_bus3_board_info));
+	return 0;
+}
+
+arch_initcall(sholest_i2c_init);
+
+extern void __init sholest_spi_init(void);
+extern void __init sholest_flash_init(void);
+extern void __init sholest_gpio_iomux_init(void);
+#ifdef CONFIG_MOT_FEAT_MDTV
+extern void __init sholest_mdtv_init(void);
+#endif
+
+#if defined(CONFIG_USB_EHCI_HCD) || defined(CONFIG_USB_EHCI_HCD_MODULE)
+
+static int sholest_usb_port_startup(struct platform_device *dev, int port)
+{
+	int r;
+
+	if (port == 2) {
+		r = gpio_request(SHOLEST_IPC_USB_SUSP_GPIO, "ipc_usb_susp");
+		if (r < 0) {
+			printk(KERN_WARNING "Could not request GPIO %d"
+			       " for IPC_USB_SUSP\n",
+			       SHOLEST_IPC_USB_SUSP_GPIO);
+			return r;
+		}
+		gpio_direction_output(SHOLEST_IPC_USB_SUSP_GPIO, 0);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void sholest_usb_port_shutdown(struct platform_device *dev, int port)
+{
+	if (port == 2)
+		gpio_free(SHOLEST_IPC_USB_SUSP_GPIO);
+}
+
+
+static void sholest_usb_port_suspend(struct platform_device *dev,
+				    int port, int suspend)
+{
+	if (port == 2)
+		gpio_set_value(SHOLEST_IPC_USB_SUSP_GPIO, suspend);
+}
+
+
+static struct omap_usb_port_data usb_port_data[] = {
+	[0] = { .flags = 0x0, }, /* disabled */
+	[1] = { .flags = 0x0, }, /* disabled */
+	[2] = {
+		.flags = OMAP_USB_PORT_FLAG_ENABLED |
+			OMAP_USB_PORT_FLAG_AUTOIDLE |
+			OMAP_USB_PORT_FLAG_NOBITSTUFF,
+		.mode = OMAP_USB_PORT_MODE_UTMI_PHY_4PIN,
+		.startup = sholest_usb_port_startup,
+		.shutdown = sholest_usb_port_shutdown,
+		.suspend = sholest_usb_port_suspend,
+	},
+};
+
+static int omap_ohci_bus_check_ctrl_standby(void);
+static struct omap_usb_platform_data usb_platform_data = {
+	.port_data = usb_port_data,
+	.num_ports = ARRAY_SIZE(usb_port_data),
+	.usbhost_standby_status	= omap_ohci_bus_check_ctrl_standby,
+};
+
+static struct resource ehci_resources[] = {
+	[0] = {
+		.start	= OMAP34XX_HSUSB_HOST_BASE + 0x800,
+		.end	= OMAP34XX_HSUSB_HOST_BASE + 0x800 + SZ_1K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {         /* general IRQ */
+		.start	= INT_34XX_EHCI_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+static u64 ehci_dmamask = ~(u32)0;
+static struct platform_device ehci_device = {
+	.name		= "ehci-omap",
+	.id		= 0,
+	.dev = {
+		.dma_mask		= &ehci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+		.platform_data		= &usb_platform_data,
+	},
+	.num_resources	= ARRAY_SIZE(ehci_resources),
+	.resource	= ehci_resources,
+};
+#endif
+
+#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE) || defined(CONFIG_USB_EHCI_HCD)
+static int omap_ohci_bus_check_ctrl_standby(void)
+{
+	u32 val;
+
+	val = cm_read_mod_reg(OMAP3430ES2_USBHOST_MOD, CM_IDLEST);
+	if (val & OMAP3430ES2_ST_USBHOST_STDBY_MASK)
+		return 1;
+	else
+		return 0;
+}
+#endif
+
+#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)
+
+
+static struct resource ohci_resources[] = {
+	[0] = {
+		.start	= OMAP34XX_HSUSB_HOST_BASE + 0x400,
+		.end	= OMAP34XX_HSUSB_HOST_BASE + 0x400 + SZ_1K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {         /* general IRQ */
+		.start	= INT_34XX_OHCI_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+static u64 ohci_dmamask = ~(u32)0;
+
+static struct omap_usb_config dummy_usb_config = {
+	.usbhost_standby_status	= omap_ohci_bus_check_ctrl_standby,
+	.usb_remote_wake_gpio = SHOLEST_BP_READY2_AP_GPIO,
+};
+
+static struct platform_device ohci_device = {
+	.name		= "ohci",
+	.id		= 0,
+	.dev = {
+		.dma_mask		= &ohci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+		.platform_data	= &dummy_usb_config,
+	},
+	.num_resources	= ARRAY_SIZE(ohci_resources),
+	.resource	= ohci_resources,
+};
+#endif /* OHCI specific data */
+
+
+static void __init sholest_ehci_init(void)
+{
+	omap_cfg_reg(AF5_34XX_GPIO142);		/*  IPC_USB_SUSP      */
+	omap_cfg_reg(AD1_3430_USB3FS_PHY_MM3_RXRCV);
+	omap_cfg_reg(AD2_3430_USB3FS_PHY_MM3_TXDAT);
+	omap_cfg_reg(AC1_3430_USB3FS_PHY_MM3_TXEN_N);
+	omap_cfg_reg(AE1_3430_USB3FS_PHY_MM3_TXSE0);
+
+#if defined(CONFIG_USB_EHCI_HCD) || defined(CONFIG_USB_EHCI_HCD_MODULE)
+	platform_device_register(&ehci_device);
+#endif
+#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)
+	if (is_cdma_phone())
+		platform_device_register(&ohci_device);
+#endif
+}
+
+static void __init sholest_sdrc_init(void)
+{
+	/* Ensure SDRC pins are mux'd for self-refresh */
+	omap_cfg_reg(H16_34XX_SDRC_CKE0);
+	omap_cfg_reg(H17_34XX_SDRC_CKE1);
+}
+
+static void __init sholest_serial_init(void)
+{
+	omap_cfg_reg(AA8_3430_UART1_TX);
+	omap_cfg_reg(Y8_3430_UART1_RX);
+	omap_cfg_reg(AA9_3430_UART1_RTS);
+	omap_cfg_reg(W8_3430_UART1_CTS);
+	omap_cfg_reg(AA25_34XX_UART2_TX);
+	omap_cfg_reg(AD25_34XX_UART2_RX);
+	omap_cfg_reg(AB25_34XX_UART2_RTS);
+	omap_cfg_reg(AB26_34XX_UART2_CTS);
+
+	omap_serial_init(SHOLEST_BPWAKE_STROBE_GPIO, 0x01);
+}
+
+/* SMPS I2C voltage control register Address for VDD1 */
+#define SHOLEST_R_VDD1_SR_CONTROL		0x00
+/* SMPS I2C voltage control register Address for VDD2 */
+#define SHOLEST_R_VDD2_SR_CONTROL		0x00
+/* SMPS I2C Address for VDD1 */
+#define SHOLEST_R_SRI2C_SLAVE_ADDR_SA0		0x1
+/* SMPS I2C Address for VDD2 */
+#define SHOLEST_R_SRI2C_SLAVE_ADDR_SA1		0x2
+/* SMPS I2C voltage control register Address for VDD1, used for SR command */
+#define SHOLEST_R_SMPS_VOL_CNTL_CMDRA0		0x01
+/* SMPS I2C voltage control register Address for VDD2, used for SR command */
+#define SHOLEST_R_SMPS_VOL_CNTL_CMDRA1		0x01
+
+static struct prm_setup_vc sholest_prm_setup = {
+	.clksetup = 0x4c,
+	.voltsetup_time1 = 0x94,
+	.voltsetup_time2 = 0x94,
+	.voltoffset = 0x0,
+	.voltsetup2 = 0x0,
+	.vdd0_on = 0x65,
+	.vdd0_onlp = 0x45,
+	.vdd0_ret = 0x19,
+	.vdd0_off = 0x00,
+	.vdd1_on = 0x65,
+	.vdd1_onlp = 0x45,
+	.vdd1_ret = 0x19,
+	.vdd1_off = 0x00,
+	.i2c_slave_ra = (SHOLEST_R_SRI2C_SLAVE_ADDR_SA1 <<
+			OMAP3430_SMPS_SA1_SHIFT) |
+			(SHOLEST_R_SRI2C_SLAVE_ADDR_SA0 <<
+			 OMAP3430_SMPS_SA0_SHIFT),
+	.vdd_vol_ra = (SHOLEST_R_VDD2_SR_CONTROL << OMAP3430_VOLRA1_SHIFT) |
+			(SHOLEST_R_VDD1_SR_CONTROL << OMAP3430_VOLRA0_SHIFT),
+	/* vdd_vol_ra controls both cmd and vol, set the address equal */
+	.vdd_cmd_ra = (SHOLEST_R_SMPS_VOL_CNTL_CMDRA1 << OMAP3430_CMDRA1_SHIFT) |
+		(SHOLEST_R_SMPS_VOL_CNTL_CMDRA0 << OMAP3430_CMDRA0_SHIFT),
+	.vdd_ch_conf = OMAP3430_CMD1 | OMAP3430_RACEN0 |
+			OMAP3430_PRM_VC_CH_CONF_SA1 | OMAP3430_RACEN1 |
+			OMAP3430_RAV1 | OMAP3430_RAC1, OMAP3430_GR_MOD,
+	.vdd_i2c_cfg = OMAP3430_HSEN,
+};
+
+#define R_SMPS_VOL_OPP1_RA0		0x02
+#define R_SMPS_VOL_OPP1_RA1		0x02
+#define R_SMPS_VOL_OPP2_RA0		0x03
+#define R_SMPS_VOL_OPP2_RA1		0x03
+
+#ifdef CONFIG_OMAP_SMARTREFLEX
+int sholest_voltagescale_vcbypass(u32 target_opp, u32 current_opp,
+					u8 target_vsel, u8 current_vsel)
+{
+
+	int sr_status = 0;
+	u32 vdd, target_opp_no;
+	u8 slave_addr = 0, opp_reg_addr = 0, volt_reg_addr = 0;
+
+	vdd = get_vdd(target_opp);
+	target_opp_no = get_opp_no(target_opp);
+
+	if (vdd == VDD1_OPP) {
+		sr_status = sr_stop_vddautocomap(SR1);
+		slave_addr = SHOLEST_R_SRI2C_SLAVE_ADDR_SA0;
+		volt_reg_addr = SHOLEST_R_VDD1_SR_CONTROL;
+		opp_reg_addr = R_SMPS_VOL_OPP2_RA0;
+
+	} else if (vdd == VDD2_OPP) {
+		sr_status = sr_stop_vddautocomap(SR2);
+		slave_addr = SHOLEST_R_SRI2C_SLAVE_ADDR_SA1;
+		volt_reg_addr = SHOLEST_R_VDD2_SR_CONTROL;
+		opp_reg_addr = R_SMPS_VOL_OPP2_RA1;
+	}
+
+	/* Update the CPCAP SWx OPP2 register, stores the on voltage value */
+	omap3_bypass_cmd(slave_addr, opp_reg_addr, target_vsel);
+
+	/* Update the CPCAP SWx voltage register, change the output voltage */
+	omap3_bypass_cmd(slave_addr, volt_reg_addr, target_vsel);
+
+	if (target_vsel > current_vsel)
+		udelay(target_vsel - current_vsel + 4);
+
+	if (sr_status) {
+		if (vdd == VDD1_OPP)
+			sr_start_vddautocomap(SR1, target_opp_no);
+		else if (vdd == VDD2_OPP)
+			sr_start_vddautocomap(SR2, target_opp_no);
+	}
+
+	return SR_PASS;
+}
+#endif
+
+/* Sholest specific PM */
+
+extern void omap_uart_block_sleep(int num);
+static struct wake_lock baseband_wakeup_wakelock;
+static int sholest_bpwake_irqhandler(int irq, void *unused)
+{
+	omap_uart_block_sleep(0);
+	/*
+	 * Ignore the BP pokes while we're awake
+	 * uart_block_sleep keeps uart clock active for 500 ms,
+	 * prevent suspend for 1 sec to be safe
+	 */
+	wake_lock_timeout(&baseband_wakeup_wakelock, HZ);
+	return IRQ_HANDLED;
+}
+
+static int sholest_bpwake_probe(struct platform_device *pdev)
+{
+	int rc;
+
+	gpio_request(SHOLEST_APWAKE_TRIGGER_GPIO, "BP -> AP IPC trigger");
+	gpio_direction_input(SHOLEST_APWAKE_TRIGGER_GPIO);
+
+	wake_lock_init(&baseband_wakeup_wakelock, WAKE_LOCK_SUSPEND, "bpwake");
+
+	rc = request_irq(gpio_to_irq(SHOLEST_APWAKE_TRIGGER_GPIO),
+			 sholest_bpwake_irqhandler,
+			 IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+			 "Remote Wakeup", NULL);
+	if (rc) {
+		wake_lock_destroy(&baseband_wakeup_wakelock);
+		printk(KERN_ERR
+		       "Failed requesting APWAKE_TRIGGER irq (%d)\n", rc);
+		return rc;
+	}
+
+	enable_irq_wake(gpio_to_irq(SHOLEST_APWAKE_TRIGGER_GPIO));
+	return 0;
+}
+
+static int sholest_bpwake_remove(struct platform_device *pdev)
+{
+	wake_lock_destroy(&baseband_wakeup_wakelock);
+	free_irq(gpio_to_irq(SHOLEST_APWAKE_TRIGGER_GPIO), NULL);
+	return 0;
+}
+
+static int sholest_bpwake_suspend(struct platform_device *pdev,
+					pm_message_t state)
+{
+	return 0;
+}
+
+static int sholest_bpwake_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver sholest_bpwake_driver = {
+	.probe		= sholest_bpwake_probe,
+	.remove		= sholest_bpwake_remove,
+	.suspend	= sholest_bpwake_suspend,
+	.resume		= sholest_bpwake_resume,
+	.driver		= {
+		.name		= "mapphone_bpwake",
+		.owner		= THIS_MODULE,
+	},
+};
+
+static struct platform_device sholest_bpwake_device = {
+	.name		= "mapphone_bpwake",
+	.id		= -1,
+	.num_resources	= 0,
+};
+
+/* Choose cold or warm reset
+ *    RST_TIME1>4ms will trigger CPCAP to trigger a system cold reset */
+static void sholest_pm_set_reset(char cold)
+{
+	if (cold) {
+		/* Configure RST_TIME1 to 6ms  */
+		prm_rmw_mod_reg_bits(OMAP_RSTTIME1_MASK,
+		0xc8<<OMAP_RSTTIME1_SHIFT,
+		OMAP3430_GR_MOD,
+		OMAP3_PRM_RSTTIME_OFFSET);
+	} else {
+		/* Configure RST_TIME1 to 30us  */
+		prm_rmw_mod_reg_bits(OMAP_RSTTIME1_MASK,
+		0x01<<OMAP_RSTTIME1_SHIFT,
+		OMAP3430_GR_MOD,
+		OMAP3_PRM_RSTTIME_OFFSET);
+	}
+}
+
+static int sholest_pm_reboot_call(struct notifier_block *this,
+			unsigned long code, void *cmd)
+{
+	int result = NOTIFY_DONE;
+
+	if (code == SYS_RESTART) {
+		/* set cold reset */
+		sholest_pm_set_reset(1);
+	}
+
+	return result;
+}
+
+static struct notifier_block sholest_pm_reboot_notifier = {
+	.notifier_call = sholest_pm_reboot_call,
+};
+
+#ifdef CONFIG_MEM_DUMP
+
+#define WARMRESET 1
+#define COLDRESET 0
+
+static unsigned long reset_status = COLDRESET ;
+#endif
+static void sholest_pm_init(void)
+{
+	omap3_set_prm_setup_vc(&sholest_prm_setup);
+	omap3_voltagescale_vcbypass_setup(sholest_voltagescale_vcbypass);
+
+    /* Set CPCAP SW1/SW2 I2C CNTL Reg to 0x45(PSM/PSM mode, VPLL enabled) to
+	 * avoid extra current drain in active case before hit RET once*/
+
+	/* Initialize CPCAP SW1&SW2 OPP1&OPP2 registers */
+	/* SW1, OPP1 for RET Voltage --- 1.0V,
+	 * OPP2 for ON Voltge --- 1.225V(OPP3)
+	 */
+	omap3_bypass_cmd(SHOLEST_R_SRI2C_SLAVE_ADDR_SA0,
+				SHOLEST_R_SMPS_VOL_CNTL_CMDRA0, 0x45);
+	omap3_bypass_cmd(SHOLEST_R_SRI2C_SLAVE_ADDR_SA0,
+				R_SMPS_VOL_OPP1_RA0, 0x20);
+	omap3_bypass_cmd(SHOLEST_R_SRI2C_SLAVE_ADDR_SA0,
+				R_SMPS_VOL_OPP2_RA0, 0x32);
+
+	/* SW2, OPP1 for RET Voltage --- 1.0V,
+	 * OPP2 for ON Voltge --- 1.175V(OPP3)
+	 */
+	omap3_bypass_cmd(SHOLEST_R_SRI2C_SLAVE_ADDR_SA1,
+				SHOLEST_R_SMPS_VOL_CNTL_CMDRA1, 0x45);
+	omap3_bypass_cmd(SHOLEST_R_SRI2C_SLAVE_ADDR_SA1,
+				R_SMPS_VOL_OPP1_RA1, 0x20);
+	omap3_bypass_cmd(SHOLEST_R_SRI2C_SLAVE_ADDR_SA1,
+				R_SMPS_VOL_OPP2_RA1, 0x2E);
+
+	/* Configure BP <-> AP wake pins */
+	omap_cfg_reg(AA21_34XX_GPIO157_OUT);
+	omap_cfg_reg(AE6_34XX_GPIO141_DOWN);
+
+	platform_device_register(&sholest_bpwake_device);
+	platform_driver_register(&sholest_bpwake_driver);
+
+#ifdef CONFIG_MEM_DUMP
+	if (reset_status == COLDRESET)
+		sholest_pm_set_reset(1);
+	else
+		sholest_pm_set_reset(0);
+#else
+	/* set cold reset, will move to warm reset once ready */
+	sholest_pm_set_reset(1);
+
+#endif
+	register_reboot_notifier(&sholest_pm_reboot_notifier);
+}
+
+#ifdef CONFIG_MEM_DUMP
+static struct proc_dir_entry *proc_entry ;
+
+ssize_t reset_proc_read(char *page, char **start, off_t off, \
+   int count, int *eof, void *data)
+{
+	int len ;
+    /* don't visit offset */
+	if (off > 0) {
+		*eof = 1 ;
+		return 0 ;
+	}
+	len = snprintf(page, sizeof(page), "%x\n", (unsigned int)reset_status) ;
+	return len ;
+}
+
+ssize_t reset_proc_write(struct file *filp, const char __user *buff, \
+  unsigned long len, void *data)
+{
+#define MAX_UL_LEN 8
+	char k_buf[MAX_UL_LEN] ;
+	int count = min((unsigned long)MAX_UL_LEN, len) ;
+	int ret ;
+
+	if (copy_from_user(k_buf, buff, count)) {
+		ret = -EFAULT ;
+		goto err ;
+	} else{
+		if (k_buf[0] == '0') {
+			reset_status = COLDRESET;
+			sholest_pm_set_reset(1);
+			printk(KERN_ERR"switch to cold reset\n");
+		} else if (k_buf[0] == '1') {
+			reset_status = WARMRESET;
+			sholest_pm_set_reset(0);
+			printk(KERN_ERR"switch to warm reset\n");
+		} else{
+			ret = -EFAULT;
+			goto err;
+		}
+	return count ;
+	}
+err:
+	return ret ;
+}
+
+static void  reset_proc_init(void)
+{
+	proc_entry = create_proc_entry("reset_proc", 0666, NULL);
+	if (proc_entry == NULL) {
+		printk(KERN_INFO"Couldn't create proc entry\n") ;
+	} else{
+		proc_entry->read_proc = reset_proc_read ;
+		proc_entry->write_proc = reset_proc_write ;
+		proc_entry->owner = THIS_MODULE ;
+	}
+}
+
+int __init warmreset_init(char *s)
+{
+	/* configure to warmreset */
+	reset_status = WARMRESET;
+	sholest_pm_set_reset(0);
+	return 1;
+}
+__setup("warmreset_debug=", warmreset_init);
+#endif
+
+static void __init config_wlan_gpio(void)
+{
+	/* WLAN PE and IRQ */
+	omap_cfg_reg(AE22_34XX_GPIO186_OUT);
+	omap_cfg_reg(J8_3430_GPIO65);
+}
+
+static void __init config_mmc2_init(void)
+{
+	u32 val;
+
+	/* MMC2 */
+	omap_cfg_reg(AE2_3430_MMC2_CLK);
+	omap_cfg_reg(AG5_3430_MMC2_CMD);
+	omap_cfg_reg(AH5_3430_MMC2_DAT0);
+	omap_cfg_reg(AH4_3430_MMC2_DAT1);
+	omap_cfg_reg(AG4_3430_MMC2_DAT2);
+	omap_cfg_reg(AF4_3430_MMC2_DAT3);
+
+	/* Set internal loopback clock */
+	val = omap_ctrl_readl(OMAP343X_CONTROL_DEVCONF1);
+	omap_ctrl_writel((val | OMAP2_MMCSDIO2ADPCLKISEL),
+				OMAP343X_CONTROL_DEVCONF1);
+}
+
+/* must match value in drivers/w1/w1_family.h */
+#define W1_EEPROM_DS2502        0x89
+static struct omap2_hdq_platform_config sholest_hdq_data = {
+	.mode = OMAP_SDQ_MODE,
+	.id = W1_EEPROM_DS2502,
+};
+
+static int __init omap_hdq_init(void)
+{
+	omap_cfg_reg(J25_34XX_HDQ_SIO);
+	omap_hdq_device.dev.platform_data = &sholest_hdq_data;
+	return platform_device_register(&omap_hdq_device);
+}
+
+static int sholest_wl1271_init(void)
+{
+	int rc = 0;
+
+	/* wl1271 BT chip init sequence */
+	gpio_direction_output(SHOLEST_WL1271_NSHUTDOWN_GPIO, 0);
+	msleep(5);
+	gpio_set_value(SHOLEST_WL1271_NSHUTDOWN_GPIO, 1);
+	msleep(10);
+	gpio_set_value(SHOLEST_WL1271_NSHUTDOWN_GPIO, 0);
+	msleep(5);
+
+	/* Reserve BT wake and hostwake GPIOs */
+	rc = gpio_request(SHOLEST_WL1271_WAKE_GPIO, "wl127x_wake_gpio");
+	if (unlikely(rc))
+		return rc;
+
+	rc = gpio_request(SHOLEST_WL1271_HOSTWAKE_GPIO,
+				"wl127x_hostwake_gpio");
+	if (unlikely(rc))
+		return rc;
+
+	gpio_direction_output(SHOLEST_WL1271_WAKE_GPIO, 1);
+	gpio_direction_input(SHOLEST_WL1271_HOSTWAKE_GPIO);
+
+	return 0;
+}
+
+static int sholest_wl1271_release(void)
+{
+	gpio_free(SHOLEST_WL1271_WAKE_GPIO);
+	gpio_free(SHOLEST_WL1271_HOSTWAKE_GPIO);
+
+	return 0;
+}
+
+static int sholest_wl1271_enable(void)
+{
+	gpio_set_value(SHOLEST_WL1271_WAKE_GPIO, 0);
+	return 0;
+}
+
+static int sholest_wl1271_disable(void)
+{
+	gpio_set_value(SHOLEST_WL1271_WAKE_GPIO, 1);
+	return 0;
+}
+
+static struct wl127x_rfkill_platform_data sholest_wl1271_pdata = {
+	.bt_nshutdown_gpio = SHOLEST_WL1271_NSHUTDOWN_GPIO,
+	.fm_enable_gpio = -1,
+	.bt_hw_init = sholest_wl1271_init,
+	.bt_hw_release = sholest_wl1271_release,
+	.bt_hw_enable = sholest_wl1271_enable,
+	.bt_hw_disable = sholest_wl1271_disable,
+};
+
+static struct platform_device sholest_wl1271_device = {
+	.name = "wl127x-rfkill",
+	.id = 0,
+	.dev.platform_data = &sholest_wl1271_pdata,
+};
+
+static struct wl127x_test_platform_data sholest_wl1271_test_pdata = {
+	.btwake_gpio = SHOLEST_WL1271_WAKE_GPIO,
+	.hostwake_gpio = SHOLEST_WL1271_HOSTWAKE_GPIO,
+};
+
+static struct platform_device sholest_wl1271_test_device = {
+	.name = "wl127x-test",
+	.id = 0,
+	.dev.platform_data = &sholest_wl1271_test_pdata,
+};
+
+static void __init sholest_bt_init(void)
+{
+	/* Mux setup for Bluetooth chip-enable */
+	omap_cfg_reg(T3_34XX_GPIO_179);
+
+	/* Mux setup for BT wake GPIO and hostwake GPIO */
+	omap_cfg_reg(AF21_34XX_GPIO8);
+	omap_cfg_reg(W7_34XX_GPIO178_DOWN);
+
+	platform_device_register(&sholest_wl1271_device);
+	platform_device_register(&sholest_wl1271_test_device);
+}
+
+static struct omap_mdm_ctrl_platform_data omap_mdm_ctrl_platform_data = {
+	.bp_ready_ap_gpio = SHOLEST_BP_READY_AP_GPIO,
+	.bp_ready2_ap_gpio = SHOLEST_BP_READY2_AP_GPIO,
+	.bp_resout_gpio = SHOLEST_BP_RESOUT_GPIO,
+	.bp_pwron_gpio = SHOLEST_BP_PWRON_GPIO,
+	.ap_to_bp_pshold_gpio = SHOLEST_AP_TO_BP_PSHOLD_GPIO,
+	.ap_to_bp_flash_en_gpio = SHOLEST_AP_TO_BP_FLASH_EN_GPIO,
+};
+
+static struct platform_device omap_mdm_ctrl_platform_device = {
+	.name = OMAP_MDM_CTRL_MODULE_NAME,
+	.id = -1,
+	.dev = {
+		.platform_data = &omap_mdm_ctrl_platform_data,
+	},
+};
+
+static int __init sholest_omap_mdm_ctrl_init(void)
+{
+	if (!is_cdma_phone())
+		return -ENODEV;
+
+	gpio_request(SHOLEST_BP_READY2_AP_GPIO, "BP Flash Ready");
+	gpio_direction_input(SHOLEST_BP_READY2_AP_GPIO);
+	omap_cfg_reg(T4_34XX_GPIO59_DOWN);
+
+	gpio_request(SHOLEST_BP_RESOUT_GPIO, "BP Reset Output");
+	gpio_direction_input(SHOLEST_BP_RESOUT_GPIO);
+	omap_cfg_reg(AE3_34XX_GPIO139_DOWN);
+
+	gpio_request(SHOLEST_BP_PWRON_GPIO, "BP Power On");
+	gpio_direction_output(SHOLEST_BP_PWRON_GPIO, 0);
+	omap_cfg_reg(AH3_34XX_GPIO137_OUT);
+
+	gpio_request(SHOLEST_AP_TO_BP_PSHOLD_GPIO, "AP to BP PS Hold");
+	gpio_direction_output(SHOLEST_AP_TO_BP_PSHOLD_GPIO, 0);
+	omap_cfg_reg(AF3_34XX_GPIO138_OUT);
+
+	return platform_device_register(&omap_mdm_ctrl_platform_device);
+}
+
+static struct omap_vout_config sholest_vout_platform_data = {
+	.max_width = 1280,
+	.max_height = 720,
+	.max_buffer_size = 0x1C3000,
+	.num_buffers = 8,
+	.num_devices = 2,
+	.device_ids = {1, 2},
+};
+
+static struct platform_device sholest_vout_device = {
+	.name = "omapvout",
+	.id = -1,
+	.dev = {
+		.platform_data = &sholest_vout_platform_data,
+	},
+};
+static void __init sholest_vout_init(void)
+{
+	platform_device_register(&sholest_vout_device);
+}
+
+#ifdef CONFIG_ANDROID_RAM_CONSOLE
+#define RAM_CONSOLE_START   0x8E000000
+#define RAM_CONSOLE_SIZE    0x20000
+static struct resource ram_console_resource = {
+       .start  = RAM_CONSOLE_START,
+       .end    = (RAM_CONSOLE_START + RAM_CONSOLE_SIZE - 1),
+       .flags  = IORESOURCE_MEM,
+};
+
+static struct platform_device ram_console_device = {
+       .name = "ram_console",
+       .id = 0,
+       .num_resources  = 1,
+       .resource       = &ram_console_resource,
+};
+
+static inline void sholest_ramconsole_init(void)
+{
+	platform_device_register(&ram_console_device);
+}
+
+static inline void omap2_ramconsole_reserve_sdram(void)
+{
+	reserve_bootmem(RAM_CONSOLE_START, RAM_CONSOLE_SIZE, 0);
+}
+#else
+static inline void sholest_ramconsole_init(void) {}
+
+static inline void omap2_ramconsole_reserve_sdram(void) {}
+#endif
+
+
+static struct platform_device sholest_sgx_device = {
+       .name                   = "pvrsrvkm",
+       .id             = -1,
+};
+static struct platform_device sholest_omaplfb_device = {
+	.name			= "omaplfb",
+	.id			= -1,
+};
+
+
+static void __init sholest_sgx_init(void)
+{
+	platform_device_register(&sholest_sgx_device);
+	platform_device_register(&sholest_omaplfb_device);
+}
+
+static void __init sholest_bp_model_init(void)
+{
+#ifdef CONFIG_OMAP_RESET_CLOCKS
+	struct clk *clkp;
+#endif
+
+#ifdef CONFIG_ARM_OF
+	struct device_node *bp_node;
+	const void *bp_prop;
+
+	if ((bp_node = of_find_node_by_path(DT_PATH_CHOSEN))) {
+		if ((bp_prop = of_get_property(bp_node, \
+			DT_PROP_CHOSEN_BP, NULL)))
+			bp_model = (char *)bp_prop;
+
+		of_node_put(bp_node);
+	}
+#endif
+#ifdef CONFIG_OMAP_RESET_CLOCKS
+	/* Enable sad2d iclk */
+	clkp = clk_get(NULL, "sad2d_ick");
+	if (clkp)
+		clk_enable(clkp);
+#endif
+}
+
+static void sholest_pm_power_off(void)
+{
+	printk(KERN_INFO "sholest_pm_power_off start...\n");
+	local_irq_disable();
+
+	/* config gpio 176 back from safe mode to reset the device */
+	omap_writew(0x4, 0x480021D2);
+	gpio_direction_output(SHOLEST_POWER_OFF_GPIO, 0);
+
+	do {} while (1);
+
+	local_irq_enable();
+}
+
+static void sholest_pm_reset(void)
+{
+	arch_reset('h');
+}
+
+static int cpcap_charger_connected_probe(struct platform_device *pdev)
+{
+	pm_power_off = sholest_pm_reset;
+	return 0;
+}
+
+static int cpcap_charger_connected_remove(struct platform_device *pdev)
+{
+	pm_power_off = sholest_pm_power_off;
+	return 0;
+}
+
+static struct platform_driver cpcap_charger_connected_driver = {
+	.probe		= cpcap_charger_connected_probe,
+	.remove		= cpcap_charger_connected_remove,
+	.driver		= {
+		.name	= "cpcap_charger_connected",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static void __init sholest_power_off_init(void)
+{
+	gpio_request(SHOLEST_POWER_OFF_GPIO, "mapphone power off");
+	gpio_direction_output(SHOLEST_POWER_OFF_GPIO, 1);
+	omap_cfg_reg(AB1_34XX_GPIO176_OUT);
+
+	/* config gpio176 into safe mode with the pull up enabled to avoid
+	 * glitch at reboot */
+	omap_writew(0x1F, 0x480021D2);
+	pm_power_off = sholest_pm_power_off;
+
+	platform_driver_register(&cpcap_charger_connected_driver);
+}
+
+#if defined(CONFIG_VIDEO_MIPI_DLI_TEST)
+static struct platform_device sholest_mipi_dli_device = {
+	.name = "mipi_dli_tester",
+	.id = -1,
+};
+static void __init sholest_mipi_dli_init(void)
+{
+	platform_device_register(&sholest_mipi_dli_device);
+}
+#endif
+
+static void __init sholest_init(void)
+{
+	int ret = 0;
+	struct kobject *properties_kobj = NULL;
+
+	prm_write_mod_reg(0xff, CORE_MOD, OMAP3430_PM_PREPWSTST);
+	omap_board_config = sholest_config;
+	omap_board_config_size = ARRAY_SIZE(sholest_config);
+
+	properties_kobj = kobject_create_and_add("board_properties", NULL);
+	if (properties_kobj)
+		ret = sysfs_create_group(properties_kobj,
+				 &sholest_properties_attr_group);
+	if (!properties_kobj || ret)
+		pr_err("failed to create board_properties\n");
+
+	sholest_bp_model_init();
+	sholest_padconf_init();
+	sholest_gpio_mapping_init();
+	sholest_ramconsole_init();
+	sholest_omap_mdm_ctrl_init();
+	sholest_spi_init();
+	sholest_flash_init();
+	sholest_serial_init();
+	sholest_als_init();
+	sholest_panel_init();
+	sholest_sensors_init();
+	sholest_camera_init();
+	sholest_touch_init();
+	sholest_audio_init();
+	usb_musb_init();
+	sholest_ehci_init();
+	sholest_sdrc_init();
+	sholest_pm_init();
+	config_mmc2_init();
+	config_wlan_gpio();
+	omap_hdq_init();
+	sholest_bt_init();
+#if SHOLEST_MMCPROBE_ENABLED
+	sholest_mmcprobe_init();
+#else
+	sholest_hsmmc_init();
+#endif
+	sholest_vout_init();
+	sholest_sgx_init();
+	sholest_power_off_init();
+	sholest_gadget_init();
+#if defined(CONFIG_VIDEO_MIPI_DLI_TEST)
+	sholest_mipi_dli_init();
+#endif
+#ifdef CONFIG_MEM_DUMP
+    reset_proc_init();
+#endif
+}
+
+static void __init sholest_map_io(void)
+{
+	omap2_ramconsole_reserve_sdram();
+	omap2_set_globals_343x();
+	omap2_map_common_io();
+}
+
+MACHINE_START(MAPPHONE, "mapphone_")
+	/* Maintainer: Motorola, Inc. */
+	.phys_io	= 0x48000000,
+	.io_pg_offst	= ((0xd8000000) >> 18) & 0xfffc,
+	.boot_params	= 0x80C00100,
+	.map_io		= sholest_map_io,
+	.init_irq	= sholest_init_irq,
+	.init_machine	= sholest_init,
+	.timer		= &omap_timer,
+MACHINE_END
diff --git a/arch/arm/mach-omap2/mux.c b/arch/arm/mach-omap2/mux.c
index 7b01036..2c901f7 100644
--- a/arch/arm/mach-omap2/mux.c
+++ b/arch/arm/mach-omap2/mux.c
@@ -702,10 +702,12 @@ MUX_CFG_34XX("C27_34XX_CAM_PCLK", 0x112,
 		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_INPUT_PULLUP)
 MUX_CFG_34XX("C23_34XX_CAM_FLD", 0x114,
 		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_OUTPUT)
+#if !defined(CONFIG_VIDEO_MIPI_INTERFACE)
 MUX_CFG_34XX("AG17_34XX_CAM_D0", 0x116,
 		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_INPUT_PULLUP)
 MUX_CFG_34XX("AH17_34XX_CAM_D1", 0x118,
 		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_INPUT)
+#endif
 MUX_CFG_34XX("B24_34XX_CAM_D2", 0x11A,
 		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_INPUT)
 MUX_CFG_34XX("C24_34XX_CAM_D3", 0x11C,
@@ -732,8 +734,72 @@ MUX_CFG_34XX("B23_34XX_CAM_WEN", 0x130,
 		OMAP34XX_MUX_MODE2)
 MUX_CFG_34XX("D25_34XX_CAM_STROBE", 0x132,
 		OMAP34XX_MUX_MODE0)
-MUX_CFG_34XX("K8_34XX_GPMC_WAIT2", 0x0D0,
+MUX_CFG_34XX("K8_34XX_GPMC_WAIT2", 0x0D2,
+		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_OUTPUT)
+MUX_CFG_34XX("H2_34XX_GPMC_A3", 0x07E,
+		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_OUTPUT)
+
+/* MDTV off state */
+MUX_CFG_34XX("F1_34XX_MDTV_INT_OFF", 0x082,
+		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_INPUT)
+MUX_CFG_34XX("AC3_34XX_MDTV_SIMO_OFF", 0x5DC,
+		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_INPUT)
+MUX_CFG_34XX("AD4_34XX_MDTV_SOMI_OFF", 0x5DE,
+		OMAP34XX_MUX_MODE1 | OMAP34XX_PIN_INPUT)
+MUX_CFG_34XX("AD3_34XX_MDTV_CS_OFF", 0x5E0,
+		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_INPUT)
+MUX_CFG_34XX("AA3_34XX_MDTV_CLK_OFF", 0x5E2,
+		OMAP34XX_MUX_MODE1 | OMAP34XX_PIN_INPUT)
+/* MDTV on state */
+MUX_CFG_34XX("F1_34XX_MDTV_INT_ON", 0x082,
+		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_INPUT_PULLUP)
+MUX_CFG_34XX("AC3_34XX_MDTV_SIMO_ON", 0x5DC,
+		OMAP34XX_MUX_MODE1 | OMAP34XX_PIN_OUTPUT)
+MUX_CFG_34XX("AD4_34XX_MDTV_SOMI_ON", 0x5DE,
+		OMAP34XX_MUX_MODE1 | OMAP34XX_PIN_INPUT_PULLUP)
+MUX_CFG_34XX("AD3_34XX_MDTV_CS_ON", 0x5E0,
+		OMAP34XX_MUX_MODE1 | OMAP34XX_PIN_OUTPUT)
+MUX_CFG_34XX("AA3_34XX_MDTV_CLK_ON", 0x5E2,
+		OMAP34XX_MUX_MODE1 | OMAP34XX_PIN_INPUT_PULLUP)
+/* DSS */
+#ifdef CONFIG_PANEL_HDTV
+MUX_CFG_34XX("AG22_34XX_DSS_DATA0", 0xdc, 
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_OUTPUT)
+MUX_CFG_34XX("AH22_34XX_DSS_DATA1", 0xde, 
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_OUTPUT)
+MUX_CFG_34XX("AG23_34XX_DSS_DATA2", 0xe0, 
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_OUTPUT)
+MUX_CFG_34XX("AH23_34XX_DSS_DATA3", 0xe2, 
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_OUTPUT)
+MUX_CFG_34XX("AG24_34XX_DSS_DATA4", 0xe4, 
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_OUTPUT)
+MUX_CFG_34XX("AH24_34XX_DSS_DATA5", 0xe6, 
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_OUTPUT)
+#endif
+
+/* Touch IC state */
+MUX_CFG_34XX("D25_34XX_GPIO109", 0x12a,
+		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_INPUT)
+/* Linear Vib. En state */
+#ifdef CONFIG_VIB_PWM
+MUX_CFG_34XX("AF22_34XX_GPIO9_OUT", 0xa18,
 		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_OUTPUT)
+#endif
+#if defined(CONFIG_VIDEO_MIPI_INTERFACE)
+	/*MIPI Camra*/
+MUX_CFG_34XX("AG17_34XX_CAM_D0", 0x116,
+		OMAP34XX_MUX_MODE2 | OMAP34XX_PIN_INPUT)
+MUX_CFG_34XX("AH17_34XX_CAM_D1", 0x118,
+		OMAP34XX_MUX_MODE2 | OMAP34XX_PIN_INPUT)
+MUX_CFG_34XX("AD17_34XX_CSI2_DX0", 0x134,
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_INPUT)
+MUX_CFG_34XX("AE18_34XX_CSI2_DY0", 0x136,
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_INPUT)
+MUX_CFG_34XX("AD16_34XX_CSI2_DX1", 0x138,
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_INPUT)
+MUX_CFG_34XX("AE17_34XX_CSI2_DY1", 0x13A,
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_INPUT)
+#endif/*CONFIG_VIDEO_MIPI_INTERFACE*/
 };
 
 #define OMAP34XX_PINS_SZ	ARRAY_SIZE(omap34xx_pins)
diff --git a/arch/arm/mach-omap2/serial.c b/arch/arm/mach-omap2/serial.c
old mode 100755
new mode 100644
diff --git a/arch/arm/plat-omap/dma.c b/arch/arm/plat-omap/dma.c
old mode 100755
new mode 100644
index cd53b28..e9eb2d9
--- a/arch/arm/plat-omap/dma.c
+++ b/arch/arm/plat-omap/dma.c
@@ -673,13 +673,16 @@ static inline void disable_lnk(int lch)
 static inline void omap2_enable_irq_lch(int lch)
 {
 	u32 val;
+	unsigned long flags;
 
 	if (!cpu_class_is_omap2())
 		return;
 
+	spin_lock_irqsave(&dma_chan_lock, flags);
 	val = dma_read(IRQENABLE_L0);
 	val |= 1 << lch;
 	dma_write(val, IRQENABLE_L0);
+	spin_unlock_irqrestore(&dma_chan_lock, flags);
 }
 
 int omap_request_dma(int dev_id, const char *dev_name,
@@ -749,11 +752,13 @@ int omap_request_dma(int dev_id, const char *dev_name,
 	}
 
 	if (cpu_class_is_omap2()) {
+		spin_lock_irqsave(&dma_chan_lock, flags);
 		omap2_enable_irq_lch(free_ch);
 		omap_enable_channel_irq(free_ch);
 		/* Clear the CSR register and IRQ status register */
 		dma_write(OMAP2_DMA_CSR_CLEAR_MASK, CSR(free_ch));
 		dma_write(1 << free_ch, IRQSTATUS_L0);
+		spin_unlock_irqrestore(&dma_chan_lock, flags);
 	}
 
 	*dma_ch_out = free_ch;
@@ -788,10 +793,12 @@ void omap_free_dma(int lch)
 
 	if (cpu_class_is_omap2()) {
 		u32 val;
+		spin_lock_irqsave(&dma_chan_lock, flags);
 		/* Disable interrupts */
 		val = dma_read(IRQENABLE_L0);
 		val &= ~(1 << lch);
 		dma_write(val, IRQENABLE_L0);
+		spin_unlock_irqrestore(&dma_chan_lock, flags);
 
 		/* Clear the CSR register and IRQ status register */
 		dma_write(OMAP2_DMA_CSR_CLEAR_MASK, CSR(lch));
diff --git a/arch/arm/plat-omap/include/dspbridge/dbdefs.h b/arch/arm/plat-omap/include/dspbridge/dbdefs.h
index 78be880..9b7b2aa 100644
--- a/arch/arm/plat-omap/include/dspbridge/dbdefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/dbdefs.h
@@ -305,6 +305,7 @@
 		PROC_INVALIDATE_MEM = 0,
 		PROC_WRITEBACK_MEM,
 		PROC_WRITEBACK_INVALIDATE_MEM,
+		PROC_WRBK_INV_ALL,
 	} ;
 
 /* Memory Segment Status Values */
diff --git a/arch/arm/plat-omap/include/dspbridge/mem.h b/arch/arm/plat-omap/include/dspbridge/mem.h
index 535ac3a..8d598f4 100644
--- a/arch/arm/plat-omap/include/dspbridge/mem.h
+++ b/arch/arm/plat-omap/include/dspbridge/mem.h
@@ -185,7 +185,7 @@
  *  Ensures:
  *      Cache is synchronized
  */
-	extern void MEM_FlushCache(void *pMemBuf, u32 cBytes, s32 FlushType);
+	extern void MEM_FlushCache(void *pMemBuf, u32 cBytes, u32 FlushType);
 
 /*
  *  ======== MEM_Free ========
diff --git a/arch/arm/plat-omap/include/mach/board-mapphone.h b/arch/arm/plat-omap/include/mach/board-mapphone.h
index 2a24113..08ffba0 100644
--- a/arch/arm/plat-omap/include/mach/board-mapphone.h
+++ b/arch/arm/plat-omap/include/mach/board-mapphone.h
@@ -50,6 +50,9 @@ extern void __init mapphone_mmcprobe_init(void);
 #if defined(CONFIG_VIDEO_MT9P012) || defined(CONFIG_VIDEO_MT9P012_MODULE)
 extern struct mt9p012_platform_data mapphone_mt9p012_platform_data;
 #endif
+#if defined(CONFIG_VIDEO_OV8810)
+extern struct ov8810_platform_data mapphone_ov8810_platform_data;
+#endif
 #ifdef CONFIG_VIDEO_OMAP3_HPLENS
 extern struct hplens_platform_data mapphone_hplens_platform_data;
 #endif
diff --git a/arch/arm/plat-omap/include/mach/board-sholest-padconf.h b/arch/arm/plat-omap/include/mach/board-sholest-padconf.h
new file mode 100644
index 0000000..e54285f
--- /dev/null
+++ b/arch/arm/plat-omap/include/mach/board-sholest-padconf.h
@@ -0,0 +1,135 @@
+
+/*
+ * board-sholest-padconf.h
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __BOARD_SHOLEST_PADCONF_H
+#define __BOARD_SHOLEST_PADCONF_H
+
+/* core control module padconf registers are at 0x48002030 - 0x480021E2 */
+#define OMAP343X_PADCONF_CORE_CTRL_BASE (OMAP343X_CTRL_BASE + 0x030)
+#define OMAP343X_PADCONF_CORE_CTRL_TOP  (OMAP343X_CTRL_BASE + 0x1E2)
+
+/* etk padconf registers are at 0x480025D8 - 0x480025FA */
+#define OMAP343X_PADCONF_CORE_ETK_BASE  (OMAP343X_CTRL_BASE + 0x5D8)
+#define OMAP343X_PADCONF_CORE_ETK_TOP   (OMAP343X_CTRL_BASE + 0x5FA)
+
+/* d2d padconf registers are at 0x480021E4 - 0x48002264 */
+#define OMAP343X_PADCONF_CORE_D2D_BASE  (OMAP343X_CTRL_BASE + 0x1E4)
+#define OMAP343X_PADCONF_CORE_D2D_TOP   (OMAP343X_CTRL_BASE + 0x264)
+
+/* wakeup module padconf registers are at 0x48002A00 - 0x48002A26 */
+#define OMAP343X_PADCONF_WKUP_BASE  (OMAP343X_CTRL_BASE + 0xA00)
+#define OMAP343X_PADCONF_WKUP_TOP   (OMAP343X_CTRL_BASE + 0xA26)
+
+/* d2d wakeup module padconf registers are at 0x48002A4C - 0x48002A50 */
+#define OMAP343X_PADCONF_WKUP_D2D_BASE  (OMAP343X_CTRL_BASE + 0xA4C)
+#define OMAP343X_PADCONF_WKUP_D2D_TOP   (OMAP343X_CTRL_BASE + 0xA50)
+
+#define OMAP343X_PADCONF_OFF_WAKEUP_ENABLED (1 << 14)
+
+#define OMAP343X_PADCONF_OFF_PULL_UP	    (1 << 13)
+#define OMAP343X_PADCONF_OFF_PULL_DOWN	    (0 << 13)
+
+#define OMAP343X_PADCONF_OFF_PUD_ENABLED    (1 << 12)
+#define OMAP343X_PADCONF_OFF_PUD_DISABLED   (0 << 12)
+
+#define OMAP343X_PADCONF_OFF_OUTPUT_HIGH    (1 << 11)
+#define OMAP343X_PADCONF_OFF_OUTPUT_LOW	    (0 << 11)
+
+#define OMAP343X_PADCONF_OFF_OUTPUT_ENABLED (1 << 10)
+#define OMAP343X_PADCONF_OFF_OUTPUT_DISABLED	(0 << 10)
+
+#define OMAP343X_PADCONF_OFFMODE_ENABLED    (1 << 9)
+#define OMAP343X_PADCONF_OFFMODE_DISABLED   (0 << 9)
+
+#define OMAP343X_PADCONF_INPUT_ENABLED	    (1 << 8)
+
+#define OMAP343X_PADCONF_PULL_UP	    (1 << 4)
+#define OMAP343X_PADCONF_PULL_DOWN	    (0 << 4)
+
+#define OMAP343X_PADCONF_PUD_ENABLED	    (1 << 3)
+#define OMAP343X_PADCONF_PUD_DISABLED	    (0 << 3)
+
+#define OMAP343X_PADCONF_MUXMODE0   (0x00)
+#define OMAP343X_PADCONF_MUXMODE1   (0x01)
+#define OMAP343X_PADCONF_MUXMODE2   (0x02)
+#define OMAP343X_PADCONF_MUXMODE3   (0x03)
+#define OMAP343X_PADCONF_MUXMODE4   (0x04)
+#define OMAP343X_PADCONF_MUXMODE5   (0x05)
+#define OMAP343X_PADCONF_MUXMODE6   (0x06)
+#define OMAP343X_PADCONF_MUXMODE7   (0x07)
+
+#define OMAP343X_PADCONF_SETTING_MASK (OMAP343X_PADCONF_OFF_WAKEUP_ENABLED | \
+		OMAP343X_PADCONF_OFF_PULL_UP | \
+		OMAP343X_PADCONF_OFF_PUD_ENABLED | \
+		OMAP343X_PADCONF_OFF_OUTPUT_HIGH | \
+		OMAP343X_PADCONF_OFF_OUTPUT_ENABLED | \
+		OMAP343X_PADCONF_OFFMODE_ENABLED | \
+		OMAP343X_PADCONF_INPUT_ENABLED | \
+		OMAP343X_PADCONF_PULL_UP | \
+		OMAP343X_PADCONF_PUD_ENABLED | \
+		OMAP343X_PADCONF_MUXMODE7)
+
+
+#ifdef CONFIG_ARM_OF
+#define OMAP343X_PAD_MASK (OMAP343X_PADCONF_MUXMODE7 | \
+		OMAP343X_PADCONF_INPUT_ENABLED | \
+		OMAP343X_PADCONF_PUD_ENABLED | \
+		OMAP343X_PADCONF_PULL_UP)
+
+#define OMAP343X_OFFMODE_MASK (OMAP343X_PADCONF_OFFMODE_ENABLED | \
+		OMAP343X_PADCONF_OFF_OUTPUT_ENABLED | \
+		OMAP343X_PADCONF_OFF_OUTPUT_HIGH | \
+		OMAP343X_PADCONF_OFF_PUD_ENABLED | \
+		OMAP343X_PADCONF_OFF_PULL_UP | \
+		OMAP343X_PADCONF_OFF_WAKEUP_ENABLED)
+
+#define MAKE_OMAP343X_PAD_VALUE(mode, input_en, pull) \
+		(((u16) mode) | ((u16) input_en) << 8 | ((u16) pull) << 3)
+
+#define MAKE_OMAP343X_OFFMODE_VALUE(offmode, offout, offpull, offwkup) \
+		(((u16) (offmode) << 9) | ((u16) (offout) << 10) | \
+		((u16) (offpull) << 12) | ((u16) (offwkup) << 14))
+
+struct dt_operation {
+	const char *path;
+	const char *prop;
+	u32 prop_unit_size;
+	void (*callback) (const void *p_data);
+	u32 name_size;
+} __attribute__ ((__packed__));
+
+struct mux_conf_entry {
+	u16 offset;
+	u8 mode;
+	u8 input_en;
+	u8 pull_type;
+} __attribute__ ((__packed__));
+
+struct mux_offmode_conf_entry {
+	u16 offset;
+	u8 offmode_en;
+	u8 offout_type;
+	u8 offpull_type;
+	u8 offwkup_en;
+} __attribute__ ((__packed__));
+#endif
+
+#endif
diff --git a/arch/arm/plat-omap/include/mach/board-sholest.h b/arch/arm/plat-omap/include/mach/board-sholest.h
new file mode 100644
index 0000000..1796f78
--- /dev/null
+++ b/arch/arm/plat-omap/include/mach/board-sholest.h
@@ -0,0 +1,73 @@
+/*
+ * linux/include/asm-arm/arch-omap/board-sholest.h
+ *
+ * Hardware definitions for OMAP3430-based Motorola reference design.
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * Derived from include/asm-arm/arch-omap/board-3430sdp.h
+ * Initial creation by Syed Mohammed Khasim
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __ASM_ARCH_OMAP_SHOLEST_H
+#define __ASM_ARCH_OMAP_SHOLEST_H
+
+#include <linux/init.h>
+#include "board-sholest-padconf.h"
+
+extern void __init sholest_usb_init(void);
+extern void __init sholest_flash_init(void);
+extern void __init sholest_panel_init(void);
+extern void __init sholest_sensors_init(void);
+extern void __init sholest_spi_init(void);
+extern void __init sholest_flash_init(void);
+extern void __init sholest_padconf_init(void);
+extern void __init sholest_hsmmc_init(void);
+extern void __init sholest_gpio_mapping_init(void);
+extern void __init sholest_camera_init(void);
+extern void __init sholest_mmcprobe_init(void);
+
+#if defined(CONFIG_VIDEO_MT9P012) || defined(CONFIG_VIDEO_MT9P012_MODULE)
+extern struct mt9p012_platform_data sholest_mt9p012_platform_data;
+#endif
+#if defined(CONFIG_VIDEO_OV8810)
+extern struct ov8810_platform_data sholest_ov8810_platform_data;
+#endif
+#ifdef CONFIG_VIDEO_OMAP3_HPLENS
+extern struct hplens_platform_data sholest_hplens_platform_data;
+#endif
+
+#define GPIO_CAMERA_RESET   98
+#define GPIO_SILENCE_KEY    110
+#if defined(CONFIG_VIDEO_OV8810)
+#define GPIO_OV8810_RESET	98
+#define GPIO_OV8810_STANDBY	64
+#endif
+
+#define OMAP_MCAM_SRC_CLK		864000000
+#define OMAP_MCAM_SRC_DIV		4
+
+#define is_cdma_phone() (!strcmp("CDMA", bp_model))
+extern char *bp_model;
+
+#endif /*  __ASM_ARCH_OMAP_SHOLEST_H */
diff --git a/arch/arm/plat-omap/include/mach/dma.h b/arch/arm/plat-omap/include/mach/dma.h
old mode 100755
new mode 100644
diff --git a/arch/arm/plat-omap/include/mach/dt_path.h b/arch/arm/plat-omap/include/mach/dt_path.h
index cb7da66..1acc4da 100644
--- a/arch/arm/plat-omap/include/mach/dt_path.h
+++ b/arch/arm/plat-omap/include/mach/dt_path.h
@@ -59,6 +59,39 @@
 /* Touch Node */
 #define DT_PATH_TOUCH		"/System@0/I2C@0/TouchOBP@0"
 #define DT_PROP_TOUCH_KEYMAP	"touch_key_map"
+#define DT_PROP_TOUCH_I2C_ADDRESS       "i2c,address"
+#define DT_PROP_TOUCH_KEYMAP		"touch_key_map"
+#define DT_PROP_TOUCH_NUM_TOUCH_KEYS	"number_of_touch_keys"
+#define DT_PROP_TOUCH_FLAGS		"touchobp-flags"
+#define DT_PROP_TOUCH_ABS_MIN_X		"abs_min_x"
+#define DT_PROP_TOUCH_ABS_MAX_X		"abs_max_x"
+#define DT_PROP_TOUCH_ABS_MIN_Y		"abs_min_y"
+#define DT_PROP_TOUCH_ABS_MAX_Y		"abs_max_y"
+#define DT_PROP_TOUCH_ABS_MIN_P		"abs_min_p"
+#define DT_PROP_TOUCH_ABS_MAX_P		"abs_max_p"
+#define DT_PROP_TOUCH_ABS_MIN_W		"abs_min_w"
+#define DT_PROP_TOUCH_ABS_MAX_W		"abs_max_w"
+#define DT_PROP_TOUCH_FUZZ_X		"fuzz_x"
+#define DT_PROP_TOUCH_FUZZ_Y		"fuzz_y"
+#define DT_PROP_TOUCH_FUZZ_P		"fuzz_p"
+#define DT_PROP_TOUCH_FUZZ_W		"fuzz_w"
+#define DT_PROP_TOUCH_KEY_ARRAY_MAP	"key_array_map"
+#define DT_PROP_TOUCH_KEY_ARRAY_COUNT	"key_array_count"
+#define DT_PROP_TOUCH_T7		"obj_t7"	/* power_cfg */
+#define DT_PROP_TOUCH_T8		"obj_t8"	/* acquire_cfg */
+#define DT_PROP_TOUCH_T9		"obj_t9"	/* multi_touch_cfg */
+#define DT_PROP_TOUCH_T15		"obj_t15"	/* key_array */
+#define DT_PROP_TOUCH_T17		"obj_t17"	/* linear_tbl_cfg */
+#define DT_PROP_TOUCH_T19		"obj_t19"	/* gpio_pwm_cfg */
+#define DT_PROP_TOUCH_T20		"obj_t20"	/* grip_suppression_cfg */
+#define DT_PROP_TOUCH_T22		"obj_t22"	/* noise_suppression_cfg */
+#define DT_PROP_TOUCH_T24		"obj_t24"	/* one_touch_gesture_proc_cfg */
+#define DT_PROP_TOUCH_T25		"obj_t25"	/* self_test_cfg */
+#define DT_PROP_TOUCH_T27		"obj_t27"	/* two_touch_gesture_proc_cfg */
+#define DT_PROP_TOUCH_T28		"obj_t28"	/* cte_config_cfg */
+
+/* Accelerometer Node */
+#define DT_PATH_LIS331DLH	"/System@0/I2C@0/Accelerometer@0"
 
 /* GPIO Node */
 #define DT_PATH_GPIO        "/System@0/GPIO@0"
diff --git a/arch/arm/plat-omap/include/mach/hardware.h b/arch/arm/plat-omap/include/mach/hardware.h
index d55d28f..9a06f93 100644
--- a/arch/arm/plat-omap/include/mach/hardware.h
+++ b/arch/arm/plat-omap/include/mach/hardware.h
@@ -381,10 +381,15 @@
 #include "board-sx1.h"
 #endif
 
+#ifdef CONFIG_MACH_SHOLEST
+#include "board-sholest.h"
+#else /* !CONFIG_MACH_SHOLEST */
+
 #ifdef CONFIG_MACH_MAPPHONE
 #include "board-mapphone.h"
 #endif
 
+#endif
 #endif /* !__ASSEMBLER__ */
 
 #endif	/* __ASM_ARCH_OMAP_HARDWARE_H */
diff --git a/arch/arm/plat-omap/include/mach/mux.h b/arch/arm/plat-omap/include/mach/mux.h
index 98e0a00..3ecbb1a 100644
--- a/arch/arm/plat-omap/include/mach/mux.h
+++ b/arch/arm/plat-omap/include/mach/mux.h
@@ -923,8 +923,10 @@ enum omap34xx_index {
 	C25_34XX_CAM_XCLKA,
 	C27_34XX_CAM_PCLK,
 	C23_34XX_CAM_FLD,
+#ifndef CONFIG_VIDEO_MIPI_INTERFACE
 	AG17_34XX_CAM_D0,
 	AH17_34XX_CAM_D1,
+#endif
 	B24_34XX_CAM_D2,
 	C24_34XX_CAM_D3,
 	D24_34XX_CAM_D4,
@@ -939,7 +941,42 @@ enum omap34xx_index {
 	B23_34XX_CAM_WEN,
 	D25_34XX_CAM_STROBE,
 	K8_34XX_GPMC_WAIT2,
-
+	H2_34XX_GPMC_A3,
+
+	/* MDTV, INT&SPI */
+	F1_34XX_MDTV_INT_OFF,
+	AC3_34XX_MDTV_SIMO_OFF,
+	AD4_34XX_MDTV_SOMI_OFF,
+	AD3_34XX_MDTV_CS_OFF,
+	AA3_34XX_MDTV_CLK_OFF,
+	F1_34XX_MDTV_INT_ON,
+	AC3_34XX_MDTV_SIMO_ON,
+	AD4_34XX_MDTV_SOMI_ON,
+	AD3_34XX_MDTV_CS_ON,
+	AA3_34XX_MDTV_CLK_ON,
+
+	/* DSS */
+#ifdef CONFIG_PANEL_HDTV
+	AG22_34XX_DSS_DATA0,
+	AH22_34XX_DSS_DATA1,
+	AG23_34XX_DSS_DATA2,
+	AH23_34XX_DSS_DATA3,
+	AG24_34XX_DSS_DATA4,
+	AH24_34XX_DSS_DATA5,
+#endif
+	D25_34XX_GPIO109,
+#ifdef CONFIG_VIB_PWM
+	AF22_34XX_GPIO9_OUT,
+#endif
+#if defined(CONFIG_VIDEO_MIPI_INTERFACE)
+	/*MIPI Camra*/
+	AG17_34XX_CAM_D0,
+	AH17_34XX_CAM_D1,
+	AD17_34XX_CSI2_DX0,
+	AE18_34XX_CSI2_DY0,
+	AD16_34XX_CSI2_DX1,
+	AE17_34XX_CSI2_DY1,
+#endif/*CONFIG_VIDEO_MIPI_INTERFACE*/
 };
 
 struct omap_mux_cfg {
diff --git a/arch/arm/plat-omap/include/mach/oldisp_user.h b/arch/arm/plat-omap/include/mach/oldisp_user.h
index 510f324..18826b6 100644
--- a/arch/arm/plat-omap/include/mach/oldisp_user.h
+++ b/arch/arm/plat-omap/include/mach/oldisp_user.h
@@ -45,6 +45,13 @@
    _IOWR('V', BASE_VIDIOC_PRIVATE + 12, struct isprsz_coef)
 #define VIDIOC_PRIVATE_ISP_RSZ_CFG \
    _IOWR('V', BASE_VIDIOC_PRIVATE + 13, struct isprsz_coef)
+#define VIDIOC_PRIVATE_ISP_HARDPIPE_CLEAR \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 14, struct ispprv_run_hardpipe)
+#define VIDIOC_PRIVATE_ISP_CCDC_BAYER_CFG \
+   _IOWR('V', BASE_VIDIOC_PRIVATE + 15, struct ispccdc_color_offset)
+#define VIDIOC_PRIVATE_ISP_LSC_WORKAROUND_CFG \
+   _IOW('V', BASE_VIDIOC_PRIVATE + 16, int)
+
 
 /* AE/AWB related structures and flags*/
 
@@ -699,5 +706,8 @@ struct ispprv_run_hardpipe {
 	__u32 crop_height;
 };
 
+struct ispccdc_color_offset{
+	__u16 offsetcode;
+};
 
 #endif /* OMAP_ISP_USER_H */
diff --git a/drivers/dsp/bridge/rmgr/proc.c b/drivers/dsp/bridge/rmgr/proc.c
index cb574ec..47eafc3 100644
--- a/drivers/dsp/bridge/rmgr/proc.c
+++ b/drivers/dsp/bridge/rmgr/proc.c
@@ -745,7 +745,6 @@ DSP_STATUS PROC_FlushMemory(DSP_HPROCESSOR hProcessor, void *pMpuAddr,
 {
 	/* Keep STATUS here for future additions to this function */
 	DSP_STATUS status = DSP_SOK;
-	enum DSP_FLUSHTYPE FlushMemType = PROC_WRITEBACK_INVALIDATE_MEM;
 	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
 	DBC_Require(cRefs > 0);
 
@@ -756,7 +755,7 @@ DSP_STATUS PROC_FlushMemory(DSP_HPROCESSOR hProcessor, void *pMpuAddr,
 	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
 		/* Critical section */
 		(void)SYNC_EnterCS(hProcLock);
-		MEM_FlushCache(pMpuAddr, ulSize, FlushMemType);
+		MEM_FlushCache(pMpuAddr, ulSize, ulFlags);
 		(void)SYNC_LeaveCS(hProcLock);
 	} else {
 		status = DSP_EHANDLE;
@@ -1073,7 +1072,7 @@ DSP_STATUS PROC_Load(DSP_HPROCESSOR hProcessor, IN CONST s32 iArgc,
 	struct DCD_MANAGER *hDCDHandle;
 	struct DMM_OBJECT *hDmmMgr;
 	u32 dwExtEnd;
-	u32 uProcId;
+	u32 uProcId = 0;
 #ifdef DEBUG
 	BRD_STATUS uBrdState;
 #endif
diff --git a/drivers/dsp/bridge/services/mem.c b/drivers/dsp/bridge/services/mem.c
index 47ec09b..3b4dca5 100644
--- a/drivers/dsp/bridge/services/mem.c
+++ b/drivers/dsp/bridge/services/mem.c
@@ -478,7 +478,7 @@ void MEM_Exit(void)
  *  Purpose:
  *      Flush cache
  */
-void MEM_FlushCache(void *pMemBuf, u32 cBytes, s32 FlushType)
+void MEM_FlushCache(void *pMemBuf, u32 cBytes, u32 FlushType)
 {
 	DBC_Require(cRefs > 0);
 
@@ -501,6 +501,10 @@ void MEM_FlushCache(void *pMemBuf, u32 cBytes, s32 FlushType)
 		outer_flush_range(__pa((u32)pMemBuf), __pa((u32)pMemBuf +
 				  cBytes));
 	break;
+    /* Writeback and Invalidate all */
+	case PROC_WRBK_INV_ALL:
+		__cpuc_flush_kern_all();
+	break;
 	default:
 		GT_1trace(MEM_debugMask, GT_6CLASS, "MEM_FlushCache: invalid "
 			  "FlushMemType 0x%x\n", FlushType);
diff --git a/drivers/gpu/pvr/linkage.h b/drivers/gpu/pvr/linkage.h
old mode 100755
new mode 100644
diff --git a/drivers/gpu/pvr/lists.c b/drivers/gpu/pvr/lists.c
old mode 100755
new mode 100644
diff --git a/drivers/gpu/pvr/lists.h b/drivers/gpu/pvr/lists.h
old mode 100755
new mode 100644
diff --git a/drivers/gpu/pvr/lock.h b/drivers/gpu/pvr/lock.h
old mode 100755
new mode 100644
diff --git a/drivers/gpu/pvr/mem_debug.c b/drivers/gpu/pvr/mem_debug.c
old mode 100755
new mode 100644
diff --git a/drivers/gpu/pvr/omap3430/sysutils_linux.c b/drivers/gpu/pvr/omap3430/sysutils_linux.c
index dfa478b..2266e89 100644
--- a/drivers/gpu/pvr/omap3430/sysutils_linux.c
+++ b/drivers/gpu/pvr/omap3430/sysutils_linux.c
@@ -238,6 +238,8 @@ IMG_VOID DisableSGXClocks(SYS_DATA *psSysData)
 		return;
 	}
 
+	/* unpin the memory bus */
+	omap_pm_set_min_bus_tput(&gpsPVRLDMDev->dev, OCP_INITIATOR_AGENT, 0);
 
 	PVR_DPF((PVR_DBG_MESSAGE, "DisableSGXClocks: Disabling SGX Clocks"));
 
diff --git a/drivers/gpu/pvr/omaplfb/omaplfb.h b/drivers/gpu/pvr/omaplfb/omaplfb.h
old mode 100755
new mode 100644
diff --git a/drivers/gpu/pvr/omaplfb/omaplfb_displayclass.c b/drivers/gpu/pvr/omaplfb/omaplfb_displayclass.c
old mode 100755
new mode 100644
diff --git a/drivers/gpu/pvr/omaplfb/omaplfb_linux.c b/drivers/gpu/pvr/omaplfb/omaplfb_linux.c
old mode 100755
new mode 100644
diff --git a/drivers/gpu/pvr/pdump_osfunc.h b/drivers/gpu/pvr/pdump_osfunc.h
old mode 100755
new mode 100644
diff --git a/drivers/gpu/pvr/sgx_mkif_km.h b/drivers/gpu/pvr/sgx_mkif_km.h
old mode 100755
new mode 100644
diff --git a/drivers/i2c/chips/Kconfig b/drivers/i2c/chips/Kconfig
index e1ad67a..a225c50 100644
--- a/drivers/i2c/chips/Kconfig
+++ b/drivers/i2c/chips/Kconfig
@@ -158,4 +158,12 @@ config SENSORS_PCA963X
 	 This driver can also be built as a module.  If so, the module
 	 will be called pca963X.
 
+##w21558, LP3907 regulator feature
+config MOT_FEAT_LP3907
+	tristate "LP3907 Voltage Regulator chip"
+	depends on I2C
+	help
+	  If you say yes or m here you get support for the National Semiconductor
+	  LP3907 Regulator driver.
+
 endmenu
diff --git a/drivers/i2c/chips/Makefile b/drivers/i2c/chips/Makefile
index c4877d9..05fff0e 100644
--- a/drivers/i2c/chips/Makefile
+++ b/drivers/i2c/chips/Makefile
@@ -21,7 +21,8 @@ obj-$(CONFIG_SENSORS_TSL2550)	+= tsl2550.o
 obj-$(CONFIG_TWL4030_POWEROFF)	+= twl4030-poweroff.o
 obj-$(CONFIG_TWL4030_MADC)	+= twl4030-madc.o
 obj-$(CONFIG_RTC_X1205_I2C)	+= x1205.o
-
+#w21558, Add LP3907 module
+obj-$(CONFIG_MOT_FEAT_LP3907)  += lp3907_i2c.o
 ifeq ($(CONFIG_I2C_DEBUG_CHIP),y)
 EXTRA_CFLAGS += -DDEBUG
 endif
diff --git a/drivers/i2c/chips/lp3907_i2c.c b/drivers/i2c/chips/lp3907_i2c.c
new file mode 100644
index 0000000..99e2f36
--- /dev/null
+++ b/drivers/i2c/chips/lp3907_i2c.c
@@ -0,0 +1,529 @@
+/*
+ * drivers/i2c/chips/lp3907_i2c.c
+ *
+ * I2C slave driver for LP3907 device
+ *
+ * Copyright (C) 2008-2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Revision History:
+ *
+ * Date          Author    Comment
+ * -----------   --------  -------------------
+ * Jun-16-2008   Motorola  Initial version
+ * Jan-04-2009   Motorola  Deleted atmega init irq
+ */
+
+/* enable/disable printk message */
+/*#define DEBUG*/
+#undef DEBUG
+
+#include <linux/kernel.h>	/* printk() */
+#include <linux/fs.h>		/* everything... */
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/cdev.h>
+#include <asm/gpio.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+
+#include "linux/i2c/lp3907_i2c.h"
+
+#define LP3907_REG_ADDR_LEN    (1)    /* 1 BYTE */
+#define I2C_RETRIES		5
+#define I2C_RETRY_DELAY		5
+
+/* LP3907 control register map */
+
+/* LP3907 POWER STATUS */
+#define LP3907_INIT_STATUS	0
+#define LP3907_PWRUP_STATUS	1
+#define LP3907_PWRDOWN_STATUS 	2
+
+typedef enum {
+	LP3907_ICRA_REG		= 0x02,
+	LP3907_SCR1_REG         = 0x07,
+	LP3907_BKLDOEN_REG      = 0x10,
+	LP3907_BKLDOSR_REG      = 0x11,
+	LP3907_VCCR_REG         = 0x20,
+	LP3907_B1TV1_REG        = 0x23,
+	LP3907_B1TV2_REG        = 0x24,
+	LP3907_B1RC_REG         = 0x25,
+	LP3907_B2TV1_REG        = 0x29,
+	LP3907_B2TV2_REG        = 0x2A,
+	LP3907_B2RC_REG         = 0x2B,
+	LP3907_BFCR_REG         = 0x38,
+	LP3907_LDO1VCR_REG      = 0x39,
+	LP3907_LDO2VCR_REG      = 0x3A,
+	LP3907_REG_MAX          = LP3907_LDO2VCR_REG,
+} LP3907_REG;
+
+#define LP3907_INVALID_REG      (LP3907_REG_MAX+1)
+
+typedef struct {
+	LP3907_REG reg;
+	u8	   data;
+} LP3907_cfg;
+/* */
+
+static LP3907_cfg lp3907_init_tbl[] = {
+	{LP3907_SCR1_REG,    0x28,},
+	{LP3907_BKLDOEN_REG, 0x74,},
+	{LP3907_VCCR_REG,    0x00,},
+	{LP3907_B2TV1_REG,   0x09,},  /* BUCK2 - 1.8V */
+	{LP3907_B2RC_REG,    0x28,},
+	{LP3907_BFCR_REG,    0x04,},
+	{LP3907_LDO1VCR_REG, 0x02,},  /* LDO1 - 1.2V */
+	{LP3907_LDO2VCR_REG, 0x08,},  /* LDO2 - 1.8V */
+
+	/* must end invalid register */
+	{LP3907_INVALID_REG, 0x00,},
+};
+
+static LP3907_cfg lp3907_pwr_off_tbl[] = {
+	{LP3907_BKLDOEN_REG, 0x70,},    /* BUCK1 disable */
+	{LP3907_BKLDOEN_REG, 0x60,},    /* LDO1EN disable */
+	{LP3907_BKLDOEN_REG, 0x20,},    /* LDO2EN disable */
+
+	/* must end invalid register */
+	{LP3907_INVALID_REG, 0x00,},
+};
+
+struct lp3907_data {
+	struct i2c_client *client;
+	struct lp3907_platform_data *pdata;
+
+	struct mutex lock; /* lock lp3907 */
+
+	int mode;
+	atomic_t enabled;
+};
+
+struct lp3907_data *g_lp3907_data;
+
+static struct i2c_driver lp3907_driver;
+static struct class *lp3907_class;
+static struct cdev lp3907_cdev;
+
+/* device major number */
+int lp3907_major_num = 240;
+int lp3907_minor_num;
+
+/* *****************************************************
+
+	Low level interface routine.
+
+* *****************************************************/
+
+/* write only 1 byte */
+static int lp3907_i2c_write(struct lp3907_data *pLP3907, u8 reg_addr, u8 value)
+{
+	struct i2c_msg msg;
+	u8 buf[sizeof(u8) + sizeof(u8)];
+	int ret = 0, try_cnt = 0;
+
+	buf[0] = reg_addr;
+	memcpy((void *)&buf[LP3907_REG_ADDR_LEN], (void *)&value, sizeof(u8));
+
+	msg.addr  = pLP3907->client->addr;
+	msg.flags = 0;   /* I2C_M_WR write the register value */
+	msg.buf   = buf;
+	msg.len   = sizeof(buf);
+
+	do {
+		/* one messages */
+		ret = i2c_transfer(pLP3907->client->adapter, &msg, 1);
+
+		if (ret != 1)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((ret != 1) && ((++try_cnt) < I2C_RETRIES));
+
+	if (ret != 1) {
+		dev_err(&pLP3907->client->dev, "[LP3907]write transfer error\n");
+		ret = -EIO;
+	} else
+		ret = 0;
+
+	return ret;
+}
+
+static int lp3907_i2c_read(struct lp3907_data *pLP3907, u8 reg_addr, u8 *buf)
+{
+	struct i2c_msg msg;
+	u8 value[sizeof(u8) + sizeof(u8)];
+	int ret = 0, try_cnt = 0;
+
+	value[0] = reg_addr;
+	memset((void *)&value[LP3907_REG_ADDR_LEN], 0, sizeof(u8));
+
+	/* */
+	msg.addr  = pLP3907->client->addr;
+	msg.flags = I2C_M_RD;
+	msg.buf   = buf;
+	msg.len = sizeof(u8);
+
+	do {
+		ret = i2c_transfer(pLP3907->client->adapter, &msg, 1);
+		if (ret != 1)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((ret != 1) && (++try_cnt < I2C_RETRIES));
+
+	if (ret != 1) {
+		dev_err(&pLP3907->client->dev, "[LP3907] read transfer error\n");
+		ret = -EIO;
+	} else {
+		memcpy((void *)buf, value + LP3907_REG_ADDR_LEN, sizeof(u8));
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static int lp3907_power_on_sequence(struct lp3907_data *pLP3907)
+{
+	int ret = 0;
+	int i = 0;
+	int line = 0;
+	u8 ldo_status = 0x00;
+
+	dev_info(&pLP3907->client->dev, "%s is called.\n", __func__);
+
+	/* 1. set voltage regulator level. */
+	for (; lp3907_init_tbl[i].reg != LP3907_INVALID_REG; i++) {
+		if (ret == 0) {
+			ret = lp3907_i2c_write(pLP3907, \
+					       lp3907_init_tbl[i].reg, \
+					       lp3907_init_tbl[i].data);
+			if (!ret) {
+				dev_info(&pLP3907->client->dev, "[LP3907]WR: reg = 0x%x, data = 0x%x\n",
+						lp3907_init_tbl[i].reg, lp3907_init_tbl[i].data);
+			}
+		} else {
+			dev_err(&pLP3907->client->dev, "lp3907_i2c_write(0x%x, 0x%x) is failed!\n",
+			       lp3907_init_tbl[i].reg, lp3907_init_tbl[i].data);
+			line = __LINE__;
+			goto lp3907_configure_exit;
+		}
+	}
+
+	/* MDTV_REG pin control */
+	if (pLP3907->pdata->power_on)
+		pLP3907->pdata->power_on();
+
+	/* 3. read status register */
+	ret = lp3907_i2c_read(pLP3907, LP3907_BKLDOSR_REG, &ldo_status);
+	if (!ret) {
+		dev_err(&pLP3907->client->dev, "LP3907 read status = %d\n", ldo_status);
+	}
+
+	return 0;
+
+lp3907_configure_exit:
+
+	dev_err(&pLP3907->client->dev, "LP3907-CONFIGURE: failed [%d] line=[%d]\n", ret, line);
+	return ret;
+}
+
+static int lp3907_power_off_sequence(struct lp3907_data *pLP3907)
+{
+	int i = 0;
+	int line = 0, ret = 0;
+
+	dev_info(&pLP3907->client->dev, "%s is called.\n", __func__);
+
+	/* MDTV_REG pin control */
+	if (pLP3907->pdata->power_off)
+		pLP3907->pdata->power_off();
+
+	/* LDO and BUCK disable */
+	for (; lp3907_pwr_off_tbl[i].reg != LP3907_INVALID_REG; i++) {
+		if (ret == 0) {
+			ret = lp3907_i2c_write(pLP3907, \
+					       lp3907_pwr_off_tbl[i].reg, \
+					       lp3907_pwr_off_tbl[i].data);
+			if (!ret) {
+				dev_info(&pLP3907->client->dev, "[LP3907]WR: reg = 0x%x, data = 0x%x\n",
+						lp3907_init_tbl[i].reg, lp3907_init_tbl[i].data);
+			}
+		} else {
+			dev_err(&pLP3907->client->dev, "lp3907_i2c_write(%x, %x) is failed!\n",
+			       lp3907_init_tbl[i].reg, lp3907_init_tbl[i].data);
+			line = __LINE__;
+			goto lp3907_poweroff_exit;
+		}
+	}
+
+	return 0;
+
+lp3907_poweroff_exit:
+
+	dev_err(&pLP3907->client->dev, "LP3907-CONFIGURE: failed [%d] line=[%d]\n", ret, line);
+	return ret;
+}
+
+static int lp3907_open(struct inode *inode, struct file *file)
+{
+	int err;
+
+	err = nonseekable_open(inode, file);
+	if (err < 0)
+		return err;
+	file->private_data = g_lp3907_data;
+
+	return 0;
+}
+
+static int lp3907_release(struct inode *inode, struct file *file)
+{
+  printk(KERN_INFO "%s is called.\n", __func__);
+  return 0;
+}
+
+static int lp3907_ioctl(struct inode *inode, struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	/*void __user *argp = (void __user *)arg;*/
+	int status = -1;
+	struct lp3907_data *pLP3907 = file->private_data;
+
+	switch (cmd) {
+	case LP3907_PWR_OFF_CMD:
+		/* power off sequence */
+		status = lp3907_power_off_sequence(pLP3907);
+		break;
+
+	case LP3907_PWR_ON_CMD:
+		/* power on sequence */
+		status = lp3907_power_on_sequence(pLP3907);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return status;
+}
+
+struct file_operations lp3907_fops = {
+	.owner   = THIS_MODULE,
+	.open    = lp3907_open,
+	.release = lp3907_release,
+	.ioctl   = lp3907_ioctl,
+};
+
+/* *****************************************************
+
+	Probe, Remove
+
+* ******************************************************/
+static int lp3907_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct lp3907_data *pLP3907;
+	int ret = -1, line;
+
+	dev_info(&client->dev, "lp3907_probe() is called.\n");
+
+	if (client->dev.platform_data == NULL) {
+		dev_err(&client->dev, "[lp3907]platform data is NULL. exiting.\n");
+		ret = -ENODEV;
+		goto err0;
+	}
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		ret  = -ENODEV;
+		goto err0;
+	}
+
+	pLP3907 = kzalloc(sizeof(*pLP3907), GFP_KERNEL);
+	if (pLP3907 == NULL) {
+		dev_err(&client->dev,
+			"failed to allocate memory for module data\n");
+		ret = -ENOMEM;
+		goto err0;
+	}
+
+	mutex_init(&pLP3907->lock);
+	mutex_lock(&pLP3907->lock);
+	pLP3907->client = client;
+
+	pLP3907->pdata = kmalloc(sizeof(*pLP3907->pdata), GFP_KERNEL);
+	if (pLP3907->pdata == NULL)
+		goto err1;
+	memcpy(pLP3907->pdata, client->dev.platform_data, sizeof(*pLP3907->pdata));
+
+	strncpy(client->name, LP3907_DRIVER_NAME, I2C_NAME_SIZE);
+	i2c_set_clientdata(client, pLP3907);
+
+	if (pLP3907->pdata->init) {
+		ret = pLP3907->pdata->init();
+		if (ret < 0)
+			goto err1;
+	}
+
+    /* store platform data*/
+	g_lp3907_data = pLP3907;
+
+	ret = lp3907_power_off_sequence(pLP3907);
+	if (ret < 0) {
+		dev_err(&pLP3907->client->dev, "LP3907 chip configure is failed!\n");
+		goto err2;
+	}
+
+	mutex_unlock(&pLP3907->lock);
+	return ret;
+
+err2:
+	if (pLP3907->pdata->exit)
+		pLP3907->pdata->exit();
+
+err1:
+	mutex_unlock(&pLP3907->lock);
+	kfree(pLP3907->pdata);
+
+err0:
+	return ret;
+
+}
+
+static int __devexit lp3907_remove(struct i2c_client *client)
+{
+	struct lp3907_data *pLP3907 = i2c_get_clientdata(client);
+
+	dev_info(&pLP3907->client->dev, "lp3907_remove() is called!\n");
+
+	if (pLP3907->pdata->exit)
+		pLP3907->pdata->exit();
+	kfree(pLP3907->pdata);
+	kfree(pLP3907);
+
+	return 0;
+}
+
+static int lp3907_resume(struct i2c_client *client)
+{
+	struct lp3907_data *pLP3907 = i2c_get_clientdata(client);
+
+	dev_info(&pLP3907->client->dev, "lp3907_resume() is called!\n");
+	return 0;
+}
+
+static int lp3907_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	struct lp3907_data *pLP3907 = i2c_get_clientdata(client);
+
+	dev_info(&pLP3907->client->dev, "lp3907_suspend() is called!\n");
+	return 0;
+}
+
+static const struct i2c_device_id lp3907_id[] = {
+	{ LP3907_DRIVER_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, lp3907_id);
+
+static struct i2c_driver lp3907_driver = {
+	.driver = {
+		.name = LP3907_DRIVER_NAME,
+	},
+	.probe	  = lp3907_probe,
+	.remove	  = __devexit_p(lp3907_remove),
+	.resume   = lp3907_resume,
+	.suspend  = lp3907_suspend,
+	.id_table = lp3907_id,
+};
+
+/*
+ *  LP3907 voltage regulator init
+ */
+static int __init lp3907_init(void)
+{
+	struct device *lp3907_device;
+	dev_t devno;
+
+	int ret = -1;
+	int line;
+
+	printk(KERN_INFO "LP3907 voltage regulator driver : init.\n");
+
+	devno = MKDEV(lp3907_major_num, lp3907_minor_num);
+	ret = register_chrdev_region(devno, 1, "lp3907");
+	if (ret < 0) {
+		printk(KERN_ERR "[FATAL] LP3907 device is failed.\n");
+		return ret;
+	}
+
+	lp3907_class = class_create(THIS_MODULE, "lp3907");
+	if (IS_ERR(lp3907_class)) {
+		unregister_chrdev_region(devno, 1);
+		ret = -EFAULT;
+	} else {
+
+	lp3907_device = device_create(lp3907_class,
+			NULL,
+			MKDEV(lp3907_major_num, lp3907_minor_num),
+			NULL,
+			"lp3907");
+		if (IS_ERR(lp3907_device)) {
+			class_destroy(lp3907_class);
+			unregister_chrdev_region(devno, 1);
+			ret = -EFAULT;
+		} else {
+
+	cdev_init(&lp3907_cdev, &lp3907_fops);
+	lp3907_cdev.owner = THIS_MODULE;
+	lp3907_cdev.ops   = &lp3907_fops;
+	kobject_set_name(&lp3907_cdev.kobj, "lp3907");
+	cdev_add(&lp3907_cdev, MKDEV(lp3907_major_num, lp3907_minor_num), 1);
+
+	ret = i2c_add_driver(&lp3907_driver);
+	if (ret) {
+		line = __LINE__;
+		goto init_exit_path;
+	}
+    }
+	}
+
+	printk(KERN_INFO "LP3907 voltage regulator driver : init is completed.\n");
+	return ret;
+init_exit_path:
+	printk(KERN_ERR "[FATAL] Unable to register LP3907 i2c driver!\n");
+	i2c_del_driver(&lp3907_driver);
+	return ret;
+}
+
+static void __exit lp3907_exit(void)
+{
+	i2c_del_driver(&lp3907_driver);
+
+	class_destroy(lp3907_class);
+	unregister_chrdev_region(MKDEV(lp3907_major_num, lp3907_minor_num), 1);
+
+	cdev_del(&lp3907_cdev);
+	printk(KERN_INFO "LP3907 voltage regulator driver: exit\n");
+}
+
+module_init(lp3907_init);
+module_exit(lp3907_exit);
+
+
+MODULE_AUTHOR("Motorola");
+MODULE_DESCRIPTION("LP3907 voltage regulator driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
index 8790ee4..b3f8b53 100644
--- a/drivers/input/misc/Kconfig
+++ b/drivers/input/misc/Kconfig
@@ -271,4 +271,12 @@ config INPUT_HALLEFFECT_BU52014HV
 	  effect sensor.
 
 	  If unsure, say N.
+
+config DISABLE_IRQ_WAKE_KPD
+	tristate "Disable IRQ wakeup on Keypad"
+	default y
+	help
+	  Say Y here if you wish not to let Keypad input wake up the phone
+	  from sleep state.
+
 endif
diff --git a/drivers/input/misc/gpio_matrix.c b/drivers/input/misc/gpio_matrix.c
index 10e1f86..c739615 100644
--- a/drivers/input/misc/gpio_matrix.c
+++ b/drivers/input/misc/gpio_matrix.c
@@ -269,11 +269,13 @@ static int gpio_keypad_request_irqs(struct gpio_kp *kp)
 				"irq %d\n", mi->input_gpios[i], irq);
 			goto err_request_irq_failed;
 		}
+#ifndef CONFIG_DISABLE_IRQ_WAKE_KPD
 		err = set_irq_wake(irq, 1);
 		if (err) {
 			pr_err("gpiomatrix: set_irq_wake failed for input %d, "
 				"irq %d\n", mi->input_gpios[i], irq);
 		}
+#endif
 		disable_irq(irq);
 	}
 	return 0;
diff --git a/drivers/input/touchscreen/qtouch_obp_ts.c b/drivers/input/touchscreen/qtouch_obp_ts.c
index 77a49f7..0f311d3 100644
--- a/drivers/input/touchscreen/qtouch_obp_ts.c
+++ b/drivers/input/touchscreen/qtouch_obp_ts.c
@@ -66,8 +66,8 @@ struct qtouch_ts_data {
 	uint32_t			last_keystate;
 	uint16_t			eeprom_checksum;
 	uint8_t			    checksum_cnt;
-	int					x_delta;
-	int					y_delta;
+        int                             x_delta;
+        int                             y_delta;
 
 	/* Note: The message buffer is reused for reading different messages.
 	 * MUST enforce that there is no concurrent access to msg_buf. */
@@ -407,6 +407,35 @@ static int qtouch_hw_init(struct qtouch_ts_data *ts)
 			return ret;
 		}
 	}
+
+	/* configure the COM CONFIG support */
+	obj = find_obj(ts, QTM_OBJ_SPT_COM_CONFIG);
+	if (obj && obj->entry.num_inst > 0) {
+		ret = qtouch_write_addr(ts, obj->entry.addr,
+					&ts->pdata->com_cfg,
+					min(sizeof(ts->pdata->com_cfg),
+					    obj->entry.size));
+		if (ret != 0) {
+			pr_err("%s: Can't write the COM CONFIG config\n",
+			       __func__);
+			return ret;
+		}
+	}
+
+	/* configure the GPIO PWM support */
+	obj = find_obj(ts, QTM_OBJ_SPT_GPIO_PWM);
+	if (obj && obj->entry.num_inst > 0) {
+		ret = qtouch_write_addr(ts, obj->entry.addr,
+					&ts->pdata->gpio_pwm_cfg,
+					min(sizeof(ts->pdata->gpio_pwm_cfg),
+					    obj->entry.size));
+		if (ret != 0) {
+			pr_err("%s: Can't write the GPIO PWM config\n",
+			       __func__);
+			return ret;
+		}
+	}
+
 	/* configure the grip suppression table */
 	obj = find_obj(ts, QTM_OBJ_PROCI_GRIPFACESUPPRESSION);
 	if (obj && obj->entry.num_inst > 0) {
@@ -421,6 +450,76 @@ static int qtouch_hw_init(struct qtouch_ts_data *ts)
 		}
 	}
 
+	/* configure noise suppression */
+	obj = find_obj(ts, QTM_OBJ_PROCG_NOISE_SUPPRESSION);
+	if (obj && obj->entry.num_inst > 0) {
+		ret = qtouch_write_addr(ts, obj->entry.addr,
+					&ts->pdata->noise_suppression_cfg,
+					min(sizeof(ts->pdata->noise_suppression_cfg),
+					    obj->entry.size));
+		if (ret != 0) {
+			pr_err("%s: Can't write the noise suppression config\n",
+			       __func__);
+			return ret;
+		}
+	}
+
+	/* configure the one touch gesture processor */
+	obj = find_obj(ts, QTM_OBJ_PROCI_ONE_TOUCH_GESTURE_PROC);
+	if (obj && obj->entry.num_inst > 0) {
+		ret = qtouch_write_addr(ts, obj->entry.addr,
+					&ts->pdata->one_touch_gesture_proc_cfg,
+					min(sizeof(ts->pdata->one_touch_gesture_proc_cfg),
+					    obj->entry.size));
+		if (ret != 0) {
+			pr_err("%s: Can't write the one touch gesture processor config\n",
+			       __func__);
+			return ret;
+		}
+	}
+
+	/* configure self test */
+	obj = find_obj(ts, QTM_OBJ_SPT_SELF_TEST);
+	if (obj && obj->entry.num_inst > 0) {
+		ret = qtouch_write_addr(ts, obj->entry.addr,
+					&ts->pdata->self_test_cfg,
+					min(sizeof(ts->pdata->self_test_cfg),
+					    obj->entry.size));
+		if (ret != 0) {
+			pr_err("%s: Can't write the self test config\n",
+			       __func__);
+			return ret;
+		}
+	}
+
+	/* configure the two touch gesture processor */
+	obj = find_obj(ts, QTM_OBJ_PROCI_TWO_TOUCH_GESTURE_PROC);
+	if (obj && obj->entry.num_inst > 0) {
+		ret = qtouch_write_addr(ts, obj->entry.addr,
+					&ts->pdata->two_touch_gesture_proc_cfg,
+					min(sizeof(ts->pdata->two_touch_gesture_proc_cfg),
+					    obj->entry.size));
+		if (ret != 0) {
+			pr_err("%s: Can't write the two touch gesture processor config\n",
+			       __func__);
+			return ret;
+		}
+	}
+
+	/* configure the capacitive touch engine  */
+	obj = find_obj(ts, QTM_OBJ_SPT_CTE_CONFIG);
+	if (obj && obj->entry.num_inst > 0) {
+		ret = qtouch_write_addr(ts, obj->entry.addr,
+					&ts->pdata->cte_config_cfg,
+					min(sizeof(ts->pdata->cte_config_cfg),
+					    obj->entry.size));
+		if (ret != 0) {
+			pr_err("%s: Can't write the capacitive touch engine config\n",
+			       __func__);
+			return ret;
+		}
+	}
+
 	/* configure the noise suppression table */
 	obj = find_obj(ts, QTM_OBJ_NOISESUPPRESSION_1);
 	if (obj && obj->entry.num_inst > 0) {
@@ -435,6 +534,20 @@ static int qtouch_hw_init(struct qtouch_ts_data *ts)
 		}
 	}
 
+	/* configure the user data table */
+	obj = find_obj(ts, QTM_OBJ_CPT_USERDATA);
+	if (obj && obj->entry.num_inst > 0) {
+		ret = qtouch_write_addr(ts, obj->entry.addr,
+					&ts->pdata->userdata,
+					min(sizeof(ts->pdata->userdata),
+					    obj->entry.size));
+		if (ret != 0) {
+			pr_err("%s: Can't write the user data\n",
+			       __func__);
+			return ret;
+		}
+	}
+
 	ret = qtouch_force_calibration(ts);
 	if (ret != 0) {
 		pr_err("%s: Unable to recalibrate after reset\n", __func__);
@@ -573,6 +686,12 @@ static int do_touch_multi_msg(struct qtouch_ts_data *ts, struct qtm_object *obj,
 	width = msg->touch_area;
 	pressure = msg->touch_amp;
 
+	if (ts->pdata->flags & QTOUCH_FLIP_X)
+		x = (ts->pdata->abs_max_x-1)-x;
+
+	if (ts->pdata->flags & QTOUCH_FLIP_Y)
+		y = (ts->pdata->abs_max_y-1)-y;
+
 	if (ts->pdata->flags & QTOUCH_SWAP_XY)
 		swap(x, y);
 
@@ -582,23 +701,23 @@ static int do_touch_multi_msg(struct qtouch_ts_data *ts, struct qtm_object *obj,
 
 	down = !(msg->status & QTM_TOUCH_MULTI_STATUS_RELEASE);
 
-	/* The chip may report erroneous points way
-	beyond what a user could possibly perform so we filter
-	these out */
-	if (ts->finger_data[finger].down &&
-			(abs(ts->finger_data[finger].x_data - x) > ts->x_delta ||
-			abs(ts->finger_data[finger].y_data - y) > ts->y_delta)) {
-				down = 0;
-				if (qtouch_tsdebug & 2)
-					pr_info("%s: x0 %i x1 %i y0 %i y1 %i\n",
-						__func__,
-						ts->finger_data[finger].x_data, x,
-						ts->finger_data[finger].y_data, y);
-	} else {
-		ts->finger_data[finger].x_data = x;
-		ts->finger_data[finger].y_data = y;
-		ts->finger_data[finger].w_data = width;
-	}
+        /* The chip may report erroneous points way
+        beyond what a user could possibly perform so we filter
+        these out */
+        if (ts->finger_data[finger].down &&
+                       (abs(ts->finger_data[finger].x_data - x) > ts->x_delta ||
+                       abs(ts->finger_data[finger].y_data - y) > ts->y_delta)) {
+                               down = 0;
+                               if (qtouch_tsdebug & 2)
+                                       pr_info("%s: x0 %i x1 %i y0 %i y1 %i\n",
+                                               __func__,
+                                               ts->finger_data[finger].x_data, x,
+                                               ts->finger_data[finger].y_data, y);
+        } else {
+               ts->finger_data[finger].x_data = x;
+               ts->finger_data[finger].y_data = y;
+               ts->finger_data[finger].w_data = width;
+        }
 
 	/* The touch IC will not give back a pressure of zero
 	   so send a 0 when a liftoff is produced */
@@ -758,6 +877,17 @@ static int qtouch_process_info_block(struct qtouch_ts_data *ts)
 	addr = QTM_OBP_ID_INFO_ADDR + sizeof(qtm_info);
 	report_id = 1;
 
+	/* Clear the object table */
+	for (i = 0; i < QTM_OBP_MAX_OBJECT_NUM; ++i) {
+		ts->obj_tbl[i].entry.type = 0;
+		ts->obj_tbl[i].entry.addr = 0;
+		ts->obj_tbl[i].entry.size = 0;
+		ts->obj_tbl[i].entry.num_inst = 0;
+		ts->obj_tbl[i].entry.num_rids = 0;
+		ts->obj_tbl[i].report_id_min = 0;
+		ts->obj_tbl[i].report_id_max = 0;
+	}
+
 	/* read out the object entries table */
 	for (i = 0; i < qtm_info.num_objs; ++i) {
 		struct qtm_object *obj;
@@ -846,6 +976,26 @@ static int qtouch_process_info_block(struct qtouch_ts_data *ts)
 
 	ts->eeprom_checksum = ts->pdata->nv_checksum;
 
+/*below: use different setting for vf.5 && vf.6*/
+	if ((qtm_info.family_id == 0x80) && \
+		((qtm_info.version == 0xf5) || \
+		(qtm_info.version == 0xf6) || \
+		(qtm_info.version == 0x12) || \
+		(qtm_info.version == 0x14))) {
+		printk(KERN_INFO "use setting for old touch firmware \n");
+		/* ts->pdata->power_cfg.active_acq_int = 0x0a; */
+
+		/* ts->pdata->acquire_cfg.touch_autocal = 0; */
+		/* ts->pdata->acquire_cfg.anti_cal_sthr = 0x14; */
+
+		ts->pdata->multi_touch_cfg.burst_len = 0x21;
+		/* ts->pdata->multi_touch_cfg.tch_det_thr = 0x25; */
+
+		/* ts->pdata->noise_suppression_cfg.gcaf_num_active = 0x03; */
+		/* ts->pdata->noise_suppression_cfg.gcaf_num_idle = 0; */
+
+		/* ts->pdata->cte_config_cfg.active_gcaf_depth = 0x10; */
+	}
 	return 0;
 
 err_no_checksum:
@@ -894,8 +1044,8 @@ static int qtouch_ts_probe(struct i2c_client *client,
 	ts->client = client;
 	i2c_set_clientdata(client, ts);
 	ts->checksum_cnt = 0;
-	ts->x_delta = ts->pdata->x_delta;
-	ts->y_delta = ts->pdata->y_delta;
+        ts->x_delta = ts->pdata->x_delta;
+        ts->y_delta = ts->pdata->y_delta;
 
 	ts->input_dev = input_allocate_device();
 	if (ts->input_dev == NULL) {
@@ -1052,6 +1202,10 @@ static int qtouch_ts_suspend(struct i2c_client *client, pm_message_t mesg)
 	if (qtouch_tsdebug & 4)
 		pr_info("%s: Suspending\n", __func__);
 
+	ret = qtouch_power_config(ts, 0);
+	if (ret < 0)
+		pr_err("%s: Cannot write power config\n", __func__);
+
 	disable_irq_nosync(ts->client->irq);
 	ret = cancel_work_sync(&ts->work);
 	if (ret) { /* if work was pending disable-count is now 2 */
@@ -1059,10 +1213,6 @@ static int qtouch_ts_suspend(struct i2c_client *client, pm_message_t mesg)
 		enable_irq(ts->client->irq);
 	}
 
-	ret = qtouch_power_config(ts, 0);
-	if (ret < 0)
-		pr_err("%s: Cannot write power config\n", __func__);
-
 	return 0;
 }
 
@@ -1091,14 +1241,32 @@ static int qtouch_ts_resume(struct i2c_client *client)
 	}
 	input_sync(ts->input_dev);
 
+	enable_irq(ts->client->irq);
+
 	ret = qtouch_power_config(ts, 1);
 	if (ret < 0) {
 		pr_err("%s: Cannot write power config\n", __func__);
 		return -EIO;
 	}
+
 	qtouch_force_reset(ts, 0);
 
-	enable_irq(ts->client->irq);
+	/* Below is a workaround for touch hang issue after toggling
+	   the power key */
+	ret = qtouch_force_calibration(ts);
+	if (ret != 0) {
+		pr_err("%s: Unable to recalibrate after reset\n", __func__);
+		return -EIO;
+	}
+	/* reset the address pointer */
+	ret = qtouch_set_addr(ts, ts->obj_tbl[QTM_OBJ_GEN_MSG_PROC].entry.addr);
+	if (ret != 0) {
+		pr_err("%s: Unable to reset address pointer after reset\n",
+		       __func__);
+		return -EIO;
+	}
+	msleep(50);
+
 	return 0;
 }
 
diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
index aecad1f..7e9955b 100644
--- a/drivers/leds/Kconfig
+++ b/drivers/leds/Kconfig
@@ -194,6 +194,12 @@ config LEDS_SHOLES
 	depends on LEDS_CLASS
 	help
 	  This option enables support for LEDs on Sholes.
+          
+config LEDS_SHOLEST
+	tristate "LED Support for Sholes Tablet device"
+	depends on LEDS_CLASS
+	help
+	  This option enables support for LEDs on Sholes Tablet.
 
 config LEDS_LM3530
 	tristate "LM3530 ALS driver"
@@ -207,6 +213,32 @@ config LEDS_LM3554
 	help
 	  This option enables support for the LM3554 .
 
+config LEDS_BD7885
+	tristate "LED Support for BD7885 I2C chips"
+	depends on LEDS_CLASS && I2C
+	help
+	  This option enables support for LEDs connected to BD7885
+	  LED driver chips accessed via the I2C bus.  Supported
+
+config LEDS_BU9847
+	tristate "LED Support for BU9847 I2C chips"
+	depends on LEDS_CLASS && I2C
+	help
+	  This option enables support for LEDs connected to BU9847
+	  LED driver chips accessed via the I2C bus.  Supported
+
+config LEDS_AF_LED
+	tristate "LED Support for AF LED operatiion"
+	depends on LEDS_CLASS
+	help
+	  This option enables support for LEDs connected to CPCAP.
+	  
+config LEDS_FLASH_RESET
+	tristate "LED Support for FLASH_RESET pin control"
+	depends on LEDS_CLASS && LEDS_BD7885
+	help
+	  This option enables support for LED's FLASH_RESET pin operation.
+
 comment "LED Triggers"
 
 config LEDS_TRIGGERS
diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
index 4597956..2c4d4c9 100644
--- a/drivers/leds/Makefile
+++ b/drivers/leds/Makefile
@@ -26,6 +26,9 @@ obj-$(CONFIG_LEDS_FSG)			+= leds-fsg.o
 obj-$(CONFIG_LEDS_PCA955X)		+= leds-pca955x.o
 obj-$(CONFIG_LEDS_DA903X)		+= leds-da903x.o
 obj-$(CONFIG_LEDS_WM8350)		+= leds-wm8350.o
+obj-$(CONFIG_LEDS_BD7885)		+= leds-bd7885.o
+obj-$(CONFIG_LEDS_BU9847)		+= leds-bu9847.o
+obj-$(CONFIG_LEDS_AF_LED)		+= leds-ld-cpcap-afled.o
 obj-$(CONFIG_LEDS_SHOLES)		+= leds-ld-cpcap-disp.o \
 					   leds-ld-cpcap-rgb.o \
 					   leds-ld-cpcap-kpad.o
diff --git a/drivers/leds/led-cpcap-lm3554.c b/drivers/leds/led-cpcap-lm3554.c
old mode 100755
new mode 100644
diff --git a/drivers/leds/led-lm3530.c b/drivers/leds/led-lm3530.c
old mode 100755
new mode 100644
index e5033e4..c555202
--- a/drivers/leds/led-lm3530.c
+++ b/drivers/leds/led-lm3530.c
@@ -27,6 +27,11 @@
 #include <linux/interrupt.h>
 #include <linux/led-lm3530.h>
 #include <linux/types.h>
+#include <linux/gpio_mapping.h>
+#ifdef CONFIG_LEDS_SHOLEST
+#include <linux/panel-suppliers.h>
+#endif
+#include <mach/gpio.h>
 
 int als_resistor_val[16] = {1, 9260, 4630, 3090, 2310,
 1850, 1540, 1320, 1160, 1030, 925, 842, 772, 712, 661, 617};
@@ -50,8 +55,39 @@ struct lm3530_data {
 	uint8_t current_divisor;
 	uint8_t current_array[8];
 	uint8_t led_on;
+#ifdef CONFIG_LEDS_SHOLEST
+	uint8_t als_circ;
+	uint16_t panel_supplier;
+#endif
 };
 
+#ifdef CONFIG_LEDS_SHOLEST
+/* For less power consumption */
+#define LM3530_LEDDRV_EN    get_gpio_by_name("lcd_panel_reset")
+/* Two-way ALS transition */
+#define ALS_INDOOR	0
+#define ALS_OUTDOOR	1
+
+/* Brightness converting table for AUO panel @ full current 22.5mA */
+uint8_t lm3530_auo_brt_cvt_tbl[128] = {
+	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	0x09, 0x0A, 0x0C, 0x0E, 0x0F, 0x10, 0x11, 0x13,
+	0x14, 0x15, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A,
+	0x1B, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x20,
+	0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x26, 0x27,
+	0x28, 0x29, 0x2A, 0x2B, 0x2B, 0x2C, 0x2D, 0x2E,
+	0x2F, 0x30, 0x31, 0x31, 0x32, 0x33, 0x34, 0x35,
+	0x36, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C,
+	0x3C, 0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x41, 0x42,
+	0x43, 0x44, 0x45, 0x46, 0x46, 0x47, 0x48, 0x49,
+	0x4A, 0x4B, 0x4C, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,
+	0x51, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
+	0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5C, 0x5D,
+	0x5E, 0x5F, 0x60, 0x61, 0x61, 0x62, 0x63, 0x64,
+	0x65, 0x66, 0x67, 0x67, 0x68, 0x69, 0x6A, 0x6B,
+	0x6C, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72};
+#endif
+
 struct lm3530_reg {
 	const char *name;
 	uint8_t reg;
@@ -79,6 +115,10 @@ static void lm3530_early_suspend(struct early_suspend *handler);
 static void lm3530_late_resume(struct early_suspend *handler);
 #endif
 
+#ifdef CONFIG_LEDS_SHOLEST
+static void ld_lm3530_lux_conv(struct lm3530_data *als_data);
+#endif
+
 static uint32_t lm3530_debug;
 module_param_named(als_debug, lm3530_debug, uint, 0664);
 
@@ -173,19 +213,98 @@ static int ld_lm3530_init_registers(struct lm3530_data *als_data)
 	return 0;
 }
 
+#ifdef CONFIG_LEDS_SHOLEST
+static int ld_lm3530_switch_als_circumstance(struct lm3530_data *als_data,
+					     uint8_t set_als)
+{
+	switch (set_als) {
+	case ALS_INDOOR:
+		/* Set ALS configuration for Indoor mode */
+		als_data->als_pdata->als_resistor_sel = 0x22;
+		als_data->als_pdata->zone_boundary_0  = 0x07;
+		als_data->als_pdata->zone_boundary_1  = 0x29;
+		als_data->als_pdata->zone_boundary_2  = 0x48;
+		als_data->als_pdata->zone_boundary_3  = 0x94;
+		als_data->als_pdata->zone_target_0    = 0x12;
+		als_data->als_pdata->zone_target_1    = 0x1F;
+		als_data->als_pdata->zone_target_2    = 0x28;
+		als_data->als_pdata->zone_target_3    = 0x31;
+		als_data->als_pdata->zone_target_4    = 0x3A;
+		/* Circumstance parameter */
+		als_data->als_circ = ALS_INDOOR;
+		break;
+	case ALS_OUTDOOR:
+		/* Set ALS configuration for Outdoor mode */
+		als_data->als_pdata->als_resistor_sel = 0xBC;
+		als_data->als_pdata->zone_boundary_0  = 0x09;
+		als_data->als_pdata->zone_boundary_1  = 0x39;
+		als_data->als_pdata->zone_boundary_2  = 0x86;
+		als_data->als_pdata->zone_boundary_3  = 0xC9;
+		als_data->als_pdata->zone_target_0    = 0x3A;
+		als_data->als_pdata->zone_target_1    = 0x42;
+		als_data->als_pdata->zone_target_2    = 0x4B;
+		als_data->als_pdata->zone_target_3    = 0x54;
+		als_data->als_pdata->zone_target_4    = 0x65;
+		/* Circumstance parameter */
+		als_data->als_circ = ALS_OUTDOOR;
+		break;
+	default:
+		pr_err("%s:Invalid ALS circumstance\n", __func__);
+		break;
+	}
+
+	/* Write registers set */
+	if (lm3530_write_reg(als_data, LM3530_ALS_RESISTOR_SELECT,
+			als_data->als_pdata->als_resistor_sel) ||
+	    lm3530_write_reg(als_data, LM3530_ALS_ZB0_REG,
+			als_data->als_pdata->zone_boundary_0) ||
+	    lm3530_write_reg(als_data, LM3530_ALS_ZB1_REG,
+			als_data->als_pdata->zone_boundary_1) ||
+	    lm3530_write_reg(als_data, LM3530_ALS_ZB2_REG,
+			als_data->als_pdata->zone_boundary_2) ||
+	    lm3530_write_reg(als_data, LM3530_ALS_ZB3_REG,
+			als_data->als_pdata->zone_boundary_3) ||
+	    lm3530_write_reg(als_data, LM3530_ALS_Z0T_REG,
+			als_data->als_pdata->zone_target_0) ||
+	    lm3530_write_reg(als_data, LM3530_ALS_Z1T_REG,
+			als_data->als_pdata->zone_target_1) ||
+	    lm3530_write_reg(als_data, LM3530_ALS_Z2T_REG,
+			als_data->als_pdata->zone_target_2) ||
+	    lm3530_write_reg(als_data, LM3530_ALS_Z3T_REG,
+			als_data->als_pdata->zone_target_3) ||
+	    lm3530_write_reg(als_data, LM3530_ALS_Z4T_REG,
+			als_data->als_pdata->zone_target_4)) {
+		pr_err("%s:ALS indoor setting failed\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Update converting table */
+	ld_lm3530_lux_conv(als_data);
+
+	return 0;
+}
+#endif
+
 static void ld_lm3530_brightness_set(struct led_classdev *led_cdev,
 				     enum led_brightness value)
 {
 	int brightness = 0;
 	int error = 0;
 	int old_led_on;
+	int config;
 	struct lm3530_data *als_data =
 	    container_of(led_cdev, struct lm3530_data, led_dev);
 
-	if (als_data->mode == AUTOMATIC)
+#ifdef CONFIG_LEDS_SHOLEST
+	if (als_data->panel_supplier == SUPPLIER_ID_INVALID)
+		als_data->panel_supplier = SUPPLIER_ID_AUO;
+#endif
+
+	if (als_data->mode == AUTOMATIC) {
 		brightness = als_data->als_pdata->gen_config;
-	else
+	} else {
 		brightness = als_data->als_pdata->manual_current;
+	}
 
 	if (value == LED_OFF) {
 		als_data->led_on = 0;
@@ -195,19 +314,70 @@ static void ld_lm3530_brightness_set(struct led_classdev *led_cdev,
 				__func__, error);
 			return;
 		}
+#ifdef CONFIG_LEDS_SHOLEST
+		gpio_set_value(LM3530_LEDDRV_EN, 0);
+#endif
 	} else {
 		brightness |= 0x01;
+#ifdef CONFIG_LEDS_SHOLEST
+		if (als_data->led_on == 0) {
+			/* Set LEDDRV_EN on */
+			gpio_set_value(LM3530_LEDDRV_EN, 1);
+			msleep(5);
+
+			/* Reinitialize lm3530 */
+			ld_lm3530_init_registers(als_data);
+
+			if (als_data->mode == AUTOMATIC) {
+				/* Set ALS as indoor mode */
+				ld_lm3530_switch_als_circumstance(als_data,
+								  ALS_INDOOR);
+			} else {
+				/* Restore configurations to disable ALS */
+				config = LM3530_MANUAL_VALUE;
+				if (als_data->mode != MANUAL)
+					config |= LM3530_SENSOR_ENABLE;
+				lm3530_write_reg(als_data, LM3530_ALS_CONFIG,
+						 config);
+				/* ALS resistance */
+				config = (als_data->mode == MANUAL ? 0 :
+					als_data->als_pdata->als_resistor_sel);
+				lm3530_write_reg(als_data,
+						 LM3530_ALS_RESISTOR_SELECT,
+						 config);
+				/* Set ramp rate for manual mode */
+				lm3530_write_reg(als_data,
+						 LM3530_BRIGHTNESS_RAMP_RATE,
+						 LM3530_MANUAL_RAMP_RATE_VALUE);
+				/* Update converting table */
+				ld_lm3530_lux_conv(als_data);
+			}
+		}
+#endif
+		if (lm3530_debug)
+			pr_info("%s:LM3530_GEN_CONFIG=%x\n",
+				__func__, brightness);
 		if (lm3530_write_reg(als_data, LM3530_GEN_CONFIG, brightness)) {
 			pr_err("%s:writing failed while setting brightness:%d\n",
 				__func__, error);
 			return;
 		}
+#ifdef CONFIG_LEDS_SHOLEST
 		if (lm3530_write_reg(als_data, LM3530_BRIGHTNESS_CTRL_REG,
-			value / 2)) {
+			((als_data->panel_supplier == SUPPLIER_ID_AUO) ?
+			lm3530_auo_brt_cvt_tbl[value >> 1] : value >> 1))) {
 				pr_err("%s:Failed to set brightness:%d\n",
 				__func__, error);
 			return;
 		}
+#else
+		if (lm3530_write_reg(als_data, LM3530_BRIGHTNESS_CTRL_REG,
+			value >> 1)) {
+			pr_err("%s:Failed to set brightness:%d\n",
+				__func__, error);
+			return;
+		}
+#endif
 		als_data->last_requested_brightness = value;
 		old_led_on = als_data->led_on;
 		als_data->led_on = 1;
@@ -249,10 +419,11 @@ static ssize_t ld_lm3530_als_store(struct device *dev, struct device_attribute
 		    && mode_value != MANUAL_SENSOR)
 		return -1;
 
-	if (mode_value == AUTOMATIC)
+	if (mode_value == AUTOMATIC) {
 		brightness = als_data->als_pdata->gen_config;
-	else
+	} else {
 		brightness = als_data->als_pdata->manual_current;
+	}
 
 	if (mode_value == AUTOMATIC) {
 		ld_lm3530_init_registers(als_data);
@@ -264,6 +435,19 @@ static ssize_t ld_lm3530_als_store(struct device *dev, struct device_attribute
 			als_data->mode = -1;
 			return -1;
 		}
+#ifdef CONFIG_LEDS_SHOLEST
+		/* Restore ramp rate for automatic ALS mode */
+		error = lm3530_write_reg(als_data,
+					 LM3530_BRIGHTNESS_RAMP_RATE,
+					 als_data->als_pdata->brightness_ramp);
+		if (error) {
+			pr_err("%s:Failed to restore ramp rate %d\n",
+			       __func__, error);
+			return -1;
+		}
+		/* Update converting table */
+		ld_lm3530_lux_conv(als_data);
+#endif
 		als_data->mode = AUTOMATIC;
 	} else {
 		als_data->mode = mode_value;
@@ -295,6 +479,17 @@ static ssize_t ld_lm3530_als_store(struct device *dev, struct device_attribute
 			       __func__, error);
 			return -1;
 		}
+#ifdef CONFIG_LEDS_SHOLEST
+		/* Set ramp rate for manual mode */
+		error = lm3530_write_reg(als_data,
+					 LM3530_BRIGHTNESS_RAMP_RATE,
+					 LM3530_MANUAL_RAMP_RATE_VALUE);
+		if (error) {
+			pr_err("%s:Failed to restore ramp rate %d\n",
+			       __func__, error);
+		return -1;
+	}
+#endif
 	}
 
 	if (mode_value != MANUAL) {
@@ -416,6 +611,61 @@ static ssize_t ld_lm3530_registers_store(struct device *dev,
 static DEVICE_ATTR(registers, 0644, ld_lm3530_registers_show,
 		ld_lm3530_registers_store);
 
+/*
+ * To handle panel dependent physical characteristic variances.
+ */
+#ifdef CONFIG_LEDS_SHOLEST
+static ssize_t
+ ld_lm3530_backlight_panel_show(struct device *dev, struct device_attribute
+			*attr, char *buf)
+{
+	struct i2c_client *client = container_of(dev->parent, struct i2c_client,
+						 dev);
+	struct lm3530_data *als_data = i2c_get_clientdata(client);
+
+	return sprintf(buf, "%u", als_data->panel_supplier);
+}
+
+static ssize_t
+ ld_lm3530_panel_specific_tune(struct device *dev, struct device_attribute
+			*attr, const char *buf, size_t size)
+{
+	int error = 0;
+	unsigned long backlight_panel;
+	struct i2c_client *client = container_of(dev->parent, struct i2c_client,
+						 dev);
+	struct lm3530_data *als_data = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &backlight_panel);
+	if (error < 0) {
+		pr_err("%s:Unable to read input, error=%d\n", __func__, error);
+		return -1;
+	}
+
+	pr_info("%s:Tuning full current according to given panel ID:%lu\n",
+		__func__, backlight_panel);
+
+	/* Store panel supplier ID */
+	als_data->panel_supplier = backlight_panel;
+
+	if (als_data->panel_supplier != SUPPLIER_ID_INVALID) {
+		/* Set current 26mA for TMD or 29.5mA for AUO */
+		als_data->als_pdata->gen_config =
+			(als_data->als_pdata->gen_config & 0xE3) |
+			((als_data->panel_supplier == SUPPLIER_ID_TMD) ?
+			 0x18 : 0x1C);
+		/* Set current 19mA for TMD or 22.5mA for AUO */
+		als_data->als_pdata->manual_current =
+			(als_data->als_pdata->manual_current & 0xE3) |
+			((als_data->panel_supplier == SUPPLIER_ID_TMD) ?
+			 0x10 : 0x14);
+	}
+	return backlight_panel;
+}
+static DEVICE_ATTR(backlight_panel, 0666, ld_lm3530_backlight_panel_show,
+			ld_lm3530_panel_specific_tune);
+#endif
+
 void ld_lm3530_work_queue(struct work_struct *work)
 {
 	int ret;
@@ -430,7 +680,6 @@ void ld_lm3530_work_queue(struct work_struct *work)
 		       __func__, ret);
 
 		enable_irq(als_data->client->irq);
-
 		return;
 	}
 	/* Don't allow the data to be sent if the LED is supposed to
@@ -438,6 +687,7 @@ void ld_lm3530_work_queue(struct work_struct *work)
 	if (als_data->led_on == 0) {
 		if (lm3530_debug)
 			pr_info("%s:Skipping this interrupt\n", __func__);
+
 		enable_irq(als_data->client->irq);
 		return;
 	}
@@ -447,7 +697,27 @@ void ld_lm3530_work_queue(struct work_struct *work)
 		pr_info("%s:ALS Zone read back: %d\n",
 		       __func__, als_data->zone);
 
-	light_value = als_data->zone *  (als_data->current_divisor - 1);
+#ifdef CONFIG_LEDS_SHOLEST
+	if ((als_data->als_circ == ALS_OUTDOOR) &&
+	    (als_data->zone == LM3530_ALS_ZONE_MIN)) {
+		pr_info("%s:Switch ALS configuratiosn into indoor mode\n",
+			__func__);
+		ld_lm3530_switch_als_circumstance(als_data, ALS_INDOOR);
+
+		queue_work(als_data->working_queue, &als_data->wq);
+		return;
+	} else if ((als_data->als_circ == ALS_INDOOR) &&
+		   (als_data->zone == LM3530_ALS_ZONE_MAX)) {
+		pr_info("%s:Switch ALS configuratiosn into outdoor mode\n",
+			__func__);
+		ld_lm3530_switch_als_circumstance(als_data, ALS_OUTDOOR);
+
+		queue_work(als_data->working_queue, &als_data->wq);
+		return;
+	}
+#endif
+
+	light_value = als_data->zone * (als_data->current_divisor - 1);
 
 	/* Need to indicate a zone 0 but this would indicate it is off
 	so send up a low value and not a 0 */
@@ -581,6 +851,10 @@ static int ld_lm3530_probe(struct i2c_client *client,
 	als_data->led_dev.name = LD_LM3530_LED_DEV;
 	als_data->led_dev.brightness_set = ld_lm3530_brightness_set;
 	als_data->led_on = 1;
+#ifdef CONFIG_LEDS_SHOLEST
+	als_data->als_circ = ALS_INDOOR;
+	als_data->panel_supplier = SUPPLIER_ID_TMD;
+#endif
 
 	als_data->working_queue = create_singlethread_workqueue("als_wq");
 	if (!als_data->working_queue) {
@@ -654,6 +928,15 @@ static int ld_lm3530_probe(struct i2c_client *client,
 		goto err_create_registers_file_failed;
 	}
 
+#ifdef CONFIG_LEDS_SHOLEST
+	error = device_create_file(als_data->led_dev.dev, &dev_attr_backlight_panel);
+	if (error < 0) {
+		pr_err("%s:File device creation failed: %d\n", __func__, error);
+		error = -ENODEV;
+		goto err_create_backlight_panel_file_failed;
+	}
+#endif
+
 #ifdef CONFIG_HAS_EARLYSUSPEND
 	als_data->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
 	als_data->early_suspend.suspend = lm3530_early_suspend;
@@ -665,6 +948,10 @@ static int ld_lm3530_probe(struct i2c_client *client,
 
 	return 0;
 
+#ifdef CONFIG_LEDS_SHOLEST
+err_create_backlight_panel_file_failed:
+	device_remove_file(als_data->led_dev.dev, &dev_attr_backlight_panel);
+#endif
 err_create_registers_file_failed:
 	device_remove_file(als_data->led_dev.dev, &dev_attr_pwm_mode);
 err_create_pwm_file_failed:
@@ -693,6 +980,9 @@ static int ld_lm3530_remove(struct i2c_client *client)
 	device_remove_file(als_data->led_dev.dev, &dev_attr_als);
 	device_remove_file(als_data->led_dev.dev, &dev_attr_pwm_mode);
 	device_remove_file(als_data->led_dev.dev, &dev_attr_registers);
+#ifdef CONFIG_LEDS_SHOLEST
+	device_remove_file(als_data->led_dev.dev, &dev_attr_backlight_panel);
+#endif
 	led_classdev_unregister(&als_data->led_dev);
 	free_irq(als_data->client->irq, als_data);
 	if (als_data->working_queue)
diff --git a/drivers/leds/leds-bd7885.c b/drivers/leds/leds-bd7885.c
new file mode 100644
index 0000000..6dfe3de
--- /dev/null
+++ b/drivers/leds/leds-bd7885.c
@@ -0,0 +1,661 @@
+/*
+ * drivers/i2c/chips/leds-bd7885.c
+ *
+ * I2C slave driver for BD7885 device
+ *
+ * Copyright (C) 2008-2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Revision History:
+ *
+ * Date          Author    Comment
+ * -----------   --------  -------------------
+ * Jun-24-2008   Motorola  Initial version
+ * 
+ */
+
+#include <linux/kernel.h>	/* printk() */
+#include <linux/fs.h>		/* everything... */
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/cdev.h>
+#include <asm/gpio.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <asm/uaccess.h>
+#include <linux/miscdevice.h>
+
+#include <linux/leds-bd7885.h>
+
+#if defined(CONFIG_LEDS_BU9847)
+#include <linux/leds-bu9847.h>
+#endif
+
+static int bd7885_open(struct inode *inode, struct file *file);
+static int bd7885_release(struct inode *inode, struct file *file);
+static int bd7885_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
+
+/*Below two external definition is for strobe manual control.*/
+extern int ov8810_strobe_manual_ready(void);
+extern int ov8810_strobe_manual_trigger(void);
+
+#if defined(CONFIG_LEDS_BU9847)
+int bu9847_fetch_regs(void);
+#endif
+
+struct bd7885_chip {
+	struct mutex lock;
+	struct i2c_client *client;
+	int status;               /* flag indicate chip current power state */
+};
+
+struct file_operations bd7885_fops = {
+	.owner   = THIS_MODULE,
+	.open    = bd7885_open,
+	.release = bd7885_release,
+	.ioctl   = bd7885_ioctl,
+};
+
+static struct miscdevice bd7885_device = {
+  .minor = MISC_DYNAMIC_MINOR,
+  .name = BD7885_DEVICE_NAME,
+  .fops = &bd7885_fops,
+};
+
+const static bd7885_cfg bd7885_charege_enalbe_tbl[4] = {
+	{BD7885_DRVCNT_REG, 0x03},
+	{BD7885_RECHG_REG, 0x11},
+	{BD7885_IPEAKADJ_REG, 0x07},
+	/* must end invalid register */
+	{BD7885_REG_TERM, BD7885_VAL_TERM}
+};
+
+const static bd7885_cfg bd7885_charge_disable_tbl[2] = {
+       {BD7885_DRVCNT_REG, 0x00},
+	/* must end invalid register */
+	{BD7885_REG_TERM, BD7885_VAL_TERM}
+};
+
+/*for register value keep here.*/
+static char bd7885_reg_status_tbl[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+
+/* for ioctl */
+struct i2c_client *bd7885_i2c_client;
+
+/* device major number */
+int bd7885_major_num = 0;
+int bd7885_minor_num = 0;
+
+#if defined(CONFIG_LEDS_BU9847)
+/*for register value keep here.*/
+extern char bu9847_reg_info_tbl[18];
+#endif
+
+#define BD7885_I2C_RETRY_MAX 3
+
+/* *****************************************************
+
+	Low level interface routine.
+
+* *****************************************************/
+static int bd7885_reg_read(struct i2c_client *client, u8 reg_addr, u8 *buf)
+{
+    /** \var error
+     *  \brief Return error code, initialized to no error
+     */
+    int error = E_OK;
+    /** \var i
+     *  \brief Retry counter
+     */
+    int i = 0;
+    unsigned char value[BD7885_REG_DATA_LEN];
+
+    /* If number of bytes is out of range or buffer is incorrect, report, exit */
+    if ((buf == NULL) || (reg_addr > BD7885_STATUS_REG)) {
+	printk(KERN_ERR "invalid read parameter(s)\n");
+	return -EINVAL;
+    }
+    /* If I2C client doesn't exist */
+    if (client == NULL) {
+	printk(KERN_ERR "bd7885 null i2c read client\n");
+	return -EUNATCH;
+    }
+
+    /* Do read */
+    do {
+	/* Establish read address
+	*  i2c_master_send returns either the number of bytes sent or negative error from
+	*  i2c_transfer
+	*/
+	/* Copy the data into a buffer for correct format */
+	value[0] = reg_addr & 0xFF;
+	error = i2c_master_send(client, value, BD7885_REG_DATA_LEN);
+	/* Read data if send address succeeded (i2c_master_send returns the number
+	*  of bytes transferred) */
+	if (error == BD7885_REG_DATA_LEN) {
+		/* Retreive data
+		*  i2c_master_recv returns either the number of bytes received or negative error
+		*  from i2c_transfer
+		*/
+		error = i2c_master_recv(client, buf, BD7885_REG_DATA_LEN);
+	} else {
+		printk(KERN_ERR "bd7885 write of address %d failed: %d\n", value[0], error);
+	}
+
+	/* On failure (error will contain num_bytes if succeeded), print error code and
+	* delay before trying again */
+	if (error != BD7885_REG_DATA_LEN) {
+		printk(KERN_ERR "bd7885 read[%i] failed: %d\n", i, error);
+		msleep(10);
+	}
+    /* Do while an error exists and we haven't exceeded retry attempts */
+    } while ((error != BD7885_REG_DATA_LEN) && ((++i) < BD7885_I2C_RETRY_MAX));
+
+
+
+    /* On success, set error to E_OK (i2c_master_recv returns the number of bytes
+     *  transferred) */
+    if (error == BD7885_REG_DATA_LEN) {
+	error = E_OK;
+    }
+
+    return error;
+}
+
+static int bd7885_reg_write(struct i2c_client *client, u8 reg_addr, u8 reg_value)
+{
+    unsigned char value[BD7885_REG_ADDR_DATA_LEN];
+    int retval = 0;
+    int i =  BD7885_I2C_RETRY_MAX;
+    
+    /* Fail if the length is too small */
+    if ((reg_addr == BD7885_HW_ID_REG) || (reg_addr == BD7885_STATUS_REG) \
+		|| (reg_addr > BD7885_STATUS_REG)) {
+	printk(KERN_ERR "bd7885_reg_write: length is invalid\n");
+	return -EINVAL;
+    }
+
+    /* Fail if we weren't able to initialize (yet) */
+    if (client == NULL) {
+	printk(KERN_ERR "bd7885_reg_write: initialization failed\n");
+	return -EINVAL;
+    }
+
+    /* Copy the data into a buffer for correct format */
+    value[0] = reg_addr & 0xFF;
+    memcpy(&value[1], &reg_value, BD7885_REG_DATA_LEN);
+
+    /* Write the data to the device (retrying if necessary) */
+    do {
+	retval = i2c_master_send(client, value, BD7885_REG_ADDR_DATA_LEN);
+
+	/* On failure, output the error code and delay before trying again */
+	if (retval < 0) {
+		printk(KERN_ERR "bd7885 write 0x%X failed: %d\n",\
+				value[0], retval);
+		msleep(5);
+	}
+    } while ((retval < 0) && (i-- >= 0));
+
+    /* On success, set retval to 0 (i2c_master_send returns no. of bytes transfered) */
+    if (retval == BD7885_REG_ADDR_DATA_LEN) {
+	retval = 0;
+	/*Store write value to global status table.*/
+	bd7885_reg_status_tbl[reg_addr] = reg_value;
+    }
+
+    /* Delay after every I2C access or IC will NAK */
+    msleep(5);
+
+    return retval;
+}
+
+static int bd7885_reg_writes(struct i2c_client *client, const bd7885_cfg *reglist)
+{
+	int err = 0;
+	const bd7885_cfg *next = reglist;
+
+	while (!((next->reg == BD7885_REG_TERM)
+		&& (next->data == BD7885_VAL_TERM))) {
+		err = bd7885_reg_write(client, next->reg, next->data);
+		udelay(100);
+		if (err)
+			return err;
+		next++;
+	}
+	return 0;
+}
+
+/*
+It shoudl be called just one time.
+Because it include gpio request. If it is call many time, it makes error condition.
+*/
+static int bd7885_io_init(void)
+{
+    return 0;
+}
+
+#if defined(CONFIG_LEDS_BU9847)
+static int bd7885_quench_level_set(struct i2c_client *client,
+    unsigned char level)
+{
+    int ret = 0;
+
+    /*Quench level is from 1 to 12 if using bu9847.*/
+    if ((level < 1) || (level > 12))
+		return -1;
+
+    ret = bd7885_reg_write(client, BD7885_QUENCHADJ_REG,
+    bu9847_reg_info_tbl[BU9847_QCHC1_REG + level - 1]);
+
+    if (ret != 0) {
+		printk(KERN_ERR "bd7885_quench_level_set failed\n");
+		return -1;
+    }
+
+    return 0;
+}
+#endif/*CONFIG_LEDS_BU9847*/
+
+static int bd7885_charge_enable_sequence(struct i2c_client *client)
+{
+    printk(KERN_INFO "%s is called.\n", __FUNCTION__);
+
+    /*Register value write down for charge enable.*/
+    if (bd7885_reg_writes(client, bd7885_charege_enalbe_tbl) != 0) {
+	printk(KERN_ERR "bd7885_reg_writes failed\n");
+	return -EFAULT;
+    }
+
+    return 0;
+}
+
+int bd7885_charge_disable_sequence(struct i2c_client *client)
+{
+    printk(KERN_INFO "%s is called.\n", __FUNCTION__);
+
+    /*Register value write down for charge disable.*/
+    if (bd7885_reg_writes(client, bd7885_charge_disable_tbl) != 0) {
+	printk(KERN_ERR "bd7885_reg_writes failed\n");
+	return -EFAULT;
+    }
+
+    return 0;
+}
+
+static int bd7885_charge_enable(struct i2c_client *client)
+{
+
+    if (bd7885_charge_enable_sequence(client) != 0) {
+	printk(KERN_ERR "%s: bd7885_reg_writes failed\n", __FUNCTION__);
+	return -EFAULT;
+    }
+
+    return 0;
+}
+
+#if defined(CONFIG_LEDS_FLASH_RESET)
+bool bd7885_device_detection(void)
+{
+	u8 reg_val = 0;
+	int ret = 0;
+
+	/*Driver ID fetch and de*/
+	ret = bd7885_reg_read(bd7885_i2c_client, BD7885_HW_ID_REG, &reg_val);
+
+	if (ret != 0) {
+		printk(KERN_ERR "Xenon flash HW ID read fail\n");
+		return false;
+	}
+
+	if (reg_val == BD7885_HW_ID_VAL)
+		return true;
+
+	return false;
+}
+#endif
+
+/* *****************************************************
+
+	Probe, Remove
+
+* ******************************************************/
+static int bd7885_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct bd7885_chip *chip;
+	int ret = 0;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE))  {
+		ret  = -ENODEV;
+		goto exit_check_functionality_failed;
+	}
+
+       bd7885_i2c_client = client;
+
+	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
+	if (!chip)	{
+		return -ENOMEM;
+	}
+
+	printk(KERN_INFO "BD7885 driver: bd7885_probe()\n");
+
+	chip->client = client;
+	strncpy(client->name, BD7885_DRIVER_NAME, I2C_NAME_SIZE);
+	i2c_set_clientdata(client, chip);
+
+       ret = misc_register(&bd7885_device);
+	if (ret != 0)
+		printk(KERN_INFO "misc_register failed\n");
+
+	mutex_init(&chip->lock);
+
+	printk(KERN_INFO "BD7885 chip probe is finished.\n");
+
+	return ret;
+
+exit_check_functionality_failed:
+	return ret;
+}
+
+static int bd7885_remove(struct i2c_client *client)
+{
+	struct bd7885_chip *chip = i2c_get_clientdata(client);
+
+	printk(KERN_INFO "bd7885_remove() is called!\n");
+	kfree(chip);
+
+	return 0;
+}
+
+static const struct i2c_device_id bd7885_id[] = {
+	{ BD7885_DRIVER_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, bd7885_id);
+
+static struct i2c_driver bd7885_driver = {
+	.driver = {
+		.name = BD7885_DRIVER_NAME,
+	},
+	.probe	  = bd7885_probe,
+	.remove	  = __devexit_p(bd7885_remove),
+	.id_table = bd7885_id,
+};
+
+static int bd7885_open(struct inode *inode, struct file *file)
+{
+	unsigned char reg_cnt = 0;
+
+	for (reg_cnt = 0; reg_cnt <= BD7885_STATUS_REG; reg_cnt++) {
+		if (bd7885_reg_read(bd7885_i2c_client, reg_cnt,\
+					&bd7885_reg_status_tbl[reg_cnt]) != 0) {
+			printk(KERN_ERR "bd7885_read failed. addr = %d\n",\
+					reg_cnt);
+			return -EFAULT;
+		}
+	}
+
+	printk(KERN_INFO "%s is called.\n",\
+					__func__);
+	return nonseekable_open(inode, file);
+}
+
+static int bd7885_release(struct inode *inode, struct file *file)
+{
+  printk(KERN_INFO "%s is called.\n", __FUNCTION__);
+  return 0;
+}
+
+static int bd7885_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+    void __user *argp = (void __user *)arg;
+    unsigned char rwbuf, data1, data2;
+    bd7885_cfg rw_reg_buf;
+
+    int error = E_OK;
+
+    /* get information from user */
+    switch (cmd) {
+    case BD7885_IOCTL_GET_REGISTER:
+    case BD7885_IOCTL_SET_REGISTER:
+      if (copy_from_user(&rw_reg_buf, argp, sizeof(rw_reg_buf)))
+	return -EFAULT;
+	break;
+
+    case BD7885_IOCTL_SET_CHARGING:
+    case BD7885_IOCTL_SET_CHARGE_LEVEL:
+    case BD7885_IOCTL_SET_MODE:
+    case BD7885_IOCTL_SET_QUENCH_THRESHOLD:
+    case BD7885_IOCTL_GET_STATUS:
+    case BD7885_IOCTL_READY_STROBE_MANUAL:
+    case BD7885_IOCTL_FIRE_STROBE_MANUAL:
+      if (copy_from_user(&rwbuf, argp, sizeof(rwbuf)))
+		return -EFAULT;
+      break;
+
+    default:
+      printk(KERN_ERR "Abnormal value input = %d.\n", cmd);
+      break;
+    }
+
+    printk(KERN_ERR "BD7785_cmd = %d.\n", cmd);
+
+    /* interact with driver */
+    switch (cmd) {
+    case BD7885_IOCTL_GET_REGISTER:
+	printk(KERN_ERR "BD7785_cmd = BD7885_IOCTL_GET_REGISTER is called.\n");
+       error = bd7885_reg_read(bd7885_i2c_client, rw_reg_buf.reg,\
+							&rw_reg_buf.data);
+	if (error != 0) {
+		printk(KERN_ERR "bd7885_read failed. addr = %d\n",\
+						rw_reg_buf.reg);
+		return error;
+	}
+      break;
+
+    case BD7885_IOCTL_SET_REGISTER:
+	printk(KERN_ERR "BD7785_cmd = BD7885_IOCTL_SET_REGISTER is called.\n");
+
+	error = bd7885_reg_write(bd7885_i2c_client, rw_reg_buf.reg,\
+							rw_reg_buf.data);
+	if (error != 0) {
+		printk(KERN_ERR "bd7885_read failed. addr = %d\n",\
+						rw_reg_buf.reg);
+		return error;
+	}
+	break;
+
+    case BD7885_IOCTL_SET_CHARGING:
+	printk(KERN_ERR "BD7785_cmd = BD7885_IOCTL_SET_CHARGING is called.\n");
+
+	if (rwbuf == BD7885_CHARGE_ENABLE) {
+		error = bd7885_charge_enable(bd7885_i2c_client);
+		if (error != 0) {
+			printk(KERN_ERR "BD7885 cmd = %d\n", cmd);
+			return error;
+		}
+
+	} else if (rwbuf == BD7885_CHARGE_DISABLE) {
+		error = bd7885_charge_disable_sequence(bd7885_i2c_client);
+		if (error != 0) {
+			printk(KERN_ERR "BD7885 cmd = %d\n", cmd);
+			return error;
+		}
+	} else {
+		printk(KERN_ERR "BD7885 charging status abnormal.\n");
+		return -EFAULT;
+	}
+	break;
+
+    case BD7885_IOCTL_SET_CHARGE_LEVEL:
+	printk(KERN_ERR "BD7785_cmd = BD7885_IOCTL_SET_CHARGE_LEVEL is called.\n");
+
+	rwbuf &= BD7885_FULL_ADJ_LVL_MASK;
+       /*Apply FULLADJ setting.*/
+       error = bd7885_reg_write(bd7885_i2c_client, BD7885_FULLADJ_REG, rwbuf);
+	if (error != 0) {
+		printk(KERN_ERR "BD7885 cmd = %d write failure.\n", cmd);
+		return error;
+	}
+	break;
+
+    case BD7885_IOCTL_GET_STATUS:
+	printk(KERN_ERR "BD7785_cmd = BD7885_IOCTL_GET_STATUS is called.\n");
+
+       error = bd7885_reg_read(bd7885_i2c_client, BD7885_STATUS_REG, &rwbuf);
+	if (error != 0) {
+		printk(KERN_ERR "BD7885 cmd = %d write failure.\n", cmd);
+		return error;
+	}
+	break;
+
+    case BD7885_IOCTL_SET_MODE:
+	printk(KERN_ERR "BD7785_cmd = BD7885_IOCTL_SET_MODE is called.\n");
+
+       /*Apply Mode setting.*/
+       if (rwbuf == BD7885_STROBE_QUENCH_MODE) {
+		/* Set QUENCH_EN, Set PCNT_EN */
+		data1 = bd7885_reg_status_tbl[BD7885_QUENCHCNT_REG] | \
+				BD7885_QUENCH_EN_MASK;
+		data2 = bd7885_reg_status_tbl[BD7885_DRVCNT_REG] | \
+				BD7885_PCNT_EN_MASK;
+       }
+      else if (rwbuf == BD7885_STROBE_MANUAL_MODE) {
+		/* Clr QUENCH_EN, Set PCNT_EN */
+		data1 = bd7885_reg_status_tbl[BD7885_QUENCHCNT_REG] & \
+				(~BD7885_QUENCH_EN_MASK);
+		data2 = bd7885_reg_status_tbl[BD7885_DRVCNT_REG] | \
+				BD7885_PCNT_EN_MASK;
+      }
+       else {
+		/* Clr QUENCH_EN & PCNT_EN */
+		data1 = bd7885_reg_status_tbl[BD7885_QUENCHCNT_REG] & \
+				(~BD7885_QUENCH_EN_MASK);
+		data2 = bd7885_reg_status_tbl[BD7885_DRVCNT_REG] & \
+				(~BD7885_PCNT_EN_MASK);
+       }
+
+       error = bd7885_reg_write(bd7885_i2c_client, BD7885_QUENCHCNT_REG, data1);
+       error |= bd7885_reg_write(bd7885_i2c_client, BD7885_DRVCNT_REG, data2);
+	if (error != 0) {
+		printk(KERN_ERR "BD7885 cmd = %d write failure.\n", cmd);
+		return error;
+	}
+       break;
+
+    case BD7885_IOCTL_SET_QUENCH_THRESHOLD:
+	printk(KERN_ERR "BD7785_cmd = BD7885_IOCTL_SET_QUENCH_THRESHOLD is called.\n");
+
+       /*Apply VSTOPADJ & PTR value to Xenon flash.*/
+#if defined(CONFIG_LEDS_BU9847)
+	   /*Quench level fetch from EEPROM.*/
+		   error = bu9847_fetch_regs();
+		   if (error != 0)
+				return error;
+
+       /*Quench level fetch from EEPROM.*/
+       if (rwbuf != 0) {
+		/*Enable PCNT_EN*/
+		data1 = bd7885_reg_status_tbl[BD7885_DRVCNT_REG] | \
+				BD7885_PCNT_EN_MASK;
+		error = bd7885_reg_write(bd7885_i2c_client, \
+				BD7885_DRVCNT_REG, data1);
+		error |= bd7885_quench_level_set(bd7885_i2c_client, rwbuf);
+       } else {
+		/*Disable PCNT_EN*/
+		data1 = bd7885_reg_status_tbl[BD7885_DRVCNT_REG] & \
+				(~BD7885_PCNT_EN_MASK);
+		error = bd7885_reg_write(bd7885_i2c_client, \
+				BD7885_DRVCNT_REG, data1);
+       }
+	if (error != 0) {
+		printk(KERN_ERR "BD7885 cmd = %d write failure.\n", cmd);
+		return error;
+	}
+#endif
+	break;
+
+    case BD7885_IOCTL_READY_STROBE_MANUAL:
+		ov8810_strobe_manual_ready();
+	break;
+
+    case BD7885_IOCTL_FIRE_STROBE_MANUAL:
+		ov8810_strobe_manual_trigger();
+	break;
+
+    default:
+      return -ENOTTY;
+    }
+
+    /* return information to user */
+    switch (cmd) {
+    case BD7885_IOCTL_GET_REGISTER:
+	printk(KERN_ERR "BD7785_cmd = BD7885_IOCTL_GET_REGISTER copy to user.\n");
+
+      if (copy_to_user(argp, &rw_reg_buf, sizeof(rw_reg_buf)))
+	return -EFAULT;
+      break;
+
+    case BD7885_IOCTL_GET_STATUS:
+	printk(KERN_ERR "BD7785_cmd = BD7885_IOCTL_GET_STATUS copy to user.\n");
+	printk(KERN_ERR "status value = %d\n", rwbuf);
+
+      if (copy_to_user(argp, &rwbuf, sizeof(rwbuf)))
+	return -EFAULT;
+      break;
+
+    default:
+      break;
+    }
+
+    return error;
+}
+
+/*
+ *  BD7885 voltage regulator init
+ */
+static int __init bd7885_init(void)
+{
+    int ret = -EFAULT;
+
+    ret = i2c_add_driver(&bd7885_driver);
+    if (ret != 0) {
+	printk(KERN_INFO "BD7885 init failed.\n");
+    }
+    printk(KERN_INFO "BD7885 i2c driver : init is completed.\n");
+
+    /*Base IO initialize.*/
+    bd7885_io_init();
+
+    return ret;
+}
+
+static void __exit bd7885_exit(void)
+{
+	i2c_del_driver(&bd7885_driver);
+
+	printk(KERN_INFO "BD7885  flash driver: exit\n");
+}
+
+module_init(bd7885_init);
+module_exit(bd7885_exit);
+
+MODULE_AUTHOR("Motorola");
+MODULE_DESCRIPTION("BD7885 flash regulator driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/leds/leds-bu9847.c b/drivers/leds/leds-bu9847.c
new file mode 100644
index 0000000..282a393
--- /dev/null
+++ b/drivers/leds/leds-bu9847.c
@@ -0,0 +1,297 @@
+/*
+ * drivers/i2c/chips/leds-bu9847.c
+ *
+ * I2C slave driver for BU9847 device
+ *
+ * Copyright (C) 2008-2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Revision History:
+ *
+ * Date          Author    Comment
+ * -----------   --------  -------------------
+ * Jun-24-2008   Motorola  Initial version
+ *
+ */
+
+#include <linux/kernel.h>	/* printk() */
+#include <linux/fs.h>		/* everything... */
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/cdev.h>
+#include <asm/gpio.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <asm/uaccess.h>
+#include <linux/miscdevice.h>
+
+#include "linux/leds-bu9847.h"
+
+static int bu9847_open(struct inode *inode, struct file *file);
+static int bu9847_release(struct inode *inode, struct file *file);
+static int bu9847_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
+
+typedef struct {
+	unsigned char reg;
+	unsigned char	   data;
+} bu9847_cfg;
+
+struct bu9847_chip {
+	struct mutex lock;
+	struct i2c_client *client;
+	int status;               /* flag indicate chip current power state */
+};
+
+struct file_operations bu9847_fops = {
+	.owner   = THIS_MODULE,
+	.open    = bu9847_open,
+	.release = bu9847_release,
+	.ioctl   = bu9847_ioctl,
+};
+
+static struct miscdevice bu9847_device = {
+  .minor = MISC_DYNAMIC_MINOR,
+  .name = BU9847_DEVICE_NAME,
+  .fops = &bu9847_fops,
+};
+
+/*for register value keep here.*/
+char bu9847_reg_info_tbl[18] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+
+/* for ioctl */
+struct i2c_client *bu9847_i2c_client;
+
+/* device major number */
+int bu9847_major_num = 0;
+int bu9847_minor_num = 0;
+
+#define BU9847_I2C_RETRY_MAX 3
+
+/* *****************************************************
+
+	Low level interface routine.
+
+* *****************************************************/
+static int bu9847_reg_read(struct i2c_client *client, u8 reg_addr, u8 *buf)
+{
+    /** \var error
+     *  \brief Return error code, initialized to no error
+     */
+    int error = E_OK;
+    /** \var i
+     *  \brief Retry counter
+     */
+    int i = 0;
+    unsigned char value[BU9847_REG_DATA_LEN];
+
+    /* If number of bytes is out of range or buffer is incorrect, report, exit */
+    if ((buf == NULL) || (reg_addr > BU9847_PRLDT_REG)) {
+	printk(KERN_ERR "invalid read parameter(s)\n");
+	return -EINVAL;
+    }
+    /* If I2C client doesn't exist */
+    if (client == NULL) {
+	printk(KERN_ERR "bu9847 null i2c read client\n");
+	return -EUNATCH;
+    }
+
+	/* Do read */
+    do {
+	/* Establish read address
+	*  i2c_master_send returns either the number of bytes sent or negative error from
+	*  i2c_transfer
+	*/
+	/* Copy the data into a buffer for correct format */
+	value[0] = reg_addr & 0xFF;
+	error = i2c_master_send(client, value , BU9847_REG_DATA_LEN);
+	/* Read data if send address succeeded (i2c_master_send returns the number
+	*  of bytes transferred) */
+	if (error == BU9847_REG_DATA_LEN) {
+		/* Retreive data
+		*  i2c_master_recv returns either the number of bytes received or negative error
+		*  from i2c_transfer
+		*/
+		error = i2c_master_recv(client, buf, BU9847_REG_DATA_LEN);
+	} else {
+		printk(KERN_ERR "bu9847 write of address %d failed: %d\n", value[0], error);
+	}
+
+	/* On failure (error will contain num_bytes if succeeded), print error code and
+	* delay before trying again */
+        if (error != BU9847_REG_DATA_LEN) {
+		printk(KERN_ERR "bu9847 read[%i] failed: %d\n", i, error);
+		msleep(10);
+	}
+    /* Do while an error exists and we haven't exceeded retry attempts */
+    } while ((error != BU9847_REG_DATA_LEN) && ((++i) < 5));
+
+    /* On success, set error to E_OK (i2c_master_recv returns the number of bytes
+     *  transferred) */
+    if (error == BU9847_REG_DATA_LEN)
+	error = E_OK;
+
+    return error;
+}
+
+int bu9847_fetch_regs(void)
+{
+    unsigned char reg_cnt = 0;
+    unsigned int ret = 0;
+
+    /*Read out status register information.*/
+    for (reg_cnt = BU9847_HW_ID_REG; reg_cnt <= BU9847_PRLDT_REG; reg_cnt++) {
+	ret = bu9847_reg_read(bu9847_i2c_client, reg_cnt, &bu9847_reg_info_tbl[reg_cnt]);
+	if (ret != 0) {
+		printk(KERN_INFO "bu9847_reg_read_filed. reg_addr = %d\n", reg_cnt);
+		return ret;
+	}
+    }
+
+    return 0;
+}
+
+/* *****************************************************
+
+	Probe, Remove
+
+* ******************************************************/
+static int bu9847_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct bu9847_chip *chip;
+	int ret = 0;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE)) {
+		ret  = -ENODEV;
+		goto exit_check_functionality_failed;
+	}
+
+       bu9847_i2c_client = client;
+
+	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+
+	printk(KERN_INFO "BU9847 driver: bu9847_probe()\n");
+
+	chip->client = client;
+	strncpy(client->name, BU9847_DRIVER_NAME, I2C_NAME_SIZE);
+	i2c_set_clientdata(client, chip);
+
+#if 0
+       ret = i2c_attach_client(client);
+       if (ret != 0)
+	    printk(KERN_INFO "i2c_attach_client failed\n");
+#endif
+
+       ret = misc_register(&bu9847_device);
+       if (ret != 0)
+	    printk(KERN_INFO "misc_register failed\n");
+
+	mutex_init(&chip->lock);
+
+	printk(KERN_INFO "BU9847 chip probe is finished.\n");
+
+	return ret;
+
+exit_check_functionality_failed:
+	return ret;
+}
+
+static int bu9847_remove(struct i2c_client *client)
+{
+	struct bu9847_chip *chip = i2c_get_clientdata(client);
+
+	printk(KERN_INFO "bu9847_remove() is called!\n");
+	kfree(chip);
+
+	return 0;
+}
+
+static const struct i2c_device_id bu9847_id[] = {
+	{ BU9847_DRIVER_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, bu9847_id);
+
+static struct i2c_driver bu9847_driver = {
+	.driver = {
+		.name = BU9847_DRIVER_NAME,
+	},
+	.probe	  = bu9847_probe,
+	.remove	  = __devexit_p(bu9847_remove),
+	.id_table = bu9847_id,
+};
+
+static int bu9847_open(struct inode *inode, struct file *file)
+{
+  printk(KERN_INFO "%s is called.\n", __FUNCTION__);
+  return nonseekable_open(inode, file);
+}
+
+static int bu9847_release(struct inode *inode, struct file *file)
+{
+  printk(KERN_INFO "%s is called.\n", __FUNCTION__);
+  return 0;
+}
+static int bu9847_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+    int ret = 0;
+
+    /* Do the handling. */
+    switch (cmd) {
+	case BU9847_IOCTL_INIT:
+		/*EEPROM data fetch from HW.*/
+		ret = bu9847_fetch_regs();
+	break;
+
+	default:
+		printk(KERN_INFO "%s's default called. %d\n", __FUNCTION__, cmd);
+	break;
+    }
+
+    return ret;
+}
+/*
+ *  BU9847 voltage regulator init
+ */
+static int __init bu9847_init(void)
+{
+    int ret = -1;
+
+    ret = i2c_add_driver(&bu9847_driver);
+    if (ret != 0)
+	printk(KERN_INFO "BU9847 init failed.\n");
+
+     printk(KERN_INFO "BU9847 i2c driver : init is completed.\n");
+
+    return ret;
+}
+
+static void __exit bu9847_exit(void)
+{
+	i2c_del_driver(&bu9847_driver);
+
+	printk(KERN_INFO "BU9847  flash driver: exit\n");
+}
+
+module_init(bu9847_init);
+module_exit(bu9847_exit);
+
+MODULE_AUTHOR("Motorola");
+MODULE_DESCRIPTION("BU9847 flash regulator driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/leds/leds-ld-cpcap-afled.c b/drivers/leds/leds-ld-cpcap-afled.c
new file mode 100644
index 0000000..29bea70
--- /dev/null
+++ b/drivers/leds/leds-ld-cpcap-afled.c
@@ -0,0 +1,174 @@
+/*
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free dispware; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free dispware Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free dispware
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+ * 02111-1307, USA
+ */
+
+#include <linux/err.h>
+#include <linux/leds.h>
+#include <linux/leds-ld-cpcap.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/spi/cpcap.h>
+#include <linux/spi/cpcap-regbits.h>
+
+struct af_led_data {
+	struct led_classdev af_led_class_dev;
+	struct cpcap_device *cpcap;
+	struct regulator *regulator;
+	int regulator_state;
+};
+
+static void af_led_set(struct led_classdev *led_cdev,
+			    enum led_brightness value)
+{
+	unsigned short brightness = 0;
+	int cpcap_status = 0;
+	struct af_led_data *af_led_data =
+	    container_of(led_cdev, struct af_led_data,
+			 af_led_class_dev);
+
+	if (value > 0) {
+		/*Set max bright level.*/
+		/* need to add dynamic control */
+		brightness = LD_MSG_IND_CPCAP_MASK >> 2;
+
+		if ((af_led_data->regulator) &&
+		    (af_led_data->regulator_state == 0)) {
+			regulator_enable(af_led_data->regulator);
+			af_led_data->regulator_state = 1;
+		}
+
+		/*cpcap_uc_stop(af_led_data->cpcap, CPCAP_MACRO_6);*/
+
+		cpcap_status = cpcap_regacc_write(af_led_data->cpcap,
+			CPCAP_REG_REDC, brightness, LD_MSG_IND_CPCAP_MASK);
+		if (cpcap_status < 0)
+			pr_err("%s: Writing to the register failed for %i\n",
+			       __func__, cpcap_status);
+	} else {
+		if ((af_led_data->regulator) &&
+		    (af_led_data->regulator_state == 1)) {
+			regulator_disable(af_led_data->regulator);
+			af_led_data->regulator_state = 0;
+		}
+
+		/* Due to a HW issue turn off the current then
+		turn off the duty cycle */
+		brightness = 1;
+
+		/*cpcap_uc_start(af_led_data->cpcap, CPCAP_MACRO_6);*/
+		/*cpcap_uc_start(af_led_data->cpcap, CPCAP_MACRO_4);*/
+
+		cpcap_status = cpcap_regacc_write(af_led_data->cpcap,
+			CPCAP_REG_REDC, brightness, LD_MSG_IND_CPCAP_MASK);
+		if (cpcap_status < 0)
+			pr_err("%s: Writing to the register failed for %i\n",
+			       __func__, cpcap_status);
+
+		brightness = 0;
+
+		cpcap_status = cpcap_regacc_write(af_led_data->cpcap,
+			CPCAP_REG_REDC, brightness, LD_MSG_IND_CPCAP_MASK);
+		if (cpcap_status < 0)
+			pr_err("%s: Writing to the register failed for %i\n",
+			       __func__, cpcap_status);
+	}
+
+}
+EXPORT_SYMBOL(af_led_set);
+
+static int af_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct af_led_data *info;
+
+	if (pdev == NULL) {
+		pr_err("%s: platform data required\n", __func__);
+		return -ENODEV;
+	}
+
+	info = kzalloc(sizeof(struct af_led_data), GFP_KERNEL);
+	if (info == NULL) {
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	info->cpcap = pdev->dev.platform_data;
+	platform_set_drvdata(pdev, info);
+
+	info->regulator = regulator_get(&pdev->dev, LD_SUPPLY);
+	if (IS_ERR(info->regulator)) {
+		pr_err("%s: Cannot get %s regulator\n", __func__, LD_SUPPLY);
+		ret = PTR_ERR(info->regulator);
+		goto exit_request_reg_failed;
+
+	}
+
+	info->regulator_state = 0;
+
+	info->af_led_class_dev.name = "af-led";
+	info->af_led_class_dev.brightness_set = af_led_set;
+	ret = led_classdev_register(&pdev->dev, &info->af_led_class_dev);
+	if (ret < 0) {
+		pr_err("%s:Register Auto focus LED class failed\n", __func__);
+		goto err_reg_af_led_class_failed;
+	}
+
+	return ret;
+
+err_reg_af_led_class_failed:
+	if (info->regulator)
+		regulator_put(info->regulator);
+exit_request_reg_failed:
+	kfree(info);
+	return ret;
+}
+
+static int af_remove(struct platform_device *pdev)
+{
+	struct af_led_data *info = platform_get_drvdata(pdev);
+
+	if (info->regulator)
+		regulator_put(info->regulator);
+
+	led_classdev_unregister(&info->af_led_class_dev);
+	return 0;
+}
+
+static struct platform_driver ld_af_driver = {
+	.probe = af_probe,
+	.remove = af_remove,
+	.driver = {
+		   .name = LD_AF_LED_DEV,
+		   },
+};
+
+static int __init led_af_init(void)
+{
+	return platform_driver_register(&ld_af_driver);
+}
+
+static void __exit led_af_exit(void)
+{
+	platform_driver_unregister(&ld_af_driver);
+}
+
+module_init(led_af_init);
+module_exit(led_af_exit);
+
+MODULE_DESCRIPTION("AF LED driver");
+MODULE_AUTHOR("Motorola");
+MODULE_LICENSE("GPL");
diff --git a/drivers/leds/leds-ld-cpcap-disp.c b/drivers/leds/leds-ld-cpcap-disp.c
old mode 100755
new mode 100644
index ecd5318..de69fb2
--- a/drivers/leds/leds-ld-cpcap-disp.c
+++ b/drivers/leds/leds-ld-cpcap-disp.c
@@ -27,8 +27,10 @@
 struct disp_button_led_data {
 	struct led_classdev disp_button_class_dev;
 	struct cpcap_device *cpcap;
+#ifndef CONFIG_LEDS_SHOLEST
 	struct regulator *regulator;
 	int regulator_state;
+#endif
 };
 
 static void disp_button_set(struct led_classdev *led_cdev,
@@ -41,6 +43,10 @@ static void disp_button_set(struct led_classdev *led_cdev,
 			 disp_button_class_dev);
 
 	if (value > 0) {
+#ifdef CONFIG_LEDS_SHOLEST
+		brightness = (LD_BLED_CPCAP_DUTY_CYCLE |
+			LD_BLED_CPCAP_CURRENT | LD_DISP_BUTTON_ON);
+#else
 		brightness = (LD_DISP_BUTTON_DUTY_CYCLE |
 			LD_DISP_BUTTON_CURRENT | LD_DISP_BUTTON_ON);
 
@@ -49,34 +55,53 @@ static void disp_button_set(struct led_classdev *led_cdev,
 			regulator_enable(disp_button_led_data->regulator);
 			disp_button_led_data->regulator_state = 1;
 		}
+#endif
 
+#ifdef CONFIG_LEDS_SHOLEST
+		cpcap_status = cpcap_regacc_write(disp_button_led_data->cpcap,
+						  CPCAP_REG_BLEDC,
+						  brightness,
+						  LD_BLED_CPCAP_MASK);
+#else
 		cpcap_status = cpcap_regacc_write(disp_button_led_data->cpcap,
 						  CPCAP_REG_KLC,
 						  brightness,
 						  LD_DISP_BUTTON_CPCAP_MASK);
-
+#endif
 		if (cpcap_status < 0)
 			pr_err("%s: Writing to the register failed for %i\n",
 			       __func__, cpcap_status);
 
 	} else {
+#ifndef CONFIG_LEDS_SHOLEST
 		if ((disp_button_led_data->regulator) &&
 		    (disp_button_led_data->regulator_state == 1)) {
 			regulator_disable(disp_button_led_data->regulator);
 			disp_button_led_data->regulator_state = 0;
 		}
+#endif
 		/* Due to a HW issue turn off the current then
 		turn off the duty cycle */
 		brightness = 0x01;
+#ifdef CONFIG_LEDS_SHOLEST
 		cpcap_status = cpcap_regacc_write(disp_button_led_data->cpcap,
-					  CPCAP_REG_KLC, brightness,
-					  LD_DISP_BUTTON_CPCAP_MASK);
-
+						  CPCAP_REG_BLEDC, brightness,
+						  LD_BLED_CPCAP_MASK);
+#else
+		cpcap_status = cpcap_regacc_write(disp_button_led_data->cpcap,
+						  CPCAP_REG_KLC, brightness,
+						  LD_DISP_BUTTON_CPCAP_MASK);
+#endif
 		brightness = 0x00;
+#ifdef CONFIG_LEDS_SHOLEST
+		cpcap_status = cpcap_regacc_write(disp_button_led_data->cpcap,
+						  CPCAP_REG_BLEDC, brightness,
+						  LD_BLED_CPCAP_MASK);
+#else
 		cpcap_status = cpcap_regacc_write(disp_button_led_data->cpcap,
 						  CPCAP_REG_KLC, brightness,
 						  LD_DISP_BUTTON_CPCAP_MASK);
-
+#endif
 		if (cpcap_status < 0)
 			pr_err("%s: Writing to the register failed for %i\n",
 			       __func__, cpcap_status);
@@ -104,6 +129,7 @@ static int disp_button_probe(struct platform_device *pdev)
 	info->cpcap = pdev->dev.platform_data;
 	platform_set_drvdata(pdev, info);
 
+#ifndef CONFIG_LEDS_SHOLEST
 	info->regulator = regulator_get(&pdev->dev, LD_SUPPLY);
 	if (IS_ERR(info->regulator)) {
 		pr_err("%s: Cannot get %s regulator\n", __func__, LD_SUPPLY);
@@ -113,6 +139,7 @@ static int disp_button_probe(struct platform_device *pdev)
 	}
 
 	info->regulator_state = 0;
+#endif
 
 	info->disp_button_class_dev.name = "button-backlight";
 	info->disp_button_class_dev.brightness_set = disp_button_set;
@@ -125,8 +152,10 @@ static int disp_button_probe(struct platform_device *pdev)
 	return ret;
 
 err_reg_button_class_failed:
+#ifndef CONFIG_LEDS_SHOLEST
 	if (info->regulator)
 		regulator_put(info->regulator);
+#endif
 exit_request_reg_failed:
 	kfree(info);
 	return ret;
@@ -136,8 +165,10 @@ static int disp_button_remove(struct platform_device *pdev)
 {
 	struct disp_button_led_data *info = platform_get_drvdata(pdev);
 
+#ifndef CONFIG_LEDS_SHOLEST
 	if (info->regulator)
 		regulator_put(info->regulator);
+#endif
 
 	led_classdev_unregister(&info->disp_button_class_dev);
 	return 0;
diff --git a/drivers/leds/leds-ld-cpcap-kpad.c b/drivers/leds/leds-ld-cpcap-kpad.c
old mode 100755
new mode 100644
diff --git a/drivers/leds/leds-ld-cpcap-rgb.c b/drivers/leds/leds-ld-cpcap-rgb.c
old mode 100755
new mode 100644
index c0406c6..0b4131f
--- a/drivers/leds/leds-ld-cpcap-rgb.c
+++ b/drivers/leds/leds-ld-cpcap-rgb.c
@@ -36,12 +36,20 @@ struct msg_ind_led_data {
 void msg_ind_set_rgb_brightness(struct msg_ind_led_data *msg_ind_data,
 				int color, enum led_brightness value)
 {
+#ifdef CONFIG_LEDS_SHOLEST
+	unsigned short brightness = LD_MSG_IND_LO_CURRENT | LD_MSG_IND_ON;
+#else
 	unsigned short brightness = LD_MSG_IND_CURRENT | LD_MSG_IND_ON;
+#endif
 	int cpcap_status = 0;
 	int cpcap_register = 0;
 
 	if (color & LD_LED_RED)
+#ifdef CONFIG_LEDS_SHOLEST
+        cpcap_register = CPCAP_REG_ADLC;
+#else
 		cpcap_register = CPCAP_REG_REDC;
+#endif
 	else if (color & LD_LED_GREEN)
 		cpcap_register = CPCAP_REG_GREENC;
 	else if (color & LD_LED_BLUE)
@@ -56,7 +64,25 @@ void msg_ind_set_rgb_brightness(struct msg_ind_led_data *msg_ind_data,
 					  LD_MSG_IND_CPCAP_MASK);
 
 		brightness = 0x00;
-	} else if (value <= 51)
+	}
+#ifdef CONFIG_LEDS_SHOLEST
+	else if (value <= 51)
+		brightness |= (LD_MSG_IND_LOW << \
+				((cpcap_register == CPCAP_REG_ADLC) << 1));
+	else if (value <= 104)
+		brightness |= (LD_MSG_IND_LOW_MED << \
+				((cpcap_register == CPCAP_REG_ADLC) << 1));
+	else if (value <= 155)
+		brightness |= (LD_MSG_IND_MEDIUM << \
+				((cpcap_register == CPCAP_REG_ADLC) << 1));
+	else if (value <= 201)
+		brightness |= (LD_MSG_IND_MED_HIGH << \
+				((cpcap_register == CPCAP_REG_ADLC) << 1));
+	else
+		brightness |= (LD_MSG_IND_HIGH << \
+				((cpcap_register == CPCAP_REG_ADLC) << 1));
+#else
+    else if (value <= 51)
 		brightness |= LD_MSG_IND_LOW;
 	else if (value <= 104)
 		brightness |= LD_MSG_IND_LOW_MED;
@@ -66,6 +92,7 @@ void msg_ind_set_rgb_brightness(struct msg_ind_led_data *msg_ind_data,
 		brightness |= LD_MSG_IND_MED_HIGH;
 	else
 		brightness |= LD_MSG_IND_HIGH;
+#endif
 
 	cpcap_status = cpcap_regacc_write(msg_ind_data->cpcap,
 					  cpcap_register, brightness,
diff --git a/drivers/media/dvb/siano/Kconfig b/drivers/media/dvb/siano/Kconfig
index dd863f2..80a4dfa 100644
--- a/drivers/media/dvb/siano/Kconfig
+++ b/drivers/media/dvb/siano/Kconfig
@@ -2,25 +2,68 @@
 # Siano Mobile Silicon Digital TV device configuration
 #
 
-config DVB_SIANO_SMS1XXX
-	tristate "Siano SMS1XXX USB dongle support"
-	depends on DVB_CORE && USB
+# w21558, SPI interface between OMAP and SMS1130
+config MOT_FEAT_SPI_SMS1130
+	bool "Siano and OMAP SPI interface support"
+	default n
+
+config SMS_SIANO_MDTV_TDMB
+	tristate "Siano SMS1xxx based MDTV receiver"
+	default n
+	---help---
+	Choose Y or M here if you have MDTV receiver with a Siano chipset.
+	To compile this driver as a module, choose M here
+	(The modules will be called smsmdtv).
+	Note: All dependents, if selected, will be part of this module.
+	Further documentation on this driver can be found on the WWW at http://www.siano-ms.com/
+
+if SMS_SIANO_MDTV_TDMB
+menu "Siano module components"
+
+# Kernel sub systems support
+
+config SMS_DVB3_SUBSYS
+	bool "DVB v.3 Subsystem support"
+	default n
+	---help---
+	Choose
+
+config SMS_HOSTLIB_SUBSYS
+	bool "Host Library Subsystem support."
+	default n
+	---help---
+	Choose if you would like to have Siano's host library kernel sub-system support.
+
+if SMS_HOSTLIB_SUBSYS
+
+config SMS_NET_SUBSYS
+	bool "Siano Network Adapter"
+	default n
 	---help---
-	  Choose Y here if you have a USB dongle with a SMS1XXX chipset.
+	Choose if you would like to have Siano's network adapter support.
+
+endif # SMS_HOSTLIB_SUBSYS
 
-	  To compile this driver as a module, choose M here: the
-	  module will be called sms1xxx.
+# Hardware interfaces support
 
-config DVB_SIANO_SMS1XXX_SMS_IDS
-	bool "Enable support for Siano Mobile Silicon default USB IDs"
-	depends on DVB_SIANO_SMS1XXX
-	default y
+config SMS_SPI_DRV
+	bool "SPI interface support"
+	default n
 	---help---
-	  Choose Y here if you have a USB dongle with a SMS1XXX chipset
-	  that uses Siano Mobile Silicon's default usb vid:pid.
+	Choose if you would like to have Siano's support for OMAP34XX SPI interface
+
+config SMS_USB_DRV
+        bool "USB inteface support"
+        default n
+        ---help---
+        Choose
 
-	  Choose N here if you would prefer to use Siano's external driver.
+config SMS_SDIO_DRV
+        bool "SDIO interface support"
+        default n
+        ---help---
+        Choose
 
-	  Further documentation on this driver can be found on the WWW at
-	  <http://www.siano-ms.com/>.
+endmenu
+endif # SMS_SIANO_MDTV_TDMB
 
diff --git a/drivers/media/dvb/siano/Makefile b/drivers/media/dvb/siano/Makefile
index ee0737a..f2fcbc0 100644
--- a/drivers/media/dvb/siano/Makefile
+++ b/drivers/media/dvb/siano/Makefile
@@ -1,8 +1,42 @@
-sms1xxx-objs := smscoreapi.o smsusb.o smsdvb.o sms-cards.o
+#sms1xxx-objs := smscoreapi.o smsusb.o smsdvb.o sms-cards.o
 
-obj-$(CONFIG_DVB_SIANO_SMS1XXX) += sms1xxx.o
+#obj-$(CONFIG_DVB_SIANO_SMS1XXX) += sms1xxx.o
 
-EXTRA_CFLAGS += -Idrivers/media/dvb/dvb-core
+#EXTRA_CFLAGS += -Idrivers/media/dvb/dvb-core
 
-EXTRA_CFLAGS += $(extra-cflags-y) $(extra-cflags-m)
+#EXTRA_CFLAGS += $(extra-cflags-y) $(extra-cflags-m)
+###############################################################################
+#
+# Siano Mobile Silicon, Inc.
+# MDTV receiver kernel modules.
+# Copyright (C) 2006-2008, Uri Shkolnik
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+#
+###############################################################################
 
+#Local variables initailization
+MODULE_NAME = smsmdtv
+
+SMSOBJ := smscoreapi.o sms-cards.o smsendian.o smsir.o
+
+EXTRA_CFLAGS += -DSMS_HOSTLIB_SUBSYS
+SMSOBJ += smschar.o
+
+EXTRA_CFLAGS += -DSMS_SPI_DRV
+SMSOBJ += smsspilog.o smsspicommon.o smsspiphy_omap34xx.o
+
+smsmdtv-objs := $(SMSOBJ)
+
+obj-m := smsmdtv.o
diff --git a/drivers/media/dvb/siano/compat.h b/drivers/media/dvb/siano/compat.h
new file mode 100644
index 0000000..66cf6d6
--- /dev/null
+++ b/drivers/media/dvb/siano/compat.h
@@ -0,0 +1,238 @@
+/*
+ * $Id: compat.h,v 1.44 2006/01/15 09:35:16 mchehab Exp $
+ */
+
+#ifndef _COMPAT_H
+#define _COMPAT_H
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
+#define	KERN_CONT	""
+#endif
+
+/* To allow I2C compatibility code to work */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
+#include <linux/i2c-dev.h>
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+#ifdef CONFIG_PROC_FS
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#endif
+#endif
+
+/* To allow alsa code to work */
+#ifdef NEED_SOUND_DRIVER_H
+#include <sound/driver.h>
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 23)
+#define set_freezable()
+#define cancel_delayed_work_sync cancel_rearming_delayed_work
+#endif
+
+#ifndef __pure
+#  define __pure __attribute__((pure))
+#endif
+
+#ifndef I2C_M_IGNORE_NAK
+# define I2C_M_IGNORE_NAK 0x1000
+#endif
+
+/* device_create/destroy added in 2.6.18 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+/* on older kernels, class_device_create will in turn be a compat macro */
+# define device_create(a, b, c, d, e, f, g) class_device_create(a, NULL, c, b, d, e, f, g)
+# define device_destroy(a, b) class_device_destroy(a, b)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+#define IRQF_SHARED		SA_SHIRQ
+#define IRQF_DISABLED		SA_INTERRUPT
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+# define PCIAGP_FAIL 0
+
+#define vmalloc_32_user(a) vmalloc_32(a)
+
+#endif
+
+/* bool type and enum-based definition of true and false was added in 2.6.19 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+typedef int bool;
+#define true 1
+#define false 0
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+#define sony_pic_camera_command(a, b) sonypi_camera_command(a, b)
+
+#define SONY_PIC_COMMAND_SETCAMERAAGC        SONYPI_COMMAND_SETCAMERAAGC
+#define SONY_PIC_COMMAND_SETCAMERABRIGHTNESS SONYPI_COMMAND_SETCAMERABRIGHTNESS
+#define SONY_PIC_COMMAND_SETCAMERACOLOR      SONYPI_COMMAND_SETCAMERACOLOR
+#define SONY_PIC_COMMAND_SETCAMERACONTRAST   SONYPI_COMMAND_SETCAMERACONTRAST
+#define SONY_PIC_COMMAND_SETCAMERAHUE        SONYPI_COMMAND_SETCAMERAHUE
+#define SONY_PIC_COMMAND_SETCAMERAPICTURE    SONYPI_COMMAND_SETCAMERAPICTURE
+#define SONY_PIC_COMMAND_SETCAMERASHARPNESS  SONYPI_COMMAND_SETCAMERASHARPNESS
+#define SONY_PIC_COMMAND_SETCAMERA           SONYPI_COMMAND_SETCAMERA
+#endif
+
+/* pci_dev got a new revision field in 2.6.23-rc1 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 23) && defined(LINUX_PCI_H)
+/* Just make it easier to subsitute pci_dev->revision with
+ * v4l_compat_pci_rev(pci_dev).  It's too bad there isn't some kind of context
+ * sensitive macro in C that could do this for us.  */
+static inline u8 v4l_compat_pci_rev(struct pci_dev *pci)
+{ u8 rev; pci_read_config_byte(pci, PCI_REVISION_ID, &rev); return rev; }
+#endif
+
+#if defined(COMPAT_PCM_TO_RATE_BIT) && defined(__SOUND_PCM_H)
+/* New alsa core utility function */
+static inline unsigned int snd_pcm_rate_to_rate_bit(unsigned int rate)
+{
+	static const unsigned int rates[] = { 5512, 8000, 11025, 16000, 22050,
+		32000, 44100, 48000, 64000, 88200, 96000, 176400, 192000 };
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(rates); i++)
+		if (rates[i] == rate)
+			return 1u << i;
+	return SNDRV_PCM_RATE_KNOT;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
+# define task_pid_nr(current) ((current)->pid)
+
+# define sg_init_table(a, b)
+# define sg_page(p) (sg->page)
+# define sg_set_page(sglist, pg, sz, off)	\
+do {						\
+	struct scatterlist *p = sglist;		\
+	p->page   = pg;				\
+	p->length = sz;				\
+	p->offset = off;			\
+} while (0)
+
+#define pr_err(fmt, arg...) \
+	printk(KERN_ERR fmt, ##arg)
+#endif
+
+#ifndef BIT_MASK
+# define BIT_MASK(nr)            (1UL << ((nr) % BITS_PER_LONG))
+# define BIT_WORD(nr)            ((nr) / BITS_PER_LONG)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
+#define i2c_verify_client(dev)	\
+	((dev->bus == &i2c_bus_type) ? to_i2c_client(dev) : NULL)
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25)
+#define i2c_verify_client(dev) \
+	((dev->bus && 0 == strcmp(dev->bus->name, "i2c")) ? to_i2c_client(dev) : NULL)
+#endif
+
+#ifndef USB_DEVICE_AND_INTERFACE_INFO
+# define USB_DEVICE_AND_INTERFACE_INFO(vend, prod, cl, sc, pr) \
+	.match_flags = USB_DEVICE_ID_MATCH_INT_INFO \
+		| USB_DEVICE_ID_MATCH_DEVICE, \
+	.idVendor = (vend), .idProduct = (prod), \
+	.bInterfaceClass = (cl), \
+	.bInterfaceSubClass = (sc), .bInterfaceProtocol = (pr)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+#define get_unaligned_be16(a)					\
+	be16_to_cpu(get_unaligned((unsigned short *)(a)))
+#define put_unaligned_be16(r, a)				\
+	put_unaligned(cpu_to_be16(r), ((unsigned short *)(a)))
+#define get_unaligned_le16(a)					\
+	le16_to_cpu(get_unaligned((unsigned short *)(a)))
+#define put_unaligned_le16(r, a)				\
+	put_unaligned(cpu_to_le16(r), ((unsigned short *)(a)))
+#define get_unaligned_be32(a)					\
+	be32_to_cpu(get_unaligned((u32 *)(a)))
+#define put_unaligned_be32(r, a)				\
+	put_unaligned(cpu_to_be32(r), ((u32 *)(a)))
+#define get_unaligned_le32(a)					\
+	le32_to_cpu(get_unaligned((u32 *)(a)))
+#define put_unaligned_le32(r, a)				\
+	put_unaligned(cpu_to_le32(r), ((u32 *)(a)))
+#define get_unaligned_le64(a)					\
+	le64_to_cpu(get_unaligned((u64 *)(a)))
+#define put_unaligned_le64(r, a)				\
+	put_unaligned(cpu_to_le64(r), ((u64 *)(a)))
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25)
+#ifdef CONFIG_PROC_FS
+static inline struct proc_dir_entry *proc_create(const char *a,
+	mode_t b, struct proc_dir_entry *c, const struct file_operations *d)
+{
+	struct proc_dir_entry *e;
+
+	e = create_proc_entry(a, b, c);
+	if (e) {
+		e->owner = THIS_MODULE;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 17)
+		e->proc_fops = d;
+#else
+		e->proc_fops = (struct file_operations *)d;
+#endif
+	}
+	return e;
+}
+#endif
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+#ifdef CONFIG_PROC_FS
+static inline struct proc_dir_entry *proc_create_data(const char *a,
+	mode_t b, struct proc_dir_entry *c, const struct file_operations *d,
+	void *f)
+{
+	struct proc_dir_entry *e;
+
+	e = create_proc_entry(a, b, c);
+	if (e) {
+		e->owner = THIS_MODULE;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 17)
+		e->proc_fops = d;
+#else
+		e->proc_fops = (struct file_operations *)d;
+#endif
+		e->data = f;
+	}
+	return e;
+}
+#endif
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 17)
+#define hweight64(x)  generic_hweight64(x)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+#define div64_u64(a, b) div64_64(a, b)
+
+#define clamp (x, l, h)		max_t(__typeof__(x),		\
+				(l),			\
+				min_t(__typeof__(x),	\
+				(h),        	\
+				(x)))
+
+#define dev_name(dev)	((dev)->bus_id)
+
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
+typedef unsigned long uintptr_t;
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+static inline int list_is_singular(const struct list_head *head)
+{
+	return !list_empty(head) && (head->next == head->prev);
+}
+#endif
+
+#endif
diff --git a/drivers/media/dvb/siano/sms-cards.c b/drivers/media/dvb/siano/sms-cards.c
index 4307e4e..27ccb97 100644
--- a/drivers/media/dvb/siano/sms-cards.c
+++ b/drivers/media/dvb/siano/sms-cards.c
@@ -18,9 +18,9 @@
  */
 
 #include "sms-cards.h"
+#include "smsir.h"
 
 struct usb_device_id smsusb_id_table[] = {
-#ifdef CONFIG_DVB_SIANO_SMS1XXX_SMS_IDS
 	{ USB_DEVICE(0x187f, 0x0010),
 		.driver_info = SMS1XXX_BOARD_SIANO_STELLAR },
 	{ USB_DEVICE(0x187f, 0x0100),
@@ -31,7 +31,6 @@ struct usb_device_id smsusb_id_table[] = {
 		.driver_info = SMS1XXX_BOARD_SIANO_NOVA_B },
 	{ USB_DEVICE(0x187f, 0x0300),
 		.driver_info = SMS1XXX_BOARD_SIANO_VEGA },
-#endif
 	{ USB_DEVICE(0x2040, 0x1700),
 		.driver_info = SMS1XXX_BOARD_HAUPPAUGE_CATAMOUNT },
 	{ USB_DEVICE(0x2040, 0x1800),
@@ -60,167 +59,265 @@ struct usb_device_id smsusb_id_table[] = {
 		.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },
 	{ USB_DEVICE(0x2040, 0x5590),
 		.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },
-	{ }		/* Terminating entry */
-};
+	{ USB_DEVICE(0x187f, 0x0202),
+		.driver_info = SMS1XXX_BOARD_SIANO_NICE },
+	{ USB_DEVICE(0x187f, 0x0301),
+		.driver_info = SMS1XXX_BOARD_SIANO_VENICE },
+	{ } /* Terminating entry */
+	};
+
 MODULE_DEVICE_TABLE(usb, smsusb_id_table);
 
 static struct sms_board sms_boards[] = {
 	[SMS_BOARD_UNKNOWN] = {
-		.name	= "Unknown board",
+	/* 0 */
+		.name = "Unknown board",
 	},
 	[SMS1XXX_BOARD_SIANO_STELLAR] = {
-		.name	= "Siano Stellar Digital Receiver",
-		.type	= SMS_STELLAR,
-		.fw[DEVICE_MODE_DVBT_BDA] = "sms1xxx-stellar-dvbt-01.fw",
+	/* 1 */
+		.name =
+		"Siano Stellar Digital Receiver",
+		.type = SMS_STELLAR,
 	},
 	[SMS1XXX_BOARD_SIANO_NOVA_A] = {
-		.name	= "Siano Nova A Digital Receiver",
-		.type	= SMS_NOVA_A0,
-		.fw[DEVICE_MODE_DVBT_BDA] = "sms1xxx-nova-a-dvbt-01.fw",
+	/* 2 */
+		.name = "Siano Nova A Digital Receiver",
+		.type = SMS_NOVA_A0,
 	},
 	[SMS1XXX_BOARD_SIANO_NOVA_B] = {
-		.name	= "Siano Nova B Digital Receiver",
-		.type	= SMS_NOVA_B0,
-		.fw[DEVICE_MODE_DVBT_BDA] = "sms1xxx-nova-b-dvbt-01.fw",
+	/* 3 */
+		.name = "Siano Nova B Digital Receiver",
+		.type = SMS_NOVA_B0,
 	},
 	[SMS1XXX_BOARD_SIANO_VEGA] = {
-		.name	= "Siano Vega Digital Receiver",
-		.type	= SMS_VEGA,
+	/* 4 */
+		.name = "Siano Vega Digital Receiver",
+		.type = SMS_VEGA,
 	},
 	[SMS1XXX_BOARD_HAUPPAUGE_CATAMOUNT] = {
-		.name	= "Hauppauge Catamount",
-		.type	= SMS_STELLAR,
-		.fw[DEVICE_MODE_DVBT_BDA] = "sms1xxx-stellar-dvbt-01.fw",
+	/* 5 */
+		.name = "Hauppauge Catamount",
+		.type = SMS_STELLAR,
+		.fw[DEVICE_MODE_DVBT_BDA] =
+		"sms1xxx-stellar-dvbt-01.fw",
 	},
 	[SMS1XXX_BOARD_HAUPPAUGE_OKEMO_A] = {
-		.name	= "Hauppauge Okemo-A",
-		.type	= SMS_NOVA_A0,
-		.fw[DEVICE_MODE_DVBT_BDA] = "sms1xxx-nova-a-dvbt-01.fw",
+	/* 6 */
+		.name = "Hauppauge Okemo-A",
+		.type = SMS_NOVA_A0,
+		.fw[DEVICE_MODE_DVBT_BDA] =
+		"sms1xxx-nova-a-dvbt-01.fw",
 	},
 	[SMS1XXX_BOARD_HAUPPAUGE_OKEMO_B] = {
-		.name	= "Hauppauge Okemo-B",
-		.type	= SMS_NOVA_B0,
-		.fw[DEVICE_MODE_DVBT_BDA] = "sms1xxx-nova-b-dvbt-01.fw",
+	/* 7 */
+		.name = "Hauppauge Okemo-B",
+		.type = SMS_NOVA_B0,
+		.fw[DEVICE_MODE_DVBT_BDA] =
+		"sms1xxx-nova-b-dvbt-01.fw",
 	},
 	[SMS1XXX_BOARD_HAUPPAUGE_WINDHAM] = {
-		.name	= "Hauppauge WinTV MiniStick",
-		.type	= SMS_NOVA_B0,
+	/* 8 */
+		.name = "Hauppauge WinTV MiniStick",
+		.type = SMS_NOVA_B0,
 		.fw[DEVICE_MODE_DVBT_BDA] = "sms1xxx-hcw-55xxx-dvbt-02.fw",
-		.led_power = 26,
-		.led_lo    = 27,
-		.led_hi    = 28,
+		.board_cfg.leds_power = 26,
+		.board_cfg.led0 = 27,
+		.board_cfg.led1 = 28,
 	},
 	[SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD] = {
-		.name	= "Hauppauge WinTV MiniCard",
-		.type	= SMS_NOVA_B0,
+	/* 9 */
+		.name = "Hauppauge WinTV MiniCard",
+		.type = SMS_NOVA_B0,
 		.fw[DEVICE_MODE_DVBT_BDA] = "sms1xxx-hcw-55xxx-dvbt-02.fw",
-		.lna_ctrl  = 29,
+		.board_cfg.foreign_lna0_ctrl = 29,
 	},
 	[SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD_R2] = {
-		.name	= "Hauppauge WinTV MiniCard",
-		.type	= SMS_NOVA_B0,
+	/* 10 */
+		.name = "Hauppauge WinTV MiniCard",
+		.type = SMS_NOVA_B0,
 		.fw[DEVICE_MODE_DVBT_BDA] = "sms1xxx-hcw-55xxx-dvbt-02.fw",
-		.lna_ctrl  = -1,
+		.board_cfg.foreign_lna0_ctrl = 1,
+	},
+	[SMS1XXX_BOARD_SIANO_NICE] = {
+	/* 11 */
+		.name = "Siano Nice Digital Receiver",
+		.type = SMS_NOVA_B0,
+	},
+	[SMS1XXX_BOARD_SIANO_VENICE] = {
+	/* 12 */
+		.name = "Siano Venice Digital Receiver",
+		.type = SMS_VEGA,
 	},
 };
 
 struct sms_board *sms_get_board(int id)
 {
 	BUG_ON(id >= ARRAY_SIZE(sms_boards));
-
 	return &sms_boards[id];
 }
 
-static int sms_set_gpio(struct smscore_device_t *coredev, int pin, int enable)
-{
-	int lvl, ret;
-	u32 gpio;
-	struct smscore_gpio_config gpioconfig = {
-		.direction            = SMS_GPIO_DIRECTION_OUTPUT,
-		.pullupdown           = SMS_GPIO_PULLUPDOWN_NONE,
-		.inputcharacteristics = SMS_GPIO_INPUTCHARACTERISTICS_NORMAL,
-		.outputslewrate       = SMS_GPIO_OUTPUTSLEWRATE_FAST,
-		.outputdriving        = SMS_GPIO_OUTPUTDRIVING_4mA,
-	};
-
-	if (pin == 0)
-		return -EINVAL;
-
-	if (pin < 0) {
-		/* inverted gpio */
-		gpio = pin * -1;
-		lvl = enable ? 0 : 1;
-	} else {
-		gpio = pin;
-		lvl = enable ? 1 : 0;
-	}
-
-	ret = smscore_configure_gpio(coredev, gpio, &gpioconfig);
-	if (ret < 0)
-		return ret;
-
-	return smscore_set_gpio(coredev, gpio, lvl);
+static inline void sms_gpio_assign_11xx_default_led_config(
+		struct smscore_gpio_config *pGpioConfig) {
+	pGpioConfig->Direction = SMS_GPIO_DIRECTION_OUTPUT;
+	pGpioConfig->InputCharacteristics =
+		SMS_GPIO_INPUTCHARACTERISTICS_NORMAL;
+	pGpioConfig->OutputDriving = SMS_GPIO_OUTPUTDRIVING_4mA;
+	pGpioConfig->OutputSlewRate = SMS_GPIO_OUTPUTSLEWRATE_0_45_V_NS;
+	pGpioConfig->PullUpDown = SMS_GPIO_PULLUPDOWN_NONE;
 }
 
-int sms_board_setup(struct smscore_device_t *coredev)
-{
+int sms_board_event(struct smscore_device_t *coredev,
+		enum SMS_BOARD_EVENTS gevent) {
 	int board_id = smscore_get_board_id(coredev);
 	struct sms_board *board = sms_get_board(board_id);
+	struct smscore_gpio_config MyGpioConfig;
 
-	switch (board_id) {
-	case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
-		/* turn off all LEDs */
-		sms_set_gpio(coredev, board->led_power, 0);
-		sms_set_gpio(coredev, board->led_hi, 0);
-		sms_set_gpio(coredev, board->led_lo, 0);
-		break;
-	case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD_R2:
-	case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD:
-		/* turn off LNA */
-		sms_set_gpio(coredev, board->lna_ctrl, 0);
-		break;
-	}
-	return 0;
-}
+	sms_gpio_assign_11xx_default_led_config(&MyGpioConfig);
 
-int sms_board_power(struct smscore_device_t *coredev, int onoff)
-{
-	int board_id = smscore_get_board_id(coredev);
-	struct sms_board *board = sms_get_board(board_id);
+	switch (gevent) {
+	case BOARD_EVENT_POWER_INIT: /* including hotplug */
+		switch (board_id) {
+		case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
+			/* set I/O and turn off all LEDs */
+			smscore_gpio_configure(coredev,
+					board->board_cfg.leds_power,
+					&MyGpioConfig);
+			smscore_gpio_set_level(coredev,
+					board->board_cfg.leds_power, 0);
+			smscore_gpio_configure(coredev, board->board_cfg.led0,
+					&MyGpioConfig);
+			smscore_gpio_set_level(coredev,
+					board->board_cfg.led0, 0);
+			smscore_gpio_configure(coredev, board->board_cfg.led1,
+					&MyGpioConfig);
+			smscore_gpio_set_level(coredev,
+					board->board_cfg.led1, 0);
+			break;
+		case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD_R2:
+		case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD:
+			/* set I/O and turn off LNA */
+			smscore_gpio_configure(coredev,
+					board->board_cfg.foreign_lna0_ctrl,
+					&MyGpioConfig);
+			smscore_gpio_set_level(coredev,
+					board->board_cfg.foreign_lna0_ctrl,
+					0);
+			break;
+		}
+		break; /* BOARD_EVENT_BIND */
 
-	switch (board_id) {
-	case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
-		/* power LED */
-		sms_set_gpio(coredev,
-			     board->led_power, onoff ? 1 : 0);
-		break;
-	case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD_R2:
-	case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD:
-		/* LNA */
-		sms_set_gpio(coredev,
-			     board->lna_ctrl, onoff ? 1 : 0);
-		break;
-	}
-	return 0;
-}
+	case BOARD_EVENT_POWER_SUSPEND:
+		switch (board_id) {
+		case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
+			smscore_gpio_set_level(coredev,
+						board->board_cfg.leds_power, 0);
+			smscore_gpio_set_level(coredev,
+						board->board_cfg.led0, 0);
+			smscore_gpio_set_level(coredev,
+						board->board_cfg.led1, 0);
+			break;
+		case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD_R2:
+		case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD:
+			smscore_gpio_set_level(coredev,
+					board->board_cfg.foreign_lna0_ctrl,
+					0);
+			break;
+		}
+		break; /* BOARD_EVENT_POWER_SUSPEND */
 
-int sms_board_led_feedback(struct smscore_device_t *coredev, int led)
-{
-	int board_id = smscore_get_board_id(coredev);
-	struct sms_board *board = sms_get_board(board_id);
+	case BOARD_EVENT_POWER_RESUME:
+		switch (board_id) {
+		case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
+			smscore_gpio_set_level(coredev,
+						board->board_cfg.leds_power, 1);
+			smscore_gpio_set_level(coredev,
+						board->board_cfg.led0, 1);
+			smscore_gpio_set_level(coredev,
+						board->board_cfg.led1, 0);
+			break;
+		case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD_R2:
+		case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD:
+			smscore_gpio_set_level(coredev,
+					board->board_cfg.foreign_lna0_ctrl,
+					1);
+			break;
+		}
+		break; /* BOARD_EVENT_POWER_RESUME */
 
-	/* dont touch GPIO if LEDs are already set */
-	if (smscore_led_state(coredev, -1) == led)
-		return 0;
+	case BOARD_EVENT_BIND:
+		switch (board_id) {
+		case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
+			smscore_gpio_set_level(coredev,
+				board->board_cfg.leds_power, 1);
+			smscore_gpio_set_level(coredev,
+				board->board_cfg.led0, 1);
+			smscore_gpio_set_level(coredev,
+				board->board_cfg.led1, 0);
+			break;
+		case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD_R2:
+		case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD:
+			smscore_gpio_set_level(coredev,
+					board->board_cfg.foreign_lna0_ctrl,
+					1);
+			break;
+		}
+		break; /* BOARD_EVENT_BIND */
 
-	switch (board_id) {
-	case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
-		sms_set_gpio(coredev,
-			     board->led_lo, (led & SMS_LED_LO) ? 1 : 0);
-		sms_set_gpio(coredev,
-			     board->led_hi, (led & SMS_LED_HI) ? 1 : 0);
+	case BOARD_EVENT_SCAN_PROG:
+		break; /* BOARD_EVENT_SCAN_PROG */
+	case BOARD_EVENT_SCAN_COMP:
+		break; /* BOARD_EVENT_SCAN_COMP */
+	case BOARD_EVENT_EMERGENCY_WARNING_SIGNAL:
+		break; /* BOARD_EVENT_EMERGENCY_WARNING_SIGNAL */
+	case BOARD_EVENT_FE_LOCK:
+		switch (board_id) {
+		case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
+			smscore_gpio_set_level(coredev,
+			board->board_cfg.led1, 1);
+			break;
+		}
+		break; /* BOARD_EVENT_FE_LOCK */
+	case BOARD_EVENT_FE_UNLOCK:
+		switch (board_id) {
+		case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
+			smscore_gpio_set_level(coredev,
+						board->board_cfg.led1, 0);
+			break;
+		}
+		break; /* BOARD_EVENT_FE_UNLOCK */
+	case BOARD_EVENT_DEMOD_LOCK:
+		break; /* BOARD_EVENT_DEMOD_LOCK */
+	case BOARD_EVENT_DEMOD_UNLOCK:
+		break; /* BOARD_EVENT_DEMOD_UNLOCK */
+	case BOARD_EVENT_RECEPTION_MAX_4:
+		break; /* BOARD_EVENT_RECEPTION_MAX_4 */
+	case BOARD_EVENT_RECEPTION_3:
+		break; /* BOARD_EVENT_RECEPTION_3 */
+	case BOARD_EVENT_RECEPTION_2:
+		break; /* BOARD_EVENT_RECEPTION_2 */
+	case BOARD_EVENT_RECEPTION_1:
+		break; /* BOARD_EVENT_RECEPTION_1 */
+	case BOARD_EVENT_RECEPTION_LOST_0:
+		break; /* BOARD_EVENT_RECEPTION_LOST_0 */
+	case BOARD_EVENT_MULTIPLEX_OK:
+		switch (board_id) {
+		case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
+			smscore_gpio_set_level(coredev,
+						board->board_cfg.led1, 1);
+			break;
+		}
+		break; /* BOARD_EVENT_MULTIPLEX_OK */
+	case BOARD_EVENT_MULTIPLEX_ERRORS:
+		switch (board_id) {
+		case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
+			smscore_gpio_set_level(coredev,
+						board->board_cfg.led1, 0);
+			break;
+		}
+		break; /* BOARD_EVENT_MULTIPLEX_ERRORS */
 
-		smscore_led_state(coredev, led);
+	default:
+		sms_err("Unknown SMS board event");
 		break;
 	}
 	return 0;
diff --git a/drivers/media/dvb/siano/sms-cards.h b/drivers/media/dvb/siano/sms-cards.h
index 8e0fe9f..7a6c82e 100644
--- a/drivers/media/dvb/siano/sms-cards.h
+++ b/drivers/media/dvb/siano/sms-cards.h
@@ -22,6 +22,7 @@
 
 #include <linux/usb.h>
 #include "smscoreapi.h"
+#include "smsir.h"
 
 #define SMS_BOARD_UNKNOWN 0
 #define SMS1XXX_BOARD_SIANO_STELLAR 1
@@ -34,25 +35,76 @@
 #define SMS1XXX_BOARD_HAUPPAUGE_WINDHAM 8
 #define SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD 9
 #define SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD_R2 10
+#define SMS1XXX_BOARD_SIANO_NICE	11
+#define SMS1XXX_BOARD_SIANO_VENICE	12
+
+struct sms_board_gpio_cfg {
+	int lna_vhf_exist;
+	int lna_vhf_ctrl;
+	int lna_uhf_exist;
+	int lna_uhf_ctrl;
+	int lna_uhf_d_ctrl;
+	int lna_sband_exist;
+	int lna_sband_ctrl;
+	int lna_sband_d_ctrl;
+	int foreign_lna0_ctrl;
+	int foreign_lna1_ctrl;
+	int foreign_lna2_ctrl;
+	int rf_switch_vhf;
+	int rf_switch_uhf;
+	int rf_switch_sband;
+	int leds_power;
+	int led0;
+	int led1;
+	int led2;
+	int led3;
+	int led4;
+	int ir;
+	int eeprom_wp;
+	int mrc_sense;
+	int mrc_pdn_resetn;
+	int mrc_gp0; /* mrcs spi int */
+	int mrc_gp1;
+	int mrc_gp2;
+	int mrc_gp3;
+	int mrc_gp4;
+	int host_spi_gsp_ts_int;
+};
 
 struct sms_board {
 	enum sms_device_type_st type;
 	char *name, *fw[DEVICE_MODE_MAX];
-
-	/* gpios */
-	int led_power, led_hi, led_lo, lna_ctrl;
+	struct sms_board_gpio_cfg board_cfg;
+	enum ir_kb_type ir_kb_type;
 };
 
 struct sms_board *sms_get_board(int id);
 
-int sms_board_setup(struct smscore_device_t *coredev);
+extern struct usb_device_id smsusb_id_table[];
+extern struct smscore_device_t *coredev;
 
-#define SMS_LED_OFF 0
-#define SMS_LED_LO  1
-#define SMS_LED_HI  2
-int sms_board_led_feedback(struct smscore_device_t *coredev, int led);
-int sms_board_power(struct smscore_device_t *coredev, int onoff);
+enum SMS_BOARD_EVENTS {
+	BOARD_EVENT_POWER_INIT,
+	BOARD_EVENT_POWER_SUSPEND,
+	BOARD_EVENT_POWER_RESUME,
+	BOARD_EVENT_BIND,
+	BOARD_EVENT_SCAN_PROG,
+	BOARD_EVENT_SCAN_COMP,
+	BOARD_EVENT_EMERGENCY_WARNING_SIGNAL,
+	BOARD_EVENT_FE_LOCK,
+	BOARD_EVENT_FE_UNLOCK,
+	BOARD_EVENT_DEMOD_LOCK,
+	BOARD_EVENT_DEMOD_UNLOCK,
+	BOARD_EVENT_RECEPTION_MAX_4,
+	BOARD_EVENT_RECEPTION_3,
+	BOARD_EVENT_RECEPTION_2,
+	BOARD_EVENT_RECEPTION_1,
+	BOARD_EVENT_RECEPTION_LOST_0,
+	BOARD_EVENT_MULTIPLEX_OK,
+	BOARD_EVENT_MULTIPLEX_ERRORS
+};
 
-extern struct usb_device_id smsusb_id_table[];
+int sms_board_event(struct smscore_device_t *coredev,
+		enum SMS_BOARD_EVENTS gevent);
 
 #endif /* __SMS_CARDS_H__ */
diff --git a/drivers/media/dvb/siano/smschar.c b/drivers/media/dvb/siano/smschar.c
new file mode 100644
index 0000000..80547f0
--- /dev/null
+++ b/drivers/media/dvb/siano/smschar.c
@@ -0,0 +1,683 @@
+/****************************************************************
+
+Siano Mobile Silicon, Inc.
+MDTV receiver kernel modules.
+Copyright (C) 2006-2008, Uri Shkolnik
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+****************************************************************/
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+
+#include <linux/kernel.h>	/* printk() */
+#include <linux/fs.h>		/* everything... */
+#include <linux/types.h>	/* size_t */
+#include <linux/cdev.h>
+#include <linux/sched.h>
+#include <linux/poll.h>
+#include <asm/system.h>		/* cli(), *_flags */
+#include <linux/uaccess.h>	/* copy_*_user */
+
+#include "smscoreapi.h"
+#include "smscharioctl.h"
+
+/* max number of packets allowed to be pending on queue*/
+#define SMS_CHR_MAX_Q_LEN	15
+#define SMSCHAR_NR_DEVS		17
+
+struct smschar_device_t {
+	struct cdev cdev;	/*!< Char device structure */
+	wait_queue_head_t waitq;	/* Processes waiting */
+	int cancel_waitq;
+	spinlock_t lock;	/*!< critical section */
+	int pending_count;
+	struct list_head pending_data;	/*!< list of pending data */
+	struct smscore_buffer_t *currentcb;
+	int device_index;
+	struct smscore_device_t *coredev;
+	struct smscore_client_t *smsclient;
+};
+
+/*!  Holds the major number of the device node. may be changed at load
+time.*/
+int smschar_major = 255;
+
+/*!  Holds the first minor number of the device node.
+may be changed at load time.*/
+int smschar_minor;
+
+/* macros that allow the load time parameters change*/
+module_param(smschar_major, int, S_IRUGO);
+module_param(smschar_minor, int, S_IRUGO);
+
+struct smschar_device_t smschar_devices[SMSCHAR_NR_DEVS];
+static int g_smschar_inuse;
+
+static int g_pnp_status_changed = 1;
+wait_queue_head_t g_pnp_event;
+static struct class *smschar_class;
+
+/**
+ * unregisters sms client and returns all queued buffers
+ *
+ * @param dev pointer to the client context (smschar parameters block)
+ *
+ */
+static void smschar_unregister_client(struct smschar_device_t *dev)
+{
+	unsigned long flags;
+
+	sms_info("entering... smschar_unregister_client....\n");
+	if (dev->coredev && dev->smsclient) {
+		dev->cancel_waitq = 1;
+		wake_up_interruptible(&dev->waitq);
+
+		spin_lock_irqsave(&dev->lock, flags);
+
+		while (!list_empty(&dev->pending_data)) {
+			struct smscore_buffer_t *cb =
+				(struct smscore_buffer_t *)dev->pending_data.next;
+			list_del(&cb->entry);
+
+			smscore_putbuffer(dev->coredev, cb);
+			dev->pending_count--;
+		}
+
+		if (dev->currentcb) {
+			smscore_putbuffer(dev->coredev, dev->currentcb);
+			dev->currentcb = NULL;
+			dev->pending_count--;
+		}
+
+		smscore_unregister_client(dev->smsclient);
+		dev->smsclient = NULL;
+
+		spin_unlock_irqrestore(&dev->lock, flags);
+	}
+}
+
+/**
+ * queues incoming buffers into buffers queue
+ *
+ * @param context pointer to the client context (smschar parameters block)
+ * @param cb pointer to incoming buffer descriptor
+ *
+ * @return 0 on success, <0 on queue overflow.
+ */
+static int smschar_onresponse(void *context, struct smscore_buffer_t *cb)
+{
+	struct smschar_device_t *dev = context;
+	unsigned long flags;
+
+	if (!dev) {
+		sms_err("recieved bad dev pointer\n");
+		return -EFAULT;
+	}
+	spin_lock_irqsave(&dev->lock, flags);
+
+	if (dev->pending_count > SMS_CHR_MAX_Q_LEN) {
+		spin_unlock_irqrestore(&dev->lock, flags);
+		return -EBUSY;
+	}
+
+	dev->pending_count++;
+	/* if data channel, remove header */
+	if (dev->device_index) {
+		cb->size -= sizeof(struct SmsMsgHdr_ST);
+		cb->offset += sizeof(struct SmsMsgHdr_ST);
+	}
+
+	list_add_tail(&cb->entry, &dev->pending_data);
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	if (waitqueue_active(&dev->waitq)) {
+		wake_up_interruptible(&dev->waitq);
+  }
+
+	return 0;
+}
+
+/**
+ * handles device removal event
+ *
+ * @param context pointer to the client context (smschar parameters block)
+ *
+ */
+static void smschar_onremove(void *context)
+{
+	struct smschar_device_t *dev = (struct smschar_device_t *)context;
+
+	smschar_unregister_client(dev);
+	dev->coredev = NULL;
+}
+
+/**
+ * registers client associated with the node
+ *
+ * @param inode Inode concerned.
+ * @param file File concerned.
+ *
+ * @return 0 on success, <0 on error.
+ */
+static int smschar_open(struct inode *inode, struct file *file)
+{
+	struct smschar_device_t *dev = container_of(inode->i_cdev,
+						    struct smschar_device_t,
+						    cdev);
+	int rc = -ENODEV;
+
+	/*sms_info("entering dev->device_index = %d\n", dev->device_index);*/
+	printk(KERN_INFO "%s: dev->device_index = %d\n", __func__, dev->device_index);
+
+	if (dev->coredev) {
+		struct smsclient_params_t params;
+		params.initial_id = dev->device_index ?
+		    dev->device_index : SMS_HOST_LIB;
+		params.data_type = dev->device_index ? MSG_SMS_DAB_CHANNEL : 0;
+		params.onresponse_handler = smschar_onresponse;
+		params.onremove_handler = smschar_onremove;
+		params.context = dev;
+
+		rc = smscore_register_client(dev->coredev, &params,
+					     &dev->smsclient);
+		if (!rc)
+			file->private_data = dev;
+		dev->cancel_waitq = 0;
+		g_pnp_status_changed = 1;
+	}
+
+	if (rc) {
+		/*sms_err(" exiting, rc %d\n", rc);*/
+		printk(KERN_INFO "%s: [FATAL] smscore_register_client() is failed. rc=%d\n", __func__, rc);
+  }
+	return rc;
+}
+
+/**
+ * unregisters client associated with the node
+ *
+ * @param inode Inode concerned.
+ * @param file File concerned.
+ *
+ */
+static int smschar_release(struct inode *inode, struct file *file)
+{
+	smschar_unregister_client(file->private_data);
+	sms_info("exiting\n");
+	return 0;
+}
+
+/**
+ * copies data from buffers in incoming queue into a user buffer
+ *
+ * @param file File structure.
+ * @param buf Source buffer.
+ * @param count Size of source buffer.
+ * @param f_pos Position in file (ignored).
+ *
+ * @return Number of bytes read, or <0 on error.
+ */
+static ssize_t smschar_read(struct file *file, char __user *buf,
+			    size_t count, loff_t *f_pos)
+{
+	struct smschar_device_t *dev = file->private_data;
+	unsigned long flags;
+	int rc, copied = 0;
+
+	if (!buf) {
+		sms_err("Bad pointer recieved from user.\n");
+		return -EFAULT;
+	}
+	if (!dev->coredev || !dev->smsclient) {
+		sms_err("no client\n");
+		return -ENODEV;
+	}
+	rc = wait_event_interruptible(dev->waitq,
+				      !list_empty(&dev->pending_data)
+				      || (dev->cancel_waitq));
+	if (rc < 0) {
+		sms_info("wait_event_interruptible error %d\n", rc);
+		return rc;
+	}
+	if (dev->cancel_waitq)
+		return 0;
+	if (!dev->smsclient) {
+		sms_err("no client\n");
+		return -ENODEV;
+	}
+	spin_lock_irqsave(&dev->lock, flags);
+
+	while (!list_empty(&dev->pending_data) && (copied < count)) {
+		struct smscore_buffer_t *cb =
+		    (struct smscore_buffer_t *)dev->pending_data.next;
+		int actual_size = min(((int)count - copied), cb->size);
+		if (copy_to_user(&buf[copied], &((char *)cb->p)[cb->offset],
+				 actual_size)) {
+			sms_err("copy_to_user failed\n");
+			spin_unlock_irqrestore(&dev->lock, flags);
+			return -EFAULT;
+		}
+		copied += actual_size;
+		cb->offset += actual_size;
+		cb->size -= actual_size;
+
+		if (!cb->size) {
+			list_del(&cb->entry);
+			smscore_putbuffer(dev->coredev, cb);
+			dev->pending_count--;
+		}
+	}
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return copied;
+}
+
+/**
+ * sends the buffer to the associated device
+ *
+ * @param file File structure.
+ * @param buf Source buffer.
+ * @param count Size of source buffer.
+ * @param f_pos Position in file (ignored).
+ *
+ * @return Number of bytes read, or <0 on error.
+ */
+static ssize_t smschar_write(struct file *file, const char __user *buf,
+			     size_t count, loff_t *f_pos)
+{
+	struct smschar_device_t *dev;
+	void *buffer;
+
+	if (file == NULL) {
+		sms_err("file is NULL\n");
+		return EINVAL;
+	}
+
+	if (file->private_data == NULL) {
+		sms_err("file->private_data is NULL\n");
+		return -EINVAL;
+	}
+
+	dev = file->private_data;
+	if (!dev->smsclient) {
+		sms_err("no client\n");
+		return -ENODEV;
+	}
+
+	buffer = kmalloc(ALIGN(count, SMS_ALLOC_ALIGNMENT) + SMS_DMA_ALIGNMENT,
+			 GFP_KERNEL | GFP_DMA);
+	if (buffer) {
+		void *msg_buffer = (void *)SMS_ALIGN_ADDRESS(buffer);
+
+		if (!copy_from_user(msg_buffer, buf, count))
+			smsclient_sendrequest(dev->smsclient,
+					      msg_buffer, count);
+		else
+			count = 0;
+
+		kfree(buffer);
+	}
+
+	return count;
+}
+
+static int smschar_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct smschar_device_t *dev = file->private_data;
+	return smscore_map_common_buffer(dev->coredev, vma);
+}
+
+/**
+ * waits until buffer inserted into a queue. when inserted buffer offset
+ * are reportedto the calling process. previously reported buffer is
+ * returned to smscore pool.
+ *
+ * @param dev pointer to smschar parameters block
+ * @param touser pointer to a structure that receives incoming buffer offsets
+ *
+ * @return 0 on success, <0 on error.
+ */
+static int smschar_wait_get_buffer(struct smschar_device_t *dev,
+				   struct smschar_buffer_t *touser)
+{
+	unsigned long flags;
+	int rc;
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	if (dev->currentcb) {
+		smscore_putbuffer(dev->coredev, dev->currentcb);
+		dev->currentcb = NULL;
+		dev->pending_count--;
+	}
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	rc = wait_event_interruptible(dev->waitq,
+				      !list_empty(&dev->pending_data)
+				      || (dev->cancel_waitq));
+	if (rc < 0) {
+		sms_info("wait_event_interruptible error, rc=%d\n", rc);
+		return rc;
+	}
+
+	if (dev->cancel_waitq) {
+		touser->offset = 0;
+		touser->size = 0;
+		return 0;
+	}
+	if (!dev->smsclient) {
+		sms_err("no client\n");
+		return -ENODEV;
+	}
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	if (!list_empty(&dev->pending_data)) {
+		struct smscore_buffer_t *cb =
+		    (struct smscore_buffer_t *)dev->pending_data.next;
+		touser->offset = cb->offset_in_common + cb->offset;
+		touser->size = cb->size;
+
+		list_del(&cb->entry);
+
+		dev->currentcb = cb;
+	} else {
+		touser->offset = 0;
+		touser->size = 0;
+	}
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return 0;
+}
+
+/**
+ * poll for data availability
+ *
+ * @param file File structure.
+ * @param wait kernel polling table.
+ *
+ * @return POLLIN flag if read data is available.
+ */
+static unsigned int smschar_poll(struct file *file,
+				 struct poll_table_struct *wait)
+{
+	struct smschar_device_t *dev;
+	int mask = 0;
+
+	if (file == NULL) {
+		sms_err("file is NULL\n");
+		return EINVAL;
+	}
+
+	if (file->private_data == NULL) {
+		sms_err("file->private_data is NULL\n");
+		return -EINVAL;
+	}
+
+	dev = file->private_data;
+
+	if (list_empty(&dev->pending_data)) {
+		sms_info("No data is ready, waiting for data recieve.\n");
+		poll_wait(file, &dev->waitq, wait);
+	}
+
+	if (!list_empty(&dev->pending_data))
+		mask |= POLLIN | POLLRDNORM;
+	return mask;
+}
+
+static int smschar_ioctl(struct inode *inode, struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	struct smschar_device_t *dev = file->private_data;
+	void __user *up = (void __user *)arg;
+
+	if (!dev->coredev || !dev->smsclient) {
+		sms_err("no client\n");
+		return -ENODEV;
+	}
+
+	switch (cmd) {
+	case SMSCHAR_SET_DEVICE_MODE:
+		return smscore_set_device_mode(dev->coredev, (int)arg);
+
+	case SMSCHAR_GET_DEVICE_MODE:
+		if (put_user(smscore_get_device_mode(dev->coredev),
+				(int *)up))
+				return -EFAULT;
+		break;
+/*##w21558, Added*/
+	case SMSCHAR_RESET_DEVICE_MODE:
+		return smscore_reset_device_mode(dev->coredev);
+/*}}*/
+
+	case SMSCHAR_IS_DEVICE_PNP_EVENT:
+		{
+			sms_info("Waiting for PnP event.\n");
+			wait_event_interruptible(g_pnp_event,
+						 !g_pnp_status_changed);
+			g_pnp_status_changed = 0;
+			sms_info("PnP Event %d.\n", g_smschar_inuse);
+			if (put_user(g_smschar_inuse, (int *)up))
+				return -EFAULT;
+			break;
+		}
+	case SMSCHAR_GET_BUFFER_SIZE:
+		{
+			if (put_user
+			    (smscore_get_common_buffer_size(dev->coredev),
+			     (int *)up))
+				return -EFAULT;
+
+			break;
+		}
+
+	case SMSCHAR_WAIT_GET_BUFFER:
+		{
+			struct smschar_buffer_t touser;
+			int rc;
+
+			rc = smschar_wait_get_buffer(dev, &touser);
+			if (rc < 0)
+				return rc;
+
+			if (copy_to_user(up, &touser,
+					 sizeof(struct smschar_buffer_t)))
+				return -EFAULT;
+
+			break;
+		}
+	case SMSCHAR_CANCEL_WAIT_BUFFER:
+		{
+			dev->cancel_waitq = 1;
+			wake_up_interruptible(&dev->waitq);
+			break;
+		}
+	case SMSCHAR_GET_FW_FILE_NAME:
+		{
+			if (!up)
+				return -EINVAL;
+			return smscore_get_fw_filename(dev->coredev,
+				       ((struct
+					 smschar_get_fw_filename_ioctl_t
+					 *)up)->mode,
+				       ((struct
+					 smschar_get_fw_filename_ioctl_t
+					 *)up)->filename);
+		}
+	case SMSCHAR_SEND_FW_FILE:
+		{
+			if (!up)
+				return -EINVAL;
+			return smscore_send_fw_file(dev->coredev,
+					((struct
+					smschar_send_fw_file_ioctl_t
+					*)up)->fw_buf,
+					((struct
+					smschar_send_fw_file_ioctl_t
+					*)up)->fw_size);
+		}
+
+  /* ##w21558, Added to tuner power control */
+	case SMSCHAR_SET_POWER_DOWN:
+		return smsmdtv_power_control(0);
+
+	case SMSCHAR_SET_POWER_UP:
+		return smsmdtv_power_control(1);
+	/* End */
+	default:
+		return -ENOIOCTLCMD;
+	}
+
+	return 0;
+}
+
+struct file_operations smschar_fops = {
+	.owner = THIS_MODULE,
+	.read = smschar_read,
+	.write = smschar_write,
+	.open = smschar_open,
+	.release = smschar_release,
+	.mmap = smschar_mmap,
+	.poll = smschar_poll,
+	.ioctl = smschar_ioctl,
+};
+
+static int smschar_setup_cdev(struct smschar_device_t *dev, int index)
+{
+	int rc, devno = MKDEV(smschar_major, smschar_minor + index);
+
+	cdev_init(&dev->cdev, &smschar_fops);
+
+	dev->cdev.owner = THIS_MODULE;
+	dev->cdev.ops = &smschar_fops;
+
+	kobject_set_name(&dev->cdev.kobj, "Siano_sms%d", index);
+	rc = cdev_add(&dev->cdev, devno, 1);
+	sms_info("exiting %p %d, rc %d", dev, index, rc);
+
+	if (index == 0)
+		device_create(smschar_class, \
+			NULL, devno, NULL, "mdtvctrl");
+	else
+		device_create(smschar_class, \
+			NULL, devno, NULL, "mdtv%d", index);
+	return rc;
+}
+
+/**
+ * smschar callback that called when device plugged in/out. the function
+ * register or unregisters char device interface according to plug in/out
+ *
+ * @param coredev pointer to device that is being plugged in/out
+ * @param device pointer to system device object
+ * @param arrival 1 on plug-on, 0 othewise
+ *
+ * @return 0 on success, <0 on error.
+ */
+static int smschar_hotplug(struct smscore_device_t *coredev,
+			   struct device *device, int arrival)
+{
+	int rc = 0, i;
+
+	/*sms_info("entering %d\n", arrival);*/
+
+	g_pnp_status_changed = 1;
+	if (arrival) {
+		/* currently only 1 instance supported */
+		if (!g_smschar_inuse) {
+			/* data notification callbacks assignment */
+			memset(smschar_devices, 0, SMSCHAR_NR_DEVS *
+			       sizeof(struct smschar_device_t));
+
+			/* Initialize each device. */
+			for (i = 0; i < SMSCHAR_NR_DEVS; i++) {
+				/*sms_info("create device %d", i);*/
+				smschar_setup_cdev(&smschar_devices[i], i);
+				INIT_LIST_HEAD(&smschar_devices[i].
+					       pending_data);
+				spin_lock_init(&smschar_devices[i].lock);
+				init_waitqueue_head(&smschar_devices[i].waitq);
+
+				smschar_devices[i].coredev = coredev;
+				smschar_devices[i].device_index = i;
+			}
+			g_smschar_inuse = 1;
+			wake_up_interruptible(&g_pnp_event);
+		}
+	} else {
+		/* currently only 1 instance supported */
+		if (g_smschar_inuse) {
+			/* Get rid of our char dev entries */
+			for (i = 0; i < SMSCHAR_NR_DEVS; i++) {
+				cdev_del(&smschar_devices[i].cdev);
+				/*sms_info("remove device %d\n", i);*/
+			}
+
+			g_smschar_inuse = 0;
+			wake_up_interruptible(&g_pnp_event);
+		}
+	}
+
+	/*sms_info("exiting, rc %d\n", rc);*/
+
+	return rc;/* succeed */
+}
+
+int smschar_register(void)
+{
+	dev_t devno = MKDEV(smschar_major, smschar_minor);
+	int rc = -1;
+
+	sms_info("registering device major=%d minor=%d\n", smschar_major,
+		smschar_minor);
+	if (smschar_major) {
+		rc = register_chrdev_region(devno, SMSCHAR_NR_DEVS, "smschar");
+	} else {
+		rc = alloc_chrdev_region(&devno, smschar_minor,
+					SMSCHAR_NR_DEVS, "smschar");
+		smschar_major = MAJOR(devno);
+	}
+
+	if (rc < 0) {
+		sms_warn("smschar: can't get major %d\n", smschar_major);
+		return rc;
+	}
+	init_waitqueue_head(&g_pnp_event);
+
+	smschar_class = class_create(THIS_MODULE, "SMSMdtv");
+	if (IS_ERR(smschar_class)) {
+		sms_err("smschar:can't create SMSMdtv class");
+		return -1;
+	}
+
+	return smscore_register_hotplug(smschar_hotplug);
+}
+
+void smschar_unregister(void)
+{
+	dev_t devno = MKDEV(smschar_major, smschar_minor);
+	int i = 0;
+
+	for (i = 0; i < SMSCHAR_NR_DEVS; i++)
+		device_destroy(smschar_class, MKDEV(smschar_major, i));
+
+	class_destroy(smschar_class);
+	unregister_chrdev_region(devno, SMSCHAR_NR_DEVS);
+	smscore_unregister_hotplug(smschar_hotplug);
+	sms_info("unregistered\n");
+}
diff --git a/drivers/media/dvb/siano/smscharioctl.h b/drivers/media/dvb/siano/smscharioctl.h
new file mode 100644
index 0000000..c62a126
--- /dev/null
+++ b/drivers/media/dvb/siano/smscharioctl.h
@@ -0,0 +1,58 @@
+/****************************************************************
+
+Siano Mobile Silicon, Inc.
+MDTV receiver kernel modules.
+Copyright (C) 2006-2008, Uri Shkolnik
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+****************************************************************/
+#ifndef __SMS_CHAR_IOCTL_H__
+#define __SMS_CHAR_IOCTL_H__
+
+#include <linux/ioctl.h>
+
+struct smschar_buffer_t {
+	unsigned long offset;	/* offset in common buffer (mapped to user) */
+	int size;
+};
+
+struct smschar_get_fw_filename_ioctl_t {
+	int mode;
+	char filename[200];
+};
+
+struct smschar_send_fw_file_ioctl_t {
+	char *fw_buf;
+	int fw_size;
+};
+
+#define SMSCHAR_SET_DEVICE_MODE		_IOW('K', 0, int)
+#define SMSCHAR_GET_DEVICE_MODE		_IOR('K', 1, int)
+#define SMSCHAR_GET_BUFFER_SIZE		_IOR('K', 2, int)
+#define SMSCHAR_WAIT_GET_BUFFER		_IOR('K', 3, struct smschar_buffer_t)
+#define SMSCHAR_IS_DEVICE_PNP_EVENT 	_IOR('K', 4, int)
+#define SMSCHAR_GET_FW_FILE_NAME	\
+	_IOWR('K', 5, struct smschar_get_fw_filename_ioctl_t)
+#define SMSCHAR_SEND_FW_FILE		\
+	_IOW('K', 6, struct smschar_send_fw_file_ioctl_t)
+#define SMSCHAR_CANCEL_WAIT_BUFFER	_IO('K', 7)
+
+/*##w21558, SMS1130 power control*/
+#define SMSCHAR_SET_POWER_UP   _IOW('K', 8, int)
+#define SMSCHAR_SET_POWER_DOWN _IOW('K', 9, int)
+/*##w21558, to reset device mode*/
+#define SMSCHAR_RESET_DEVICE_MODE _IOW('K', 10, int)
+
+#endif /* __SMS_CHAR_IOCTL_H__ */
diff --git a/drivers/media/dvb/siano/smscoreapi.c b/drivers/media/dvb/siano/smscoreapi.c
index cf613f2..6e03a5f 100644
--- a/drivers/media/dvb/siano/smscoreapi.c
+++ b/drivers/media/dvb/siano/smscoreapi.c
@@ -1,25 +1,23 @@
-/*
- *  Siano core API module
- *
- *  This file contains implementation for the interface to sms core component
- *
- *  author: Anatoly Greenblat
- *
- *  Copyright (c), 2005-2008 Siano Mobile Silicon, Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation;
- *
- *  Software distributed under the License is distributed on an "AS IS"
- *  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
- *
- *  See the GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
+/****************************************************************
+
+ Siano Mobile Silicon, Inc.
+ MDTV receiver kernel modules.
+ Copyright (C) 2006-2008, Uri Shkolnik
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 2 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ ****************************************************************/
 
 #include <linux/kernel.h>
 #include <linux/init.h>
@@ -28,16 +26,41 @@
 #include <linux/dma-mapping.h>
 #include <linux/delay.h>
 #include <linux/io.h>
-
+#include <linux/uaccess.h>
 #include <linux/firmware.h>
+#include <linux/wait.h>
+
+#include <asm/byteorder.h>
 
 #include "smscoreapi.h"
+#include "smsendian.h"
 #include "sms-cards.h"
+#include "smsir.h"
+
+#define MAX_GPIO_PIN_NUMBER	31
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 10)
+/*#define REQUEST_FIRMWARE_SUPPORTED*/
+#undef REQUEST_FIRMWARE_SUPPORTED
+/*#define DEFAULT_FW_FILE_PATH "/system/mdtv"*/
+#define DEFAULT_FW_FILE_PATH "/system/etc/firmware"
+#else
+/*#define DEFAULT_FW_FILE_PATH "/lib/firmware"*/
+/*#define DEFAULT_FW_FILE_PATH "/system/mdtv"*/
+#define DEFAULT_FW_FILE_PATH "/system/etc/firmware"
+#endif
+
+/* Debug level is low */
+int sms_debug = 7;
 
-int sms_debug;
 module_param_named(debug, sms_debug, int, 0644);
 MODULE_PARM_DESC(debug, "set debug level (info=1, adv=2 (or-able))");
 
+/*##w21558, mode change : 4 --> 2*/
+static int default_mode = DEVICE_MODE_DAB_TDMB;
+module_param(default_mode, int, 0644);
+MODULE_PARM_DESC(default_mode, "default firmware id (device mode)");
+
 struct smscore_device_notifyee_t {
 	struct list_head entry;
 	hotplug_t hotplug;
@@ -45,53 +68,17 @@ struct smscore_device_notifyee_t {
 
 struct smscore_idlist_t {
 	struct list_head entry;
-	int		id;
-	int		data_type;
+	int id;
+	int data_type;
 };
 
 struct smscore_client_t {
 	struct list_head entry;
 	struct smscore_device_t *coredev;
-	void			*context;
-	struct list_head 	idlist;
-	onresponse_t	onresponse_handler;
-	onremove_t		onremove_handler;
-};
-
-struct smscore_device_t {
-	struct list_head entry;
-
-	struct list_head clients;
-	struct list_head subclients;
-	spinlock_t		clientslock;
-
-	struct list_head buffers;
-	spinlock_t		bufferslock;
-	int				num_buffers;
-
-	void			*common_buffer;
-	int				common_buffer_size;
-	dma_addr_t		common_buffer_phys;
-
-	void			*context;
-	struct device	*device;
-
-	char			devpath[32];
-	unsigned long	device_flags;
-
-	setmode_t		setmode_handler;
-	detectmode_t	detectmode_handler;
-	sendrequest_t	sendrequest_handler;
-	preload_t		preload_handler;
-	postload_t		postload_handler;
-
-	int				mode, modes_supported;
-
-	struct completion version_ex_done, data_download_done, trigger_done;
-	struct completion init_device_done, reload_start_done, resume_done;
-
-	int board_id;
-	int led_state;
+	void *context;
+	struct list_head idlist;
+	onresponse_t onresponse_handler;
+	onremove_t onremove_handler;
 };
 
 void smscore_set_board_id(struct smscore_device_t *core, int id)
@@ -99,13 +86,6 @@ void smscore_set_board_id(struct smscore_device_t *core, int id)
 	core->board_id = id;
 }
 
-int smscore_led_state(struct smscore_device_t *core, int led)
-{
-	if (led >= 0)
-		core->led_state = led;
-	return core->led_state;
-}
-
 int smscore_get_board_id(struct smscore_device_t *core)
 {
 	return core->board_id;
@@ -113,9 +93,9 @@ int smscore_get_board_id(struct smscore_device_t *core)
 
 struct smscore_registry_entry_t {
 	struct list_head entry;
-	char			devpath[32];
-	int				mode;
-	enum sms_device_type_st	type;
+	char devpath[32];
+	int mode;
+	enum sms_device_type_st type;
 };
 
 static struct list_head g_smscore_notifyees;
@@ -125,29 +105,22 @@ static struct mutex g_smscore_deviceslock;
 static struct list_head g_smscore_registry;
 static struct mutex g_smscore_registrylock;
 
-static int default_mode = 4;
-
-module_param(default_mode, int, 0644);
-MODULE_PARM_DESC(default_mode, "default firmware id (device mode)");
-
 static struct smscore_registry_entry_t *smscore_find_registry(char *devpath)
 {
 	struct smscore_registry_entry_t *entry;
 	struct list_head *next;
 
 	kmutex_lock(&g_smscore_registrylock);
-	for (next = g_smscore_registry.next;
-	     next != &g_smscore_registry;
-	     next = next->next) {
+	for (next = g_smscore_registry.next; next != &g_smscore_registry; next
+			= next->next) {
 		entry = (struct smscore_registry_entry_t *) next;
 		if (!strcmp(entry->devpath, devpath)) {
 			kmutex_unlock(&g_smscore_registrylock);
 			return entry;
 		}
 	}
-	entry = (struct smscore_registry_entry_t *)
-			kmalloc(sizeof(struct smscore_registry_entry_t),
-				GFP_KERNEL);
+	entry = /* (struct smscore_registry_entry_t *) */kmalloc(
+			sizeof(struct smscore_registry_entry_t), GFP_KERNEL);
 	if (entry) {
 		entry->mode = default_mode;
 		strcpy(entry->devpath, devpath);
@@ -196,8 +169,7 @@ void smscore_registry_setmode(char *devpath, int mode)
 }
 
 static void smscore_registry_settype(char *devpath,
-				     enum sms_device_type_st type)
-{
+		enum sms_device_type_st type) {
 	struct smscore_registry_entry_t *entry;
 
 	entry = smscore_find_registry(devpath);
@@ -207,16 +179,12 @@ static void smscore_registry_settype(char *devpath,
 		sms_err("No registry found.");
 }
 
-
 static void list_add_locked(struct list_head *new, struct list_head *head,
-			    spinlock_t *lock)
-{
+		spinlock_t *lock) {
 	unsigned long flags;
 
 	spin_lock_irqsave(lock, flags);
-
 	list_add(new, head);
-
 	spin_unlock_irqrestore(lock, flags);
 }
 
@@ -234,16 +202,16 @@ int smscore_register_hotplug(hotplug_t hotplug)
 	struct list_head *next, *first;
 	int rc = 0;
 
+	sms_info(" entering... smscore_register_hotplug \n");
 	kmutex_lock(&g_smscore_deviceslock);
 
 	notifyee = kmalloc(sizeof(struct smscore_device_notifyee_t),
-			   GFP_KERNEL);
+		GFP_KERNEL);
 	if (notifyee) {
 		/* now notify callback about existing devices */
 		first = &g_smscore_devices;
-		for (next = first->next;
-		     next != first && !rc;
-		     next = next->next) {
+		for (next = first->next; next != first && !rc;
+			next = next->next) {
 			struct smscore_device_t *coredev =
 				(struct smscore_device_t *) next;
 			rc = hotplug(coredev, coredev->device, 1);
@@ -272,13 +240,15 @@ void smscore_unregister_hotplug(hotplug_t hotplug)
 {
 	struct list_head *next, *first;
 
+	sms_info(" exiting... smscore_register_hotplug \n");
+
 	kmutex_lock(&g_smscore_deviceslock);
 
 	first = &g_smscore_notifyees;
 
 	for (next = first->next; next != first;) {
 		struct smscore_device_notifyee_t *notifyee =
-			(struct smscore_device_notifyee_t *) next;
+				(struct smscore_device_notifyee_t *) next;
 		next = next->next;
 
 		if (notifyee->hotplug == hotplug) {
@@ -302,8 +272,7 @@ static void smscore_notify_clients(struct smscore_device_t *coredev)
 }
 
 static int smscore_notify_callbacks(struct smscore_device_t *coredev,
-				    struct device *device, int arrival)
-{
+		struct device *device, int arrival) {
 	struct list_head *next, *first;
 	int rc = 0;
 
@@ -313,7 +282,7 @@ static int smscore_notify_callbacks(struct smscore_device_t *coredev,
 
 	for (next = first->next; next != first; next = next->next) {
 		rc = ((struct smscore_device_notifyee_t *) next)->
-				hotplug(coredev, device, arrival);
+			 hotplug(coredev, device, arrival);
 		if (rc < 0)
 			break;
 	}
@@ -321,12 +290,10 @@ static int smscore_notify_callbacks(struct smscore_device_t *coredev,
 	return rc;
 }
 
-static struct
-smscore_buffer_t *smscore_createbuffer(u8 *buffer, void *common_buffer,
-				       dma_addr_t common_buffer_phys)
-{
-	struct smscore_buffer_t *cb =
-		kmalloc(sizeof(struct smscore_buffer_t), GFP_KERNEL);
+static struct smscore_buffer_t *smscore_createbuffer(u8 *buffer,
+		void *common_buffer, dma_addr_t common_buffer_phys) {
+	struct smscore_buffer_t *cb = kmalloc(sizeof(struct smscore_buffer_t),
+			GFP_KERNEL);
 	if (!cb) {
 		sms_info("kmalloc(...) failed");
 		return NULL;
@@ -350,11 +317,11 @@ smscore_buffer_t *smscore_createbuffer(u8 *buffer, void *common_buffer,
  * @return 0 on success, <0 on error.
  */
 int smscore_register_device(struct smsdevice_params_t *params,
-			    struct smscore_device_t **coredev)
-{
+		struct smscore_device_t **coredev) {
 	struct smscore_device_t *dev;
 	u8 *buffer;
 
+	sms_info(" entering....smscore_register_device \n");
 	dev = kzalloc(sizeof(struct smscore_device_t), GFP_KERNEL);
 	if (!dev) {
 		sms_info("kzalloc(...) failed");
@@ -372,31 +339,42 @@ int smscore_register_device(struct smsdevice_params_t *params,
 	spin_lock_init(&dev->clientslock);
 	spin_lock_init(&dev->bufferslock);
 
-	/* init completion events */
+	/* Device protocol completion events */
 	init_completion(&dev->version_ex_done);
 	init_completion(&dev->data_download_done);
 	init_completion(&dev->trigger_done);
 	init_completion(&dev->init_device_done);
 	init_completion(&dev->reload_start_done);
 	init_completion(&dev->resume_done);
+	init_completion(&dev->gpio_configuration_done);
+	init_completion(&dev->gpio_set_level_done);
+	init_completion(&dev->gpio_get_level_done);
+	init_completion(&dev->ir_init_done);
+
+	/* Buffer management */
+	init_waitqueue_head(&dev->buffer_mng_waitq);
 
 	/* alloc common buffer */
+	sms_info(" entering...alloc common buffer \n");
 	dev->common_buffer_size = params->buffer_size * params->num_buffers;
+
+/* w21558 */
+#if defined(MOT_FEAT_OMAP_DMA_USE)
 	dev->common_buffer = dma_alloc_coherent(NULL, dev->common_buffer_size,
-						&dev->common_buffer_phys,
-						GFP_KERNEL | GFP_DMA);
+			&dev->common_buffer_phys, GFP_KERNEL | GFP_DMA);
 	if (!dev->common_buffer) {
 		smscore_unregister_device(dev);
 		return -ENOMEM;
 	}
+#endif
 
 	/* prepare dma buffers */
-	for (buffer = dev->common_buffer;
-	     dev->num_buffers < params->num_buffers;
-	     dev->num_buffers++, buffer += params->buffer_size) {
-		struct smscore_buffer_t *cb =
-			smscore_createbuffer(buffer, dev->common_buffer,
-					     dev->common_buffer_phys);
+	sms_info("entering... prepare dma buffers \n");
+	for (buffer = dev->common_buffer; dev->num_buffers <
+			params->num_buffers; dev->num_buffers++, buffer
+			+= params->buffer_size) {
+		struct smscore_buffer_t *cb = smscore_createbuffer(buffer,
+				dev->common_buffer, dev->common_buffer_phys);
 		if (!cb) {
 			smscore_unregister_device(dev);
 			return -ENOMEM;
@@ -428,7 +406,70 @@ int smscore_register_device(struct smsdevice_params_t *params,
 
 	*coredev = dev;
 
-	sms_info("device %p created", dev);
+	sms_info("device %p created\n", dev);
+
+	return 0;
+}
+
+static int smscore_sendrequest_and_wait(struct smscore_device_t *coredev,
+		void *buffer, size_t size, struct completion *completion) {
+	int rc = coredev->sendrequest_handler(coredev->context, buffer, size);
+	if (rc < 0) {
+		sms_info("sendrequest returned error %d", rc);
+		return rc;
+	}
+
+	return wait_for_completion_timeout(completion,
+			msecs_to_jiffies(SMS_PROTOCOL_MAX_RAOUNDTRIP_MS)) ? 0 : -ETIME;
+}
+
+/**
+ * Starts & enables IR operations
+ *
+ * @return 0 on success, < 0 on error.
+ */
+static int smscore_init_ir(struct smscore_device_t *coredev)
+{
+	int ir_io;
+	int rc;
+	void *buffer;
+
+	coredev->ir.input_dev = NULL;
+	ir_io = sms_get_board(smscore_get_board_id(coredev))->board_cfg.ir;
+	if (ir_io) {/* only if IR port exist we use IR sub-module */
+		sms_info("IR loading");
+		rc = sms_ir_init(coredev);
+
+		if	(rc != 0)
+			sms_err("Error initialization DTV IR sub-module");
+		else {
+			buffer = kmalloc(sizeof(struct SmsMsgData_ST2) +
+						SMS_DMA_ALIGNMENT,
+						GFP_KERNEL | GFP_DMA);
+			if (buffer) {
+				struct SmsMsgData_ST2 *msg =
+				(struct SmsMsgData_ST2 *)
+				SMS_ALIGN_ADDRESS(buffer);
+
+				SMS_INIT_MSG(&msg->xMsgHeader,
+						MSG_SMS_START_IR_REQ,
+						sizeof(struct SmsMsgData_ST2));
+				msg->msgData[0] = coredev->ir.controller;
+				msg->msgData[1] = coredev->ir.timeout;
+
+				smsendian_handle_tx_message(
+					(struct SmsMsgHdr_ST2 *)msg);
+				rc = smscore_sendrequest_and_wait(coredev, msg,
+						msg->xMsgHeader. msgLength,
+						&coredev->ir_init_done);
+
+				kfree(buffer);
+			} else
+				sms_err
+				("Sending IR initialization message failed");
+		}
+	} else
+		sms_info("IR port has not been detected");
 
 	return 0;
 }
@@ -443,16 +484,22 @@ int smscore_register_device(struct smsdevice_params_t *params,
  */
 int smscore_start_device(struct smscore_device_t *coredev)
 {
-	int rc = smscore_set_device_mode(
-			coredev, smscore_registry_getmode(coredev->devpath));
+	int rc;
+
+	sms_info("%p starting......\n", coredev);
+#ifdef REQUEST_FIRMWARE_SUPPORTED
+	rc = smscore_set_device_mode(coredev, smscore_registry_getmode(
+			coredev->devpath));
 	if (rc < 0) {
-		sms_info("set device mode faile , rc %d", rc);
+		sms_info("set device mode failed , rc %d", rc);
 		return rc;
 	}
+#endif
 
 	kmutex_lock(&g_smscore_deviceslock);
 
 	rc = smscore_notify_callbacks(coredev, coredev->device, 1);
+	smscore_init_ir(coredev);
 
 	sms_info("device %p started, rc %d", coredev, rc);
 
@@ -461,32 +508,21 @@ int smscore_start_device(struct smscore_device_t *coredev)
 	return rc;
 }
 
-static int smscore_sendrequest_and_wait(struct smscore_device_t *coredev,
-					void *buffer, size_t size,
-					struct completion *completion)
-{
-	int rc = coredev->sendrequest_handler(coredev->context, buffer, size);
-	if (rc < 0) {
-		sms_info("sendrequest returned error %d", rc);
-		return rc;
-	}
-
-	return wait_for_completion_timeout(completion,
-					   msecs_to_jiffies(10000)) ?
-						0 : -ETIME;
-}
-
 static int smscore_load_firmware_family2(struct smscore_device_t *coredev,
-					 void *buffer, size_t size)
-{
+		void *buffer, size_t size) {
 	struct SmsFirmware_ST *firmware = (struct SmsFirmware_ST *) buffer;
 	struct SmsMsgHdr_ST *msg;
-	u32 mem_address = firmware->StartAddress;
+	u32 mem_address;
 	u8 *payload = firmware->Payload;
 	int rc = 0;
 
+	firmware->StartAddress = le32_to_cpu(firmware->StartAddress);
+	firmware->Length = le32_to_cpu(firmware->Length);
+
+	mem_address = firmware->StartAddress;
+
 	sms_info("loading FW to addr 0x%x size %d",
-		 mem_address, firmware->Length);
+			mem_address, firmware->Length);
 	if (coredev->preload_handler) {
 		rc = coredev->preload_handler(coredev->context);
 		if (rc < 0)
@@ -501,35 +537,35 @@ static int smscore_load_firmware_family2(struct smscore_device_t *coredev,
 	if (coredev->mode != DEVICE_MODE_NONE) {
 		sms_debug("sending reload command.");
 		SMS_INIT_MSG(msg, MSG_SW_RELOAD_START_REQ,
-			     sizeof(struct SmsMsgHdr_ST));
-		rc = smscore_sendrequest_and_wait(coredev, msg,
-						  msg->msgLength,
-						  &coredev->reload_start_done);
+				sizeof(struct SmsMsgHdr_ST));
+		smsendian_handle_tx_message((struct SmsMsgHdr_ST *)msg);
+		rc = smscore_sendrequest_and_wait(coredev, msg, msg->msgLength,
+				&coredev->reload_start_done);
 		mem_address = *(u32 *) &payload[20];
 	}
 
 	while (size && rc >= 0) {
 		struct SmsDataDownload_ST *DataMsg =
-			(struct SmsDataDownload_ST *) msg;
-		int payload_size = min((int) size, SMS_MAX_PAYLOAD_SIZE);
+				(struct SmsDataDownload_ST *) msg;
+		int payload_size = min((int)size, SMS_MAX_PAYLOAD_SIZE);
 
 		SMS_INIT_MSG(msg, MSG_SMS_DATA_DOWNLOAD_REQ,
-			     (u16)(sizeof(struct SmsMsgHdr_ST) +
-				      sizeof(u32) + payload_size));
+				(u16) (sizeof(struct SmsMsgHdr_ST) +
+						sizeof(u32) + payload_size));
 
 		DataMsg->MemAddr = mem_address;
 		memcpy(DataMsg->Payload, payload, payload_size);
 
+		smsendian_handle_tx_message((struct SmsMsgHdr_ST *)msg);
 		if ((coredev->device_flags & SMS_ROM_NO_RESPONSE) &&
-		    (coredev->mode == DEVICE_MODE_NONE))
-			rc = coredev->sendrequest_handler(
-				coredev->context, DataMsg,
-				DataMsg->xMsgHeader.msgLength);
+				(coredev->mode	== DEVICE_MODE_NONE)) {
+			rc = coredev->sendrequest_handler(coredev->context, DataMsg,
+					DataMsg->xMsgHeader. msgLength);
+		}
 		else
-			rc = smscore_sendrequest_and_wait(
-				coredev, DataMsg,
-				DataMsg->xMsgHeader.msgLength,
-				&coredev->data_download_done);
+			rc = smscore_sendrequest_and_wait(coredev, DataMsg,
+					DataMsg->xMsgHeader. msgLength,
+					&coredev->data_download_done);
 
 		payload += payload_size;
 		size -= payload_size;
@@ -539,47 +575,48 @@ static int smscore_load_firmware_family2(struct smscore_device_t *coredev,
 	if (rc >= 0) {
 		if (coredev->mode == DEVICE_MODE_NONE) {
 			struct SmsMsgData_ST *TriggerMsg =
-				(struct SmsMsgData_ST *) msg;
+					(struct SmsMsgData_ST *) msg;
 
 			SMS_INIT_MSG(msg, MSG_SMS_SWDOWNLOAD_TRIGGER_REQ,
-				     sizeof(struct SmsMsgHdr_ST) +
-				     sizeof(u32) * 5);
+					sizeof(struct SmsMsgHdr_ST) +
+					sizeof(u32) * 5);
 
 			TriggerMsg->msgData[0] = firmware->StartAddress;
-						/* Entry point */
+			/* Entry point */
 			TriggerMsg->msgData[1] = 5; /* Priority */
 			TriggerMsg->msgData[2] = 0x200; /* Stack size */
 			TriggerMsg->msgData[3] = 0; /* Parameter */
 			TriggerMsg->msgData[4] = 4; /* Task ID */
 
+			smsendian_handle_tx_message((struct SmsMsgHdr_ST *)msg);
 			if (coredev->device_flags & SMS_ROM_NO_RESPONSE) {
-				rc = coredev->sendrequest_handler(
-					coredev->context, TriggerMsg,
+				rc = coredev->sendrequest_handler(coredev->
+					context, TriggerMsg,
 					TriggerMsg->xMsgHeader.msgLength);
+
 				msleep(100);
 			} else
-				rc = smscore_sendrequest_and_wait(
-					coredev, TriggerMsg,
+				rc = smscore_sendrequest_and_wait(coredev,
+					TriggerMsg,
 					TriggerMsg->xMsgHeader.msgLength,
 					&coredev->trigger_done);
+
 		} else {
 			SMS_INIT_MSG(msg, MSG_SW_RELOAD_EXEC_REQ,
-				     sizeof(struct SmsMsgHdr_ST));
-
-			rc = coredev->sendrequest_handler(coredev->context,
-							  msg, msg->msgLength);
+					sizeof(struct SmsMsgHdr_ST));
+			smsendian_handle_tx_message((struct SmsMsgHdr_ST *)msg);
+			rc = coredev->sendrequest_handler(coredev->context, msg,
+					msg->msgLength);
 		}
 		msleep(500);
 	}
 
-	sms_debug("rc=%d, postload=%p ", rc,
-		  coredev->postload_handler);
+	sms_debug("rc=%d, postload=%p ", rc, coredev->postload_handler);
 
 	kfree(msg);
 
 	return ((rc >= 0) && coredev->postload_handler) ?
-		coredev->postload_handler(coredev->context) :
-		rc;
+			coredev->postload_handler(coredev->context) : rc;
 }
 
 /**
@@ -593,15 +630,16 @@ static int smscore_load_firmware_family2(struct smscore_device_t *coredev,
  * @return 0 on success, <0 on error.
  */
 static int smscore_load_firmware_from_file(struct smscore_device_t *coredev,
-					   char *filename,
-					   loadfirmware_t loadfirmware_handler)
-{
+		char *filename, loadfirmware_t loadfirmware_handler) {
 	int rc = -ENOENT;
+	u8 *fw_buf = NULL;
+	u32 fw_buf_size = 0;
+
+#ifdef REQUEST_FIRMWARE_SUPPORTED
 	const struct firmware *fw;
-	u8 *fw_buffer;
 
-	if (loadfirmware_handler == NULL && !(coredev->device_flags &
-					      SMS_DEVICE_FAMILY2))
+	if (loadfirmware_handler == NULL && !(coredev->device_flags
+			& SMS_DEVICE_FAMILY2))
 		return -EINVAL;
 
 	rc = request_firmware(&fw, filename, coredev->device);
@@ -610,26 +648,38 @@ static int smscore_load_firmware_from_file(struct smscore_device_t *coredev,
 		return rc;
 	}
 	sms_info("read FW %s, size=%zd", filename, fw->size);
-	fw_buffer = kmalloc(ALIGN(fw->size, SMS_ALLOC_ALIGNMENT),
-			    GFP_KERNEL | GFP_DMA);
-	if (fw_buffer) {
-		memcpy(fw_buffer, fw->data, fw->size);
-
-		rc = (coredev->device_flags & SMS_DEVICE_FAMILY2) ?
-		      smscore_load_firmware_family2(coredev,
-						    fw_buffer,
-						    fw->size) :
-		      loadfirmware_handler(coredev->context,
-					   fw_buffer, fw->size);
-
-		kfree(fw_buffer);
-	} else {
+	printk(KERN_INFO "read FW %s, size=%zd\n", filename, fw->size);
+	fw_buf = kmalloc(ALIGN(fw->size, SMS_ALLOC_ALIGNMENT),
+				GFP_KERNEL | GFP_DMA);
+	if (!fw_buf) {
 		sms_info("failed to allocate firmware buffer");
-		rc = -ENOMEM;
+		return -ENOMEM;
 	}
+	memcpy(fw_buf, fw->data, fw->size);
+	fw_buf_size = fw->size;
+#else
+	if (!coredev->fw_buf) {
+		sms_info("missing fw file buffer");
+		return -EINVAL;
+	}
+	fw_buf = coredev->fw_buf;
+	fw_buf_size = coredev->fw_buf_size;
+	sms_info("fw_buf_size = %d\n", fw_buf_size);
+#endif
 
-	release_firmware(fw);
+	rc = (coredev->device_flags & SMS_DEVICE_FAMILY2) ?
+		smscore_load_firmware_family2(coredev, fw_buf, fw_buf_size)
+		: loadfirmware_handler(coredev->context, fw_buf,
+		fw_buf_size);
 
+	kfree(fw_buf);
+
+#ifdef REQUEST_FIRMWARE_SUPPORTED
+	release_firmware(fw);
+#else
+	coredev->fw_buf = NULL;
+	coredev->fw_buf_size = 0;
+#endif
 	return rc;
 }
 
@@ -650,6 +700,9 @@ void smscore_unregister_device(struct smscore_device_t *coredev)
 
 	kmutex_lock(&g_smscore_deviceslock);
 
+	/* Release input device (IR) resources */
+	sms_ir_exit(coredev);
+
 	smscore_notify_clients(coredev);
 	smscore_notify_callbacks(coredev, NULL, 0);
 
@@ -657,20 +710,23 @@ void smscore_unregister_device(struct smscore_device_t *coredev)
 	 * onresponse must no longer be called */
 
 	while (1) {
-		while ((cb = smscore_getbuffer(coredev))) {
+		while (!list_empty(&coredev->buffers)) {
+			cb = (struct smscore_buffer_t *) coredev->buffers.next;
+			list_del(&cb->entry);
 			kfree(cb);
 			num_buffers++;
 		}
 		if (num_buffers == coredev->num_buffers)
 			break;
+
 		if (++retry > 10) {
 			sms_info("exiting although "
-				 "not all buffers released.");
+					"not all buffers released.");
 			break;
 		}
 
 		sms_info("waiting for %d buffer(s)",
-			 coredev->num_buffers - num_buffers);
+				coredev->num_buffers - num_buffers);
 		msleep(100);
 	}
 
@@ -678,8 +734,10 @@ void smscore_unregister_device(struct smscore_device_t *coredev)
 
 	if (coredev->common_buffer)
 		dma_free_coherent(NULL, coredev->common_buffer_size,
-				  coredev->common_buffer,
-				  coredev->common_buffer_phys);
+			coredev->common_buffer, coredev->common_buffer_phys);
+
+	if (coredev->fw_buf != NULL)
+		kfree(coredev->fw_buf);
 
 	list_del(&coredev->entry);
 	kfree(coredev);
@@ -689,33 +747,35 @@ void smscore_unregister_device(struct smscore_device_t *coredev)
 	sms_info("device %p destroyed", coredev);
 }
 
+/*##w21558, Removed.*/
+/*
 static int smscore_detect_mode(struct smscore_device_t *coredev)
 {
 	void *buffer = kmalloc(sizeof(struct SmsMsgHdr_ST) + SMS_DMA_ALIGNMENT,
-			       GFP_KERNEL | GFP_DMA);
+			GFP_KERNEL | GFP_DMA);
 	struct SmsMsgHdr_ST *msg =
-		(struct SmsMsgHdr_ST *) SMS_ALIGN_ADDRESS(buffer);
+			(struct SmsMsgHdr_ST *) SMS_ALIGN_ADDRESS(buffer);
 	int rc;
 
 	if (!buffer)
 		return -ENOMEM;
 
 	SMS_INIT_MSG(msg, MSG_SMS_GET_VERSION_EX_REQ,
-		     sizeof(struct SmsMsgHdr_ST));
+			sizeof(struct SmsMsgHdr_ST));
 
+	smsendian_handle_tx_message((struct SmsMsgHdr_ST *)msg);
 	rc = smscore_sendrequest_and_wait(coredev, msg, msg->msgLength,
-					  &coredev->version_ex_done);
+			&coredev->version_ex_done);
 	if (rc == -ETIME) {
 		sms_err("MSG_SMS_GET_VERSION_EX_REQ failed first try");
 
 		if (wait_for_completion_timeout(&coredev->resume_done,
-						msecs_to_jiffies(5000))) {
-			rc = smscore_sendrequest_and_wait(
-				coredev, msg, msg->msgLength,
-				&coredev->version_ex_done);
+				msecs_to_jiffies(5000))) {
+			rc = smscore_sendrequest_and_wait(coredev, msg,
+				msg->msgLength, &coredev->version_ex_done);
 			if (rc < 0)
 				sms_err("MSG_SMS_GET_VERSION_EX_REQ failed "
-					"second try, rc %d", rc);
+						"second try, rc %d", rc);
 		} else
 			rc = -ETIME;
 	}
@@ -724,30 +784,27 @@ static int smscore_detect_mode(struct smscore_device_t *coredev)
 
 	return rc;
 }
+*/
 
 static char *smscore_fw_lkup[][SMS_NUM_OF_DEVICE_TYPES] = {
-	/*Stellar		NOVA A0		Nova B0		VEGA*/
-	/*DVBT*/
-	{"none", "dvb_nova_12mhz.inp", "dvb_nova_12mhz_b0.inp", "none"},
-	/*DVBH*/
-	{"none", "dvb_nova_12mhz.inp", "dvb_nova_12mhz_b0.inp", "none"},
-	/*TDMB*/
-	{"none", "tdmb_nova_12mhz.inp", "none", "none"},
-	/*DABIP*/
-	{"none", "none", "none", "none"},
-	/*BDA*/
-	{"none", "dvb_nova_12mhz.inp", "dvb_nova_12mhz_b0.inp", "none"},
-	/*ISDBT*/
-	{"none", "isdbt_nova_12mhz.inp", "dvb_nova_12mhz.inp", "none"},
-	/*ISDBTBDA*/
-	{"none", "isdbt_nova_12mhz.inp", "isdbt_nova_12mhz_b0.inp", "none"},
-	/*CMMB*/
-	{"none", "none", "none", "cmmb_vega_12mhz.inp"}
-};
-
-static inline char *sms_get_fw_name(struct smscore_device_t *coredev,
-				    int mode, enum sms_device_type_st type)
-{
+/*Stellar               NOVA A0         Nova B0         VEGA */
+/*DVBT*/
+{ "none", "dvb_nova_12mhz.inp", "dvb_nova_12mhz_b0.inp", "none" },
+/*DVBH*/
+{ "none", "dvb_nova_12mhz.inp", "dvb_nova_12mhz_b0.inp", "none" },
+/*TDMB*/
+{ "none", "tdmb_nova_12mhz.inp", "tdmb_nova_12mhz_b0.inp", "none" },
+/*DABIP*/{ "none", "none", "none", "none" },
+/*BDA*/
+{ "none", "dvb_nova_12mhz.inp", "dvb_nova_12mhz_b0.inp", "none" },
+/*ISDBT*/
+{ "none", "isdbt_nova_12mhz.inp", "isdbt_nova_12mhz_b0.inp", "none" },
+/*ISDBTBDA*/
+{ "none", "isdbt_nova_12mhz.inp", "isdbt_nova_12mhz_b0.inp", "none" },
+/*CMMB*/{ "none", "none", "none", "cmmb_vega_12mhz.inp" } };
+
+static inline char *sms_get_fw_name(struct smscore_device_t *coredev, int mode,
+		enum sms_device_type_st type) {
 	char **fw = sms_get_board(smscore_get_board_id(coredev))->fw;
 	return (fw && fw[mode]) ? fw[mode] : smscore_fw_lkup[mode][type];
 }
@@ -764,11 +821,15 @@ static inline char *sms_get_fw_name(struct smscore_device_t *coredev,
  */
 int smscore_set_device_mode(struct smscore_device_t *coredev, int mode)
 {
+/*##w21558, Removed*/
+/*
 	void *buffer;
+*/
 	int rc = 0;
 	enum sms_device_type_st type;
 
 	sms_debug("set device mode to %d", mode);
+	printk(KERN_INFO "%s: set device mode to %d\n", __func__, mode);
 	if (coredev->device_flags & SMS_DEVICE_FAMILY2) {
 		if (mode < DEVICE_MODE_DVBT || mode > DEVICE_MODE_RAW_TUNER) {
 			sms_err("invalid mode specified %d", mode);
@@ -777,6 +838,8 @@ int smscore_set_device_mode(struct smscore_device_t *coredev, int mode)
 
 		smscore_registry_setmode(coredev->devpath, mode);
 
+/*##w21558, Removed*/
+/*
 		if (!(coredev->device_flags & SMS_DEVICE_NOT_READY)) {
 			rc = smscore_detect_mode(coredev);
 			if (rc < 0) {
@@ -784,9 +847,11 @@ int smscore_set_device_mode(struct smscore_device_t *coredev, int mode)
 				return rc;
 			}
 		}
+*/
 
 		if (coredev->mode == mode) {
 			sms_info("device mode %d already set", mode);
+			printk(KERN_INFO "device mode %d already set", mode);
 			return 0;
 		}
 
@@ -797,50 +862,54 @@ int smscore_set_device_mode(struct smscore_device_t *coredev, int mode)
 			fw_filename = sms_get_fw_name(coredev, mode, type);
 
 			rc = smscore_load_firmware_from_file(coredev,
-							     fw_filename, NULL);
+					fw_filename, NULL);
 			if (rc < 0) {
 				sms_warn("error %d loading firmware: %s, "
-					 "trying again with default firmware",
-					 rc, fw_filename);
+					"trying again with default firmware",
+					rc, fw_filename);
 
 				/* try again with the default firmware */
 				fw_filename = smscore_fw_lkup[mode][type];
 				rc = smscore_load_firmware_from_file(coredev,
-							     fw_filename, NULL);
+						fw_filename, NULL);
 
 				if (rc < 0) {
 					sms_warn("error %d loading "
-						 "firmware: %s", rc,
-						 fw_filename);
+							"firmware: %s", rc,
+							fw_filename);
 					return rc;
 				}
 			}
-			sms_log("firmware download success: %s", fw_filename);
+			sms_info("firmware download success: %s", fw_filename);
 		} else
 			sms_info("mode %d supported by running "
-				 "firmware", mode);
+					"firmware", mode);
 
+/*##w21558, Removed*/
+/*
 		buffer = kmalloc(sizeof(struct SmsMsgData_ST) +
-				 SMS_DMA_ALIGNMENT, GFP_KERNEL | GFP_DMA);
+				SMS_DMA_ALIGNMENT, GFP_KERNEL | GFP_DMA);
 		if (buffer) {
 			struct SmsMsgData_ST *msg =
-				(struct SmsMsgData_ST *)
+					(struct SmsMsgData_ST *)
 					SMS_ALIGN_ADDRESS(buffer);
 
 			SMS_INIT_MSG(&msg->xMsgHeader, MSG_SMS_INIT_DEVICE_REQ,
-				     sizeof(struct SmsMsgData_ST));
+					sizeof(struct SmsMsgData_ST));
 			msg->msgData[0] = mode;
 
-			rc = smscore_sendrequest_and_wait(
-				coredev, msg, msg->xMsgHeader.msgLength,
-				&coredev->init_device_done);
+			smsendian_handle_tx_message((struct SmsMsgHdr_ST *)msg);
+			rc = smscore_sendrequest_and_wait(coredev, msg,
+					msg->xMsgHeader. msgLength,
+					&coredev->init_device_done);
 
 			kfree(buffer);
 		} else {
 			sms_err("Could not allocate buffer for "
-				"init device message.");
+					"init device message.");
 			rc = -ENOMEM;
 		}
+*/
 	} else {
 		if (mode < DEVICE_MODE_DVBT || mode > DEVICE_MODE_DVBT_BDA) {
 			sms_err("invalid mode specified %d", mode);
@@ -851,7 +920,7 @@ int smscore_set_device_mode(struct smscore_device_t *coredev, int mode)
 
 		if (coredev->detectmode_handler)
 			coredev->detectmode_handler(coredev->context,
-						    &coredev->mode);
+					&coredev->mode);
 
 		if (coredev->mode != mode && coredev->setmode_handler)
 			rc = coredev->setmode_handler(coredev->context, mode);
@@ -862,12 +931,87 @@ int smscore_set_device_mode(struct smscore_device_t *coredev, int mode)
 		coredev->device_flags &= ~SMS_DEVICE_NOT_READY;
 	}
 
-	if (rc != 0)
+	if (rc < 0)
 		sms_err("return error code %d.", rc);
 	return rc;
 }
 
 /**
+ * calls device handler to get fw file name
+ *
+ * @param coredev pointer to a coredev object returned by
+ *                smscore_register_device
+ * @param filename pointer to user buffer to fill the file name
+ *
+ * @return 0 on success, <0 on error.
+ */
+int smscore_get_fw_filename(struct smscore_device_t *coredev, int mode,
+		char *filename) {
+	int rc = 0;
+	enum sms_device_type_st type;
+	char tmpname[200];
+
+	type = smscore_registry_gettype(coredev->devpath);
+
+#ifdef REQUEST_FIRMWARE_SUPPORTED
+	/* driver not need file system services */
+	tmpname[0] = '\0';
+#else
+	sprintf(tmpname, "%s/%s", DEFAULT_FW_FILE_PATH,
+			smscore_fw_lkup[mode][type]);
+#endif
+	if (copy_to_user(filename, tmpname, strlen(tmpname) + 1)) {
+		sms_err("Failed copy file path to user buffer\n");
+		return -EFAULT;
+	}
+	return rc;
+}
+
+/**
+ * calls device handler to keep fw buff for later use
+ *
+ * @param coredev pointer to a coredev object returned by
+ *                smscore_register_device
+ * @param ufwbuf  pointer to user fw buffer
+ * @param size    size in bytes of buffer
+ *
+ * @return 0 on success, <0 on error.
+ */
+int smscore_send_fw_file(struct smscore_device_t *coredev, u8 *ufwbuf,
+		int size) {
+	int rc = 0;
+
+	/* free old buffer */
+	if (coredev->fw_buf != NULL) {
+		kfree(coredev->fw_buf);
+		coredev->fw_buf = NULL;
+	}
+
+	coredev->fw_buf = kmalloc(ALIGN(size, SMS_ALLOC_ALIGNMENT), GFP_KERNEL
+			| GFP_DMA);
+	if (!coredev->fw_buf) {
+		sms_info("Failed allocate FW buffer memory\n");
+		return -EFAULT;
+	}
+
+	if (copy_from_user(coredev->fw_buf, ufwbuf, size)) {
+		sms_info("Failed copy FW from user buffer\n");
+		kfree(coredev->fw_buf);
+		return -EFAULT;
+	}
+	coredev->fw_buf_size = size;
+
+	return rc;
+}
+
+/* ##w21558, Added */
+int smscore_reset_device_mode(struct smscore_device_t *coredev)
+{
+  coredev->mode = -1;
+  return 0;
+}
+
+/**
  * calls device handler to get current mode of operation
  *
  * @param coredev pointer to a coredev object returned by
@@ -890,28 +1034,26 @@ int smscore_get_device_mode(struct smscore_device_t *coredev)
  * @param id client id (SMS_DONT_CARE for all id)
  *
  */
-static struct
-smscore_client_t *smscore_find_client(struct smscore_device_t *coredev,
-				      int data_type, int id)
-{
+static struct smscore_client_t *smscore_find_client(
+		struct smscore_device_t *coredev, int data_type, int id) {
 	struct smscore_client_t *client = NULL;
 	struct list_head *next, *first;
 	unsigned long flags;
 	struct list_head *firstid, *nextid;
 
-
 	spin_lock_irqsave(&coredev->clientslock, flags);
 	first = &coredev->clients;
-	for (next = first->next;
-	     (next != first) && !client;
-	     next = next->next) {
-		firstid = &((struct smscore_client_t *)next)->idlist;
-		for (nextid = firstid->next;
-		     nextid != firstid;
-		     nextid = nextid->next) {
-			if ((((struct smscore_idlist_t *)nextid)->id == id) &&
-			    (((struct smscore_idlist_t *)nextid)->data_type == data_type ||
-			    (((struct smscore_idlist_t *)nextid)->data_type == 0))) {
+	for (next = first->next; (next != first) && !client;
+			next = next->next) {
+		firstid = &((struct smscore_client_t *) next)->idlist;
+		for (nextid = firstid->next; nextid != firstid;
+				nextid = nextid->next) {
+			if ((((struct smscore_idlist_t *) nextid)->id == id)
+					&& (((struct smscore_idlist_t *)
+						 nextid)->data_type
+						== data_type
+						|| (((struct smscore_idlist_t *)
+						nextid)->data_type == 0))) {
 				client = (struct smscore_client_t *) next;
 				break;
 			}
@@ -931,12 +1073,10 @@ smscore_client_t *smscore_find_client(struct smscore_device_t *coredev,
  *
  */
 void smscore_onresponse(struct smscore_device_t *coredev,
-			struct smscore_buffer_t *cb)
-{
-	struct SmsMsgHdr_ST *phdr =
-		(struct SmsMsgHdr_ST *)((u8 *) cb->p + cb->offset);
-	struct smscore_client_t *client =
-		smscore_find_client(coredev, phdr->msgType, phdr->msgDstId);
+		struct smscore_buffer_t *cb) {
+	struct SmsMsgHdr_ST *phdr = (struct SmsMsgHdr_ST *) ((u8 *) cb->p
+			+ cb->offset);
+	struct smscore_client_t *client;
 	int rc = -EBUSY;
 
 	static unsigned long last_sample_time; /* = 0; */
@@ -947,40 +1087,54 @@ void smscore_onresponse(struct smscore_device_t *coredev,
 		last_sample_time = time_now;
 
 	if (time_now - last_sample_time > 10000) {
-		sms_debug("\ndata rate %d bytes/secs",
-			  (int)((data_total * 1000) /
-				(time_now - last_sample_time)));
+		sms_info("\ndata rate %d bytes/secs",
+				(int)((data_total * 1000) /
+						(time_now - last_sample_time)));
 
 		last_sample_time = time_now;
 		data_total = 0;
 	}
 
 	data_total += cb->size;
+
+	/* Do we need to re-route? */
+	if ((phdr->msgType == MSG_SMS_HO_PER_SLICES_IND) ||
+			(phdr->msgType == MSG_SMS_TRANSMISSION_IND)) {
+		if (coredev->mode == DEVICE_MODE_DVBT_BDA)
+			phdr->msgDstId = DVBT_BDA_CONTROL_MSG_ID;
+	}
+
+
+	client = smscore_find_client(coredev, phdr->msgType, phdr->msgDstId);
+
 	/* If no client registered for type & id,
 	 * check for control client where type is not registered */
-	if (client)
+	if (client) {
 		rc = client->onresponse_handler(client->context, cb);
-
+  }
 	if (rc < 0) {
+		smsendian_handle_rx_message((struct SmsMsgData_ST *)phdr);
+
 		switch (phdr->msgType) {
-		case MSG_SMS_GET_VERSION_EX_RES:
-		{
+		case MSG_SMS_GET_VERSION_EX_RES: {
 			struct SmsVersionRes_ST *ver =
-				(struct SmsVersionRes_ST *) phdr;
-			sms_debug("MSG_SMS_GET_VERSION_EX_RES "
-				  "id %d prots 0x%x ver %d.%d",
-				  ver->FirmwareId, ver->SupportedProtocols,
-				  ver->RomVersionMajor, ver->RomVersionMinor);
+					(struct SmsVersionRes_ST *) phdr;
+			sms_info("MSG_SMS_GET_VERSION_EX_RES "
+					"id %d prots 0x%x ver %d.%d",
+					ver->FirmwareId,
+					ver->SupportedProtocols,
+					ver->RomVersionMajor,
+					ver->RomVersionMinor);
 
 			coredev->mode = ver->FirmwareId == 255 ?
-				DEVICE_MODE_NONE : ver->FirmwareId;
+					DEVICE_MODE_NONE : ver->FirmwareId;
 			coredev->modes_supported = ver->SupportedProtocols;
 
 			complete(&coredev->version_ex_done);
 			break;
 		}
 		case MSG_SMS_INIT_DEVICE_RES:
-			sms_debug("MSG_SMS_INIT_DEVICE_RES");
+			printk(KERN_INFO "%s: MSG_SMS_INIT_DEVICE_RES\n", __func__);
 			complete(&coredev->init_device_done);
 			break;
 		case MSG_SW_RELOAD_START_RES:
@@ -994,13 +1148,50 @@ void smscore_onresponse(struct smscore_device_t *coredev,
 			sms_debug("MSG_SW_RELOAD_EXEC_RES");
 			break;
 		case MSG_SMS_SWDOWNLOAD_TRIGGER_RES:
-			sms_debug("MSG_SMS_SWDOWNLOAD_TRIGGER_RES");
+			sms_info("MSG_SMS_SWDOWNLOAD_TRIGGER_RES");
 			complete(&coredev->trigger_done);
 			break;
 		case MSG_SMS_SLEEP_RESUME_COMP_IND:
 			complete(&coredev->resume_done);
 			break;
+		case MSG_SMS_GPIO_CONFIG_EX_RES:
+			sms_debug("MSG_SMS_GPIO_CONFIG_EX_RES");
+			complete(&coredev->gpio_configuration_done);
+			break;
+		case MSG_SMS_GPIO_SET_LEVEL_RES:
+			sms_debug("MSG_SMS_GPIO_SET_LEVEL_RES");
+			complete(&coredev->gpio_set_level_done);
+			break;
+		case MSG_SMS_GPIO_GET_LEVEL_RES:
+		{
+			u32 *msgdata = (u32 *) phdr;
+			coredev->gpio_get_res = msgdata[1];
+			sms_debug("MSG_SMS_GPIO_GET_LEVEL_RES gpio level %d",
+					coredev->gpio_get_res);
+			complete(&coredev->gpio_get_level_done);
+			break;
+		}
+		case MSG_SMS_START_IR_RES:
+			complete(&coredev->ir_init_done);
+			break;
+		case MSG_SMS_IR_SAMPLES_IND:
+			sms_ir_event(coredev,
+				(const char *)
+				((char *)phdr
+				+ sizeof(struct SmsMsgHdr_ST)),
+				(int)phdr->msgLength
+				- sizeof(struct SmsMsgHdr_ST));
+      break;
+
+    case MSG_SMS_SPI_INT_LINE_SET_RES:
+      sms_info("MSG_SMS_SPI_INT_LINE_SET_RES\n");
+			break;
 		default:
+/*
+			sms_info("no client (%p) or error (%d), "
+					"type:%d dstid:%d", client, rc,
+					phdr->msgType, phdr->msgDstId);
+*/
 			break;
 		}
 		smscore_putbuffer(coredev, cb);
@@ -1020,12 +1211,24 @@ struct smscore_buffer_t *smscore_getbuffer(struct smscore_device_t *coredev)
 	struct smscore_buffer_t *cb = NULL;
 	unsigned long flags;
 
+	DEFINE_WAIT(wait);
+
 	spin_lock_irqsave(&coredev->bufferslock, flags);
 
-	if (!list_empty(&coredev->buffers)) {
+	/* This function must return a valid buffer, since the buffer list is
+	 * finite, we check that there is an available buffer, if not, we wait
+	 * until such buffer become available.
+	 */
+
+	prepare_to_wait(&coredev->buffer_mng_waitq, &wait, TASK_INTERRUPTIBLE);
+
+	if (list_empty(&coredev->buffers))
+		schedule();
+
+	finish_wait(&coredev->buffer_mng_waitq, &wait);
+
 		cb = (struct smscore_buffer_t *) coredev->buffers.next;
 		list_del(&cb->entry);
-	}
 
 	spin_unlock_irqrestore(&coredev->bufferslock, flags);
 
@@ -1041,15 +1244,13 @@ struct smscore_buffer_t *smscore_getbuffer(struct smscore_device_t *coredev)
  *
  */
 void smscore_putbuffer(struct smscore_device_t *coredev,
-		       struct smscore_buffer_t *cb)
-{
+		struct smscore_buffer_t *cb) {
+	wake_up_interruptible(&coredev->buffer_mng_waitq);
 	list_add_locked(&cb->entry, &coredev->buffers, &coredev->bufferslock);
 }
 
 static int smscore_validate_client(struct smscore_device_t *coredev,
-				   struct smscore_client_t *client,
-				   int data_type, int id)
-{
+		struct smscore_client_t *client, int data_type, int id) {
 	struct smscore_idlist_t *listentry;
 	struct smscore_client_t *registered_client;
 
@@ -1092,11 +1293,13 @@ static int smscore_validate_client(struct smscore_device_t *coredev,
  * @return 0 on success, <0 on error.
  */
 int smscore_register_client(struct smscore_device_t *coredev,
-			    struct smsclient_params_t *params,
-			    struct smscore_client_t **client)
-{
+		struct smsclient_params_t *params,
+				struct smscore_client_t **client) {
 	struct smscore_client_t *newclient;
 	/* check that no other channel with same parameters exists */
+	sms_info("entering....smscore_register_client \n");
+
+
 	if (smscore_find_client(coredev, params->data_type,
 				params->initial_id)) {
 		sms_err("Client already exist.");
@@ -1117,10 +1320,10 @@ int smscore_register_client(struct smscore_device_t *coredev,
 	list_add_locked(&newclient->entry, &coredev->clients,
 			&coredev->clientslock);
 	smscore_validate_client(coredev, newclient, params->data_type,
-				params->initial_id);
+			params->initial_id);
 	*client = newclient;
-	sms_debug("%p %d %d", params->context, params->data_type,
-		  params->initial_id);
+	sms_debug("Register new client %p DT=%d ID=%d",
+		params->context, params->data_type, params->initial_id);
 
 	return 0;
 }
@@ -1139,10 +1342,9 @@ void smscore_unregister_client(struct smscore_client_t *client)
 
 	spin_lock_irqsave(&coredev->clientslock, flags);
 
-
 	while (!list_empty(&client->idlist)) {
 		struct smscore_idlist_t *identry =
-			(struct smscore_idlist_t *) client->idlist.next;
+				(struct smscore_idlist_t *) client->idlist.next;
 		list_del(&identry->entry);
 		kfree(identry);
 	}
@@ -1166,9 +1368,8 @@ void smscore_unregister_client(struct smscore_client_t *client)
  *
  * @return 0 on success, <0 on error.
  */
-int smsclient_sendrequest(struct smscore_client_t *client,
-			  void *buffer, size_t size)
-{
+int smsclient_sendrequest(struct smscore_client_t *client, void *buffer,
+		size_t size) {
 	struct smscore_device_t *coredev;
 	struct SmsMsgHdr_ST *phdr = (struct SmsMsgHdr_ST *) buffer;
 	int rc;
@@ -1187,88 +1388,300 @@ int smsclient_sendrequest(struct smscore_client_t *client,
 	}
 
 	rc = smscore_validate_client(client->coredev, client, 0,
-				     phdr->msgSrcId);
+			phdr->msgSrcId);
 	if (rc < 0)
 		return rc;
 
 	return coredev->sendrequest_handler(coredev->context, buffer, size);
 }
 
+#ifdef SMS_HOSTLIB_SUBSYS
+/**
+ * return the size of large (common) buffer
+ *
+ * @param coredev pointer to a coredev object from clients hotplug
+ *
+ * @return size (in bytes) of the buffer
+ */
+int smscore_get_common_buffer_size(struct smscore_device_t *coredev)
+{
+	return coredev->common_buffer_size;
+}
 
-int smscore_configure_gpio(struct smscore_device_t *coredev, u32 pin,
-			   struct smscore_gpio_config *pinconfig)
+/**
+ * maps common buffer (if supported by platform)
+ *
+ * @param coredev pointer to a coredev object from clients hotplug
+ * @param vma pointer to vma struct from mmap handler
+ *
+ * @return 0 on success, <0 on error.
+ */
+int smscore_map_common_buffer(struct smscore_device_t *coredev,
+		struct vm_area_struct *vma)
 {
-	struct {
-		struct SmsMsgHdr_ST hdr;
-		u32 data[6];
-	} msg;
+	unsigned long end = vma->vm_end,
+	start = vma->vm_start,
+	size = PAGE_ALIGN(coredev->common_buffer_size);
 
-	if (coredev->device_flags & SMS_DEVICE_FAMILY2) {
-		msg.hdr.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
-		msg.hdr.msgDstId = HIF_TASK;
-		msg.hdr.msgFlags = 0;
-		msg.hdr.msgType  = MSG_SMS_GPIO_CONFIG_EX_REQ;
-		msg.hdr.msgLength = sizeof(msg);
+	if (!(vma->vm_flags & (VM_READ | VM_SHARED)) ||
+			(vma->vm_flags & VM_WRITE)) {
+		sms_err("invalid vm flags");
+		return -EINVAL;
+	}
 
-		msg.data[0] = pin;
-		msg.data[1] = pinconfig->pullupdown;
+	if ((end - start) != size) {
+		sms_err("invalid size %d expected %d",
+				(int)(end - start), (int)size);
+		return -EINVAL;
+	}
 
-		/* Convert slew rate for Nova: Fast(0) = 3 / Slow(1) = 0; */
-		msg.data[2] = pinconfig->outputslewrate == 0 ? 3 : 0;
+	if (remap_pfn_range(vma, start,
+			coredev->common_buffer_phys >> PAGE_SHIFT,
+			size, pgprot_noncached(vma->vm_page_prot))) {
+		sms_err("remap_page_range failed");
+		return -EAGAIN;
+	}
 
-		switch (pinconfig->outputdriving) {
-		case SMS_GPIO_OUTPUTDRIVING_16mA:
-			msg.data[3] = 7; /* Nova - 16mA */
-			break;
-		case SMS_GPIO_OUTPUTDRIVING_12mA:
-			msg.data[3] = 5; /* Nova - 11mA */
-			break;
-		case SMS_GPIO_OUTPUTDRIVING_8mA:
-			msg.data[3] = 3; /* Nova - 7mA */
-			break;
-		case SMS_GPIO_OUTPUTDRIVING_4mA:
-		default:
-			msg.data[3] = 2; /* Nova - 4mA */
-			break;
-		}
+	return 0;
+}
+#endif /* SMS_HOSTLIB_SUBSYS */
+
+static int GetGpioPinParams(u32 PinNum, u32 *pTranslatedPinNum,
+		u32 *pGroupNum, u32 *pGroupCfg) {
+
+	*pGroupCfg = 1;
+
+	if (PinNum >= 0 && PinNum <= 1)	{
+		*pTranslatedPinNum = 0;
+		*pGroupNum = 9;
+		*pGroupCfg = 2;
+	} else if (PinNum >= 2 && PinNum <= 6) {
+		*pTranslatedPinNum = 2;
+		*pGroupNum = 0;
+		*pGroupCfg = 2;
+	} else if (PinNum >= 7 && PinNum <= 11) {
+		*pTranslatedPinNum = 7;
+		*pGroupNum = 1;
+	} else if (PinNum >= 12 && PinNum <= 15) {
+		*pTranslatedPinNum = 12;
+		*pGroupNum = 2;
+		*pGroupCfg = 3;
+	} else if (PinNum == 16) {
+		*pTranslatedPinNum = 16;
+		*pGroupNum = 23;
+	} else if (PinNum >= 17 && PinNum <= 24) {
+		*pTranslatedPinNum = 17;
+		*pGroupNum = 3;
+	} else if (PinNum == 25) {
+		*pTranslatedPinNum = 25;
+		*pGroupNum = 6;
+	} else if (PinNum >= 26 && PinNum <= 28) {
+		*pTranslatedPinNum = 26;
+		*pGroupNum = 4;
+	} else if (PinNum == 29) {
+		*pTranslatedPinNum = 29;
+		*pGroupNum = 5;
+		*pGroupCfg = 2;
+	} else if (PinNum == 30) {
+		*pTranslatedPinNum = 30;
+		*pGroupNum = 8;
+	} else if (PinNum == 31) {
+		*pTranslatedPinNum = 31;
+		*pGroupNum = 17;
+	} else
+		return -1;
+
+	*pGroupCfg <<= 24;
+
+	return 0;
+}
+
+int smscore_gpio_configure(struct smscore_device_t *coredev, u8 PinNum,
+		struct smscore_gpio_config *pGpioConfig) {
+
+	u32 totalLen;
+	u32 TranslatedPinNum;
+	u32 GroupNum;
+	u32 ElectricChar;
+	u32 groupCfg;
+	void *buffer;
+	int rc;
+
+	struct SetGpioMsg {
+		struct SmsMsgHdr_ST xMsgHeader;
+		u32 msgData[6];
+	} *pMsg;
+
+
+	if (PinNum > MAX_GPIO_PIN_NUMBER)
+		return -EINVAL;
+
+	if (pGpioConfig == NULL)
+		return -EINVAL;
+
+	totalLen = sizeof(struct SmsMsgHdr_ST) + (sizeof(u32) * 6);
+
+	buffer = kmalloc(totalLen + SMS_DMA_ALIGNMENT,
+			GFP_KERNEL | GFP_DMA);
+	if (!buffer)
+		return -ENOMEM;
+
+	pMsg = (struct SetGpioMsg *) SMS_ALIGN_ADDRESS(buffer);
+
+	pMsg->xMsgHeader.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
+	pMsg->xMsgHeader.msgDstId = HIF_TASK;
+	pMsg->xMsgHeader.msgFlags = 0;
+	pMsg->xMsgHeader.msgLength = (u16) totalLen;
+	pMsg->msgData[0] = PinNum;
+
+	if (!(coredev->device_flags & SMS_DEVICE_FAMILY2)) {
+		pMsg->xMsgHeader.msgType = MSG_SMS_GPIO_CONFIG_REQ;
+		if (GetGpioPinParams(PinNum, &TranslatedPinNum, &GroupNum,
+				&groupCfg) != 0)
+			return -EINVAL;
+
+		pMsg->msgData[1] = TranslatedPinNum;
+		pMsg->msgData[2] = GroupNum;
+		ElectricChar = (pGpioConfig->PullUpDown)
+				| (pGpioConfig->InputCharacteristics << 2)
+				| (pGpioConfig->OutputSlewRate << 3)
+				| (pGpioConfig->OutputDriving << 4);
+		pMsg->msgData[3] = ElectricChar;
+		pMsg->msgData[4] = pGpioConfig->Direction;
+		pMsg->msgData[5] = groupCfg;
+	} else {
+		pMsg->xMsgHeader.msgType = MSG_SMS_GPIO_CONFIG_EX_REQ;
+		pMsg->msgData[1] = pGpioConfig->PullUpDown;
+		pMsg->msgData[2] = pGpioConfig->OutputSlewRate;
+		pMsg->msgData[3] = pGpioConfig->OutputDriving;
+		pMsg->msgData[4] = pGpioConfig->Direction;
+		pMsg->msgData[5] = 0;
+	}
+
+	smsendian_handle_tx_message((struct SmsMsgHdr_ST *)pMsg);
+	rc = smscore_sendrequest_and_wait(coredev, pMsg, totalLen,
+			&coredev->gpio_configuration_done);
+
+	if (rc != 0) {
+		if (rc == -ETIME)
+			sms_err("smscore_gpio_configure timeout");
+		else
+			sms_err("smscore_gpio_configure error");
+	}
+	kfree(buffer);
+
+	return rc;
+}
+
+int smscore_gpio_set_level(struct smscore_device_t *coredev, u8 PinNum,
+		u8 NewLevel) {
+
+	u32 totalLen;
+	int rc;
+	void *buffer;
 
-		msg.data[4] = pinconfig->direction;
-		msg.data[5] = 0;
-	} else /* TODO: SMS_DEVICE_FAMILY1 */
+	struct SetGpioMsg {
+		struct SmsMsgHdr_ST xMsgHeader;
+		u32 msgData[3]; /* keep it 3 ! */
+	} *pMsg;
+
+	if ((NewLevel > 1) || (PinNum > MAX_GPIO_PIN_NUMBER) ||
+			(PinNum > MAX_GPIO_PIN_NUMBER))
 		return -EINVAL;
 
-	return coredev->sendrequest_handler(coredev->context,
-					    &msg, sizeof(msg));
+	totalLen = sizeof(struct SmsMsgHdr_ST) +
+			(3 * sizeof(u32)); /* keep it 3 ! */
+
+	buffer = kmalloc(totalLen + SMS_DMA_ALIGNMENT,
+			GFP_KERNEL | GFP_DMA);
+	if (!buffer)
+		return -ENOMEM;
+
+	pMsg = (struct SetGpioMsg *) SMS_ALIGN_ADDRESS(buffer);
+
+	pMsg->xMsgHeader.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
+	pMsg->xMsgHeader.msgDstId = HIF_TASK;
+	pMsg->xMsgHeader.msgFlags = 0;
+	pMsg->xMsgHeader.msgType = MSG_SMS_GPIO_SET_LEVEL_REQ;
+	pMsg->xMsgHeader.msgLength = (u16) totalLen;
+	pMsg->msgData[0] = PinNum;
+	pMsg->msgData[1] = NewLevel;
+
+	/* Send message to SMS */
+	smsendian_handle_tx_message((struct SmsMsgHdr_ST *)pMsg);
+	rc = smscore_sendrequest_and_wait(coredev, pMsg, totalLen,
+			&coredev->gpio_set_level_done);
+
+	if (rc != 0) {
+		if (rc == -ETIME)
+			sms_err("smscore_gpio_set_level timeout");
+		else
+			sms_err("smscore_gpio_set_level error");
+	}
+	kfree(buffer);
+
+	return rc;
 }
 
-int smscore_set_gpio(struct smscore_device_t *coredev, u32 pin, int level)
-{
-	struct {
-		struct SmsMsgHdr_ST hdr;
-		u32 data[3];
-	} msg;
+int smscore_gpio_get_level(struct smscore_device_t *coredev, u8 PinNum,
+		u8 *level) {
+
+	u32 totalLen;
+	int rc;
+	void *buffer;
+
+	struct SetGpioMsg {
+		struct SmsMsgHdr_ST xMsgHeader;
+		u32 msgData[2];
+	} *pMsg;
+
 
-	if (pin > MAX_GPIO_PIN_NUMBER)
+	if (PinNum > MAX_GPIO_PIN_NUMBER)
 		return -EINVAL;
 
-	msg.hdr.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
-	msg.hdr.msgDstId = HIF_TASK;
-	msg.hdr.msgFlags = 0;
-	msg.hdr.msgType  = MSG_SMS_GPIO_SET_LEVEL_REQ;
-	msg.hdr.msgLength = sizeof(msg);
+	totalLen = sizeof(struct SmsMsgHdr_ST) + (2 * sizeof(u32));
 
-	msg.data[0] = pin;
-	msg.data[1] = level ? 1 : 0;
-	msg.data[2] = 0;
+	buffer = kmalloc(totalLen + SMS_DMA_ALIGNMENT,
+			GFP_KERNEL | GFP_DMA);
+	if (!buffer)
+		return -ENOMEM;
+
+	pMsg = (struct SetGpioMsg *) SMS_ALIGN_ADDRESS(buffer);
+
+	pMsg->xMsgHeader.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
+	pMsg->xMsgHeader.msgDstId = HIF_TASK;
+	pMsg->xMsgHeader.msgFlags = 0;
+	pMsg->xMsgHeader.msgType = MSG_SMS_GPIO_GET_LEVEL_REQ;
+	pMsg->xMsgHeader.msgLength = (u16) totalLen;
+	pMsg->msgData[0] = PinNum;
+	pMsg->msgData[1] = 0;
+
+	/* Send message to SMS */
+	smsendian_handle_tx_message((struct SmsMsgHdr_ST *)pMsg);
+	rc = smscore_sendrequest_and_wait(coredev, pMsg, totalLen,
+			&coredev->gpio_get_level_done);
+
+	if (rc != 0) {
+		if (rc == -ETIME)
+			sms_err("smscore_gpio_get_level timeout");
+		else
+			sms_err("smscore_gpio_get_level error");
+	}
+	kfree(buffer);
+
+	/* Its a race between other gpio_get_level() and the copy of the single
+	 * global 'coredev->gpio_get_res' to  the function's variable 'level'
+	 */
+	*level = coredev->gpio_get_res;
 
-	return coredev->sendrequest_handler(coredev->context,
-					    &msg, sizeof(msg));
+	return rc;
 }
 
 static int __init smscore_module_init(void)
 {
 	int rc = 0;
 
+	sms_info("entering... smscore_module_init....\n");
 	INIT_LIST_HEAD(&g_smscore_notifyees);
 	INIT_LIST_HEAD(&g_smscore_devices);
 	kmutex_init(&g_smscore_deviceslock);
@@ -1276,25 +1689,127 @@ static int __init smscore_module_init(void)
 	INIT_LIST_HEAD(&g_smscore_registry);
 	kmutex_init(&g_smscore_registrylock);
 
+	/* Register sub system adapter objects */
+
+#ifdef SMS_NET_SUBSYS
+	/* NET Register */
+	rc = smsnet_register();
+	if (rc) {
+		sms_err("Error registering Siano's network client.\n");
+		goto smsnet_error;
+	}
+#endif
+
+#ifdef SMS_HOSTLIB_SUBSYS
+	/* Char interface Register */
+	rc = smschar_register();
+	if (rc) {
+		sms_err("Error registering Siano's char device client.\n");
+		goto smschar_error;
+	}
+#endif
+
+#ifdef SMS_DVB3_SUBSYS
+	/* DVB v.3 Register */
+	rc = smsdvb_register();
+	if (rc) {
+		sms_err("Error registering DVB client.\n");
+		goto smsdvb_error;
+	}
+#endif
+
+	/* Register interfaces objects */
+
+#ifdef SMS_USB_DRV
 	/* USB Register */
 	rc = smsusb_register();
+	if (rc) {
+		sms_err("Error registering USB bus driver.\n");
+		goto sms_bus_drv_error;
+	}
+#endif
+
+#ifdef SMS_SDIO_DRV
+	/* SDIO Register */
+	rc = smssdio_register();
+	if (rc) {
+		sms_err("Error registering SDIO bus driver.\n");
+		goto sms_bus_drv_error;
+	}
+#endif
+
+#ifdef SMS_SPI_DRV
+	/* SPI Register */
+	rc = smsspi_register();
+	if (rc) {
+		sms_err("Error registering Intel PXA310 SPI bus driver.\n");
+		goto sms_bus_drv_error;
+	}
+#endif
 
-	/* DVB Register */
-	rc = smsdvb_register();
+	return rc;
+
+sms_bus_drv_error:
+#ifdef SMS_DVB3_SUBSYS
+	smsdvb_unregister();
+smsdvb_error:
+#endif
+
+#ifdef SMS_HOSTLIB_SUBSYS
+	smschar_unregister();
+smschar_error:
+#endif
+
+#ifdef SMS_NET_SUBSYS
+	smsnet_unregister();
+smsnet_error:
+#endif
 
-	sms_debug("rc %d", rc);
+	/*sms_err("rc %d", rc);*/
+	printk(KERN_INFO "%s, rc %d\n", __func__, rc);
 
 	return rc;
 }
 
 static void __exit smscore_module_exit(void)
 {
+  printk(KERN_INFO "%s is called.\n", __func__);
+
+#ifdef SMS_NET_SUBSYS
+	/* Net Unregister */
+	smsnet_unregister();
+#endif
+
+#ifdef SMS_HOSTLIB_SUBSYS
+	/* Char interface Unregister */
+	smschar_unregister();
+#endif
+
+#ifdef SMS_DVB3_SUBSYS
+	/* DVB v.3 unregister */
+	smsdvb_unregister();
+#endif
+
+	/* Unegister interfaces objects */
+#ifdef SMS_USB_DRV
+	/* USB unregister */
+	smsusb_unregister();
+#endif
+
+#ifdef SMS_SDIO_DRV
+	/* SDIO unegister */
+	smssdio_unregister();
+#endif
+#ifdef SMS_SPI_DRV
+	/* SPI unegister */
+	smsspi_unregister();
+#endif
 
 	kmutex_lock(&g_smscore_deviceslock);
 	while (!list_empty(&g_smscore_notifyees)) {
 		struct smscore_device_notifyee_t *notifyee =
-			(struct smscore_device_notifyee_t *)
-				g_smscore_notifyees.next;
+		(struct smscore_device_notifyee_t *)
+		g_smscore_notifyees.next;
 
 		list_del(&notifyee->entry);
 		kfree(notifyee);
@@ -1304,26 +1819,20 @@ static void __exit smscore_module_exit(void)
 	kmutex_lock(&g_smscore_registrylock);
 	while (!list_empty(&g_smscore_registry)) {
 		struct smscore_registry_entry_t *entry =
-			(struct smscore_registry_entry_t *)
-				g_smscore_registry.next;
+		(struct smscore_registry_entry_t *)
+		g_smscore_registry.next;
 
 		list_del(&entry->entry);
 		kfree(entry);
 	}
 	kmutex_unlock(&g_smscore_registrylock);
 
-	/* DVB UnRegister */
-	smsdvb_unregister();
-
-	/* Unregister USB */
-	smsusb_unregister();
-
-	sms_debug("");
+	sms_debug("end");
 }
 
 module_init(smscore_module_init);
 module_exit(smscore_module_exit);
 
-MODULE_DESCRIPTION("Driver for the Siano SMS1XXX USB dongle");
-MODULE_AUTHOR("Siano Mobile Silicon,,, (doronc@siano-ms.com)");
+MODULE_DESCRIPTION("Siano MDTV Core module - Version 2.0.1");
+MODULE_AUTHOR("Siano Mobile Silicon, Inc. (uris@siano-ms.com)");
 MODULE_LICENSE("GPL");
diff --git a/drivers/media/dvb/siano/smscoreapi.h b/drivers/media/dvb/siano/smscoreapi.h
index 760e233..30b3cc9 100644
--- a/drivers/media/dvb/siano/smscoreapi.h
+++ b/drivers/media/dvb/siano/smscoreapi.h
@@ -1,26 +1,26 @@
-/*
- *  Driver for the Siano SMS1xxx USB dongle
- *
- *  author: Anatoly Greenblat
- *
- *  Copyright (c), 2005-2008 Siano Mobile Silicon, Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation;
- *
- *  Software distributed under the License is distributed on an "AS IS"
- *  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
- *
- *  See the GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#ifndef __smscoreapi_h__
-#define __smscoreapi_h__
+/****************************************************************
+
+Siano Mobile Silicon, Inc.
+MDTV receiver kernel modules.
+Copyright (C) 2006-2008, Uri Shkolnik
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+****************************************************************/
+
+#ifndef __SMS_CORE_API_H__
+#define __SMS_CORE_API_H__
 
 #include <linux/version.h>
 #include <linux/device.h>
@@ -28,14 +28,14 @@
 #include <linux/mm.h>
 #include <linux/scatterlist.h>
 #include <linux/types.h>
-#include <asm/page.h>
+#include <linux/mutex.h>
+#include <linux/compat.h>
+#include <linux/wait.h>
+#include <linux/timer.h>
 
-#include "dmxdev.h"
-#include "dvbdev.h"
-#include "dvb_demux.h"
-#include "dvb_frontend.h"
+#include <asm/page.h>
 
-#include <linux/mutex.h>
+#include "smsir.h"
 
 #define kmutex_init(_p_) mutex_init(_p_)
 #define kmutex_lock(_p_) mutex_lock(_p_)
@@ -46,6 +46,7 @@
 #define min(a, b) (((a) < (b)) ? (a) : (b))
 #endif
 
+#define SMS_PROTOCOL_MAX_RAOUNDTRIP_MS			(10000)
 #define SMS_ALLOC_ALIGNMENT					128
 #define SMS_DMA_ALIGNMENT					16
 #define SMS_ALIGN_ADDRESS(addr) \
@@ -53,7 +54,7 @@
 
 #define SMS_DEVICE_FAMILY2					1
 #define SMS_ROM_NO_RESPONSE					2
-#define SMS_DEVICE_NOT_READY				0x8000000
+#define SMS_DEVICE_NOT_READY					0x8000000
 
 enum sms_device_type_st {
 	SMS_STELLAR = 0,
@@ -67,80 +68,134 @@ struct smscore_device_t;
 struct smscore_client_t;
 struct smscore_buffer_t;
 
-typedef int (*hotplug_t)(struct smscore_device_t *coredev,
-			 struct device *device, int arrival);
+typedef int (*hotplug_t) (struct smscore_device_t *coredev,
+			  struct device *device, int arrival);
 
-typedef int (*setmode_t)(void *context, int mode);
-typedef void (*detectmode_t)(void *context, int *mode);
-typedef int (*sendrequest_t)(void *context, void *buffer, size_t size);
-typedef int (*loadfirmware_t)(void *context, void *buffer, size_t size);
-typedef int (*preload_t)(void *context);
-typedef int (*postload_t)(void *context);
+typedef int (*setmode_t) (void *context, int mode);
+typedef void (*detectmode_t) (void *context, int *mode);
+typedef int (*sendrequest_t) (void *context, void *buffer, size_t size);
+typedef int (*loadfirmware_t) (void *context, void *buffer, size_t size);
+typedef int (*preload_t) (void *context);
+typedef int (*postload_t) (void *context);
 
-typedef int (*onresponse_t)(void *context, struct smscore_buffer_t *cb);
-typedef void (*onremove_t)(void *context);
+typedef int (*onresponse_t) (void *context, struct smscore_buffer_t *cb);
+typedef void (*onremove_t) (void *context);
 
 struct smscore_buffer_t {
 	/* public members, once passed to clients can be changed freely */
 	struct list_head entry;
-	int				size;
-	int				offset;
+	int size;
+	int offset;
 
 	/* private members, read-only for clients */
-	void			*p;
-	dma_addr_t		phys;
-	unsigned long	offset_in_common;
+	void *p;
+	dma_addr_t phys;
+	unsigned long offset_in_common;
 };
 
 struct smsdevice_params_t {
-	struct device	*device;
+	struct device *device;
 
-	int				buffer_size;
-	int				num_buffers;
+	int buffer_size;
+	int num_buffers;
 
-	char			devpath[32];
-	unsigned long	flags;
+	char devpath[32];
+	unsigned long flags;
 
-	setmode_t		setmode_handler;
-	detectmode_t	detectmode_handler;
-	sendrequest_t	sendrequest_handler;
-	preload_t		preload_handler;
-	postload_t		postload_handler;
+	setmode_t setmode_handler;
+	detectmode_t detectmode_handler;
+	sendrequest_t sendrequest_handler;
+	preload_t preload_handler;
+	postload_t postload_handler;
 
-	void			*context;
+	void *context;
 	enum sms_device_type_st device_type;
 };
 
 struct smsclient_params_t {
-	int				initial_id;
-	int				data_type;
-	onresponse_t	onresponse_handler;
-	onremove_t		onremove_handler;
+	int initial_id;
+	int data_type;
+	onresponse_t onresponse_handler;
+	onremove_t onremove_handler;
+	void *context;
+};
+
+struct smscore_device_t {
+	struct list_head entry;
+
+	struct list_head clients;
+	struct list_head subclients;
+	spinlock_t clientslock; /* client lock */
+
+	struct list_head buffers;
+	spinlock_t bufferslock; /* buffer lock  */
+	int num_buffers;
+
+	void *common_buffer;
+	int common_buffer_size;
+	dma_addr_t common_buffer_phys;
+
+	void *context;
+	struct device *device;
+
+	char devpath[32];
+	unsigned long device_flags;
+
+	setmode_t setmode_handler;
+	detectmode_t detectmode_handler;
+	sendrequest_t sendrequest_handler;
+	preload_t preload_handler;
+	postload_t postload_handler;
 
-	void			*context;
+	int mode, modes_supported;
+
+	/* host <--> device messages */
+	struct completion version_ex_done, data_download_done, trigger_done;
+	struct completion init_device_done, reload_start_done, resume_done;
+	struct completion gpio_configuration_done, gpio_set_level_done;
+	struct completion gpio_get_level_done, ir_init_done;
+
+	/* Buffer management */
+	wait_queue_head_t buffer_mng_waitq;
+
+	/* GPIO */
+	int gpio_get_res;
+
+	/* Target hardware board */
+	int board_id;
+
+	/* Firmware */
+	u8 *fw_buf;
+	u32 fw_buf_size;
+
+	/* Infrared (IR) */
+	struct ir_t ir;
 };
 
+/* Use DMA channel */
+#define MOT_FEAT_OMAP_DMA_USE             1
+
 /* GPIO definitions for antenna frequency domain control (SMS8021) */
-#define SMS_ANTENNA_GPIO_0					1
-#define SMS_ANTENNA_GPIO_1					0
+#define SMS_ANTENNA_GPIO_0				1
+#define SMS_ANTENNA_GPIO_1				0
 
-#define BW_8_MHZ							0
-#define BW_7_MHZ							1
-#define BW_6_MHZ							2
-#define BW_5_MHZ							3
-#define BW_ISDBT_1SEG						4
-#define BW_ISDBT_3SEG						5
+#define BW_8_MHZ					0
+#define BW_7_MHZ					1
+#define BW_6_MHZ					2
+#define BW_5_MHZ					3
+#define BW_ISDBT_1SEG					4
+#define BW_ISDBT_3SEG					5
 
 #define MSG_HDR_FLAG_SPLIT_MSG				4
 
-#define MAX_GPIO_PIN_NUMBER					31
+#define MAX_GPIO_PIN_NUMBER				31
 
-#define HIF_TASK							11
-#define SMS_HOST_LIB						150
+#define HIF_TASK					11
+#define SMS_HOST_LIB					150
 #define DVBT_BDA_CONTROL_MSG_ID				201
 
 #define SMS_MAX_PAYLOAD_SIZE				240
-#define SMS_TUNE_TIMEOUT					500
+#define SMS_TUNE_TIMEOUT				500
 
 #define MSG_SMS_GPIO_CONFIG_REQ				507
 #define MSG_SMS_GPIO_CONFIG_RES				508
@@ -148,48 +203,53 @@ struct smsclient_params_t {
 #define MSG_SMS_GPIO_SET_LEVEL_RES			510
 #define MSG_SMS_GPIO_GET_LEVEL_REQ			511
 #define MSG_SMS_GPIO_GET_LEVEL_RES			512
-#define MSG_SMS_RF_TUNE_REQ					561
-#define MSG_SMS_RF_TUNE_RES					562
+#define MSG_SMS_RF_TUNE_REQ				561
+#define MSG_SMS_RF_TUNE_RES				562
 #define MSG_SMS_INIT_DEVICE_REQ				578
 #define MSG_SMS_INIT_DEVICE_RES				579
 #define MSG_SMS_ADD_PID_FILTER_REQ			601
 #define MSG_SMS_ADD_PID_FILTER_RES			602
-#define MSG_SMS_REMOVE_PID_FILTER_REQ		603
-#define MSG_SMS_REMOVE_PID_FILTER_RES		604
-#define MSG_SMS_DAB_CHANNEL					607
-#define MSG_SMS_GET_PID_FILTER_LIST_REQ		608
-#define MSG_SMS_GET_PID_FILTER_LIST_RES		609
-#define MSG_SMS_GET_STATISTICS_REQ			615
-#define MSG_SMS_GET_STATISTICS_RES			616
-#define MSG_SMS_SET_ANTENNA_CONFIG_REQ		651
-#define MSG_SMS_SET_ANTENNA_CONFIG_RES		652
-#define MSG_SMS_GET_STATISTICS_EX_REQ		653
-#define MSG_SMS_GET_STATISTICS_EX_RES		654
-#define MSG_SMS_SLEEP_RESUME_COMP_IND		655
+#define MSG_SMS_REMOVE_PID_FILTER_REQ			603
+#define MSG_SMS_REMOVE_PID_FILTER_RES			604
+#define MSG_SMS_DAB_CHANNEL				607
+#define MSG_SMS_GET_PID_FILTER_LIST_REQ			608
+#define MSG_SMS_GET_PID_FILTER_LIST_RES			609
+#define MSG_SMS_HO_PER_SLICES_IND			630
+#define MSG_SMS_SET_ANTENNA_CONFIG_REQ			651
+#define MSG_SMS_SET_ANTENNA_CONFIG_RES			652
+#define MSG_SMS_SLEEP_RESUME_COMP_IND			655
 #define MSG_SMS_DATA_DOWNLOAD_REQ			660
 #define MSG_SMS_DATA_DOWNLOAD_RES			661
-#define MSG_SMS_SWDOWNLOAD_TRIGGER_REQ		664
-#define MSG_SMS_SWDOWNLOAD_TRIGGER_RES		665
-#define MSG_SMS_SWDOWNLOAD_BACKDOOR_REQ		666
-#define MSG_SMS_SWDOWNLOAD_BACKDOOR_RES		667
+#define MSG_SMS_SWDOWNLOAD_TRIGGER_REQ			664
+#define MSG_SMS_SWDOWNLOAD_TRIGGER_RES			665
+#define MSG_SMS_SWDOWNLOAD_BACKDOOR_REQ			666
+#define MSG_SMS_SWDOWNLOAD_BACKDOOR_RES			667
 #define MSG_SMS_GET_VERSION_EX_REQ			668
 #define MSG_SMS_GET_VERSION_EX_RES			669
-#define MSG_SMS_SET_CLOCK_OUTPUT_REQ		670
+#define MSG_SMS_SET_CLOCK_OUTPUT_REQ			670
 #define MSG_SMS_I2C_SET_FREQ_REQ			685
 #define MSG_SMS_GENERIC_I2C_REQ				687
 #define MSG_SMS_GENERIC_I2C_RES				688
 #define MSG_SMS_DVBT_BDA_DATA				693
-#define MSG_SW_RELOAD_REQ					697
-#define MSG_SMS_DATA_MSG					699
+#define MSG_SW_RELOAD_REQ				697
+#define MSG_SMS_DATA_MSG				699
 #define MSG_SW_RELOAD_START_REQ				702
 #define MSG_SW_RELOAD_START_RES				703
 #define MSG_SW_RELOAD_EXEC_REQ				704
 #define MSG_SW_RELOAD_EXEC_RES				705
 #define MSG_SMS_SPI_INT_LINE_SET_REQ		710
+#define MSG_SMS_SPI_INT_LINE_SET_RES	  711
 #define MSG_SMS_GPIO_CONFIG_EX_REQ			712
 #define MSG_SMS_GPIO_CONFIG_EX_RES			713
 #define MSG_SMS_ISDBT_TUNE_REQ				776
 #define MSG_SMS_ISDBT_TUNE_RES				777
+#define MSG_SMS_TRANSMISSION_IND			782
+#define MSG_SMS_START_IR_REQ				800
+#define MSG_SMS_START_IR_RES				801
+#define MSG_SMS_IR_SAMPLES_IND				802
+#define MSG_SMS_SIGNAL_DETECTED_IND			827
+#define MSG_SMS_NO_SIGNAL_IND				828
+
 
 #define SMS_INIT_MSG_EX(ptr, type, src, dst, len) do { \
 	(ptr)->msgType = type; (ptr)->msgSrcId = src; (ptr)->msgDstId = dst; \
@@ -198,6 +258,16 @@ struct smsclient_params_t {
 #define SMS_INIT_MSG(ptr, type, len) \
 	SMS_INIT_MSG_EX(ptr, type, 0, HIF_TASK, len)
 
+enum SMS_DVB3_EVENTS {
+	DVB3_EVENT_INIT = 0,
+	DVB3_EVENT_SLEEP,
+	DVB3_EVENT_HOTPLUG,
+	DVB3_EVENT_FE_LOCK,
+	DVB3_EVENT_FE_UNLOCK,
+	DVB3_EVENT_UNC_OK,
+	DVB3_EVENT_UNC_ERR
+};
+
 enum SMS_DEVICE_MODE {
 	DEVICE_MODE_NONE = -1,
 	DEVICE_MODE_DVBT = 0,
@@ -213,181 +283,267 @@ enum SMS_DEVICE_MODE {
 };
 
 struct SmsMsgHdr_ST {
-	u16	msgType;
-	u8	msgSrcId;
-	u8	msgDstId;
-	u16	msgLength; /* Length of entire message, including header */
-	u16	msgFlags;
+	u16 msgType;
+	u8 msgSrcId;
+	u8 msgDstId;
+	u16 msgLength;		/* Length of entire message, including header */
+	u16 msgFlags;
 };
 
 struct SmsMsgData_ST {
-	struct SmsMsgHdr_ST	xMsgHeader;
-	u32			msgData[1];
+	struct SmsMsgHdr_ST xMsgHeader;
+	u32 msgData[1];
+};
+
+struct SmsMsgData_ST2 {
+	struct SmsMsgHdr_ST xMsgHeader;
+	u32 msgData[2];
 };
 
 struct SmsDataDownload_ST {
-	struct SmsMsgHdr_ST	xMsgHeader;
-	u32			MemAddr;
-	u8			Payload[SMS_MAX_PAYLOAD_SIZE];
+	struct SmsMsgHdr_ST xMsgHeader;
+	u32 MemAddr;
+	u8 Payload[SMS_MAX_PAYLOAD_SIZE];
 };
 
 struct SmsVersionRes_ST {
-	struct SmsMsgHdr_ST	xMsgHeader;
-
-	u16		ChipModel; /* e.g. 0x1102 for SMS-1102 "Nova" */
-	u8		Step; /* 0 - Step A */
-	u8		MetalFix; /* 0 - Metal 0 */
-
-	u8		FirmwareId; /* 0xFF � ROM, otherwise the
-				     * value indicated by
-				     * SMSHOSTLIB_DEVICE_MODES_E */
-	u8		SupportedProtocols; /* Bitwise OR combination of
-					     * supported protocols */
+	struct SmsMsgHdr_ST xMsgHeader;
+
+	u16 ChipModel;		/* e.g. 0x1102 for SMS-1102 "Nova" */
+	u8 Step;		/* 0 - Step A */
+	u8 MetalFix;		/* 0 - Metal 0 */
+
+	/* FirmwareId 0xFF if ROM, otherwise the
+	 * value indicated by SMSHOSTLIB_DEVICE_MODES_E */
+	u8 FirmwareId;
+	/* SupportedProtocols Bitwise OR combination of
+				 * supported protocols */
+	u8 SupportedProtocols;
+
+	u8 VersionMajor;
+	u8 VersionMinor;
+	u8 VersionPatch;
+	u8 VersionFieldPatch;
+
+	u8 RomVersionMajor;
+	u8 RomVersionMinor;
+	u8 RomVersionPatch;
+	u8 RomVersionFieldPatch;
+
+	u8 TextLabel[34];
+};
 
-	u8		VersionMajor;
-	u8		VersionMinor;
-	u8		VersionPatch;
-	u8		VersionFieldPatch;
+struct SmsFirmware_ST {
+	u32 CheckSum;
+	u32 Length;
+	u32 StartAddress;
+	u8 Payload[1];
+};
 
-	u8		RomVersionMajor;
-	u8		RomVersionMinor;
-	u8		RomVersionPatch;
-	u8		RomVersionFieldPatch;
+/* Statistics information returned as response for SmsHostApiGetStatistics_Req*/
+struct SMSHOSTLIB_STATISTICS_S {
+	u32 Reserved;		/*!< Reserved*/
+
+	/* Common parameters*/
+	u32 IsRfLocked;		/*!< 0 - not locked, 1 - locked*/
+	u32 IsDemodLocked;	/*!< 0 - not locked, 1 - locked*/
+	u32 IsExternalLNAOn;	/*!< 0 - external LNA off, 1 - external LNA on*/
+
+	/* Reception quality*/
+	s32 SNR;		/*!< dB*/
+	u32 BER;		/*!< Post Viterbi BER [1E-5]*/
+	u32 FIB_CRC;		/*!< CRC errors percentage, valid only for DAB*/
+	u32 TS_PER;		/*!< Transport stream PER, 0xFFFFFFFF indicate N/A, valid only for DVB-T/H*/
+	u32 MFER;		/*!< DVB-H frame error rate in percentage, 0xFFFFFFFF indicate N/A, valid only for DVB-H*/
+	s32 RSSI;		/*!< dBm*/
+	s32 InBandPwr;		/*!< In band power in dBM*/
+	s32 CarrierOffset;	/*!< Carrier Offset in bin/1024*/
+
+	/* Transmission parameters*/
+	u32 Frequency;		/*!< Frequency in Hz*/
+	u32 Bandwidth;		/*!< Bandwidth in MHz, valid only for DVB-T/H*/
+	u32 TransmissionMode;	/*!< Transmission Mode, for DAB modes 1-4, for DVB-T/H FFT mode carriers in Kilos*/
+	u32 ModemState;		/*!< from SMSHOSTLIB_DVB_MODEM_STATE_ET , valid only for DVB-T/H*/
+	u32 GuardInterval;	/*!< Guard Interval from SMSHOSTLIB_GUARD_INTERVALS_ET, valid only for DVB-T/H*/
+	u32 CodeRate;		/*!< Code Rate from SMSHOSTLIB_CODE_RATE_ET, valid only for DVB-T/H*/
+	u32 LPCodeRate;		/*!< Low Priority Code Rate from SMSHOSTLIB_CODE_RATE_ET, valid only for DVB-T/H*/
+	u32 Hierarchy;		/*!< Hierarchy from SMSHOSTLIB_HIERARCHY_ET, valid only for DVB-T/H*/
+	u32 Constellation;	/*!< Constellation from SMSHOSTLIB_CONSTELLATION_ET, valid only for DVB-T/H*/
+
+	/* Burst parameters, valid only for DVB-H*/
+	u32 BurstSize;		/*!< Current burst size in bytes, valid only for DVB-H*/
+	u32 BurstDuration;	/*!< Current burst duration in mSec, valid only for DVB-H*/
+	u32 BurstCycleTime;	/*!< Current burst cycle time in mSec, valid only for DVB-H*/
+	u32 CalculatedBurstCycleTime;/*!< Current burst cycle time in mSec, as calculated by demodulator, valid only for DVB-H*/
+	u32 NumOfRows;		/*!< Number of rows in MPE table, valid only for DVB-H*/
+	u32 NumOfPaddCols;	/*!< Number of padding columns in MPE table, valid only for DVB-H*/
+	u32 NumOfPunctCols;	/*!< Number of puncturing columns in MPE table, valid only for DVB-H*/
+	u32 ErrorTSPackets;	/*!< Number of erroneous transport-stream packets*/
+	u32 TotalTSPackets;	/*!< Total number of transport-stream packets*/
+	u32 NumOfValidMpeTlbs;	/*!< Number of MPE tables which do not include errors after MPE RS decoding*/
+	u32 NumOfInvalidMpeTlbs;/*!< Number of MPE tables which include errors after MPE RS decoding*/
+	u32 NumOfCorrectedMpeTlbs;/*!< Number of MPE tables which were corrected by MPE RS decoding*/
+	/* Common params*/
+	u32 BERErrorCount;	/*!< Number of errornous SYNC bits.*/
+	u32 BERBitCount;	/*!< Total number of SYNC bits.*/
+
+	/* Interface information*/
+	u32 SmsToHostTxErrors;	/*!< Total number of transmission errors.*/
+
+	/* DAB/T-DMB*/
+	u32 PreBER; 		/*!< DAB/T-DMB only: Pre Viterbi BER [1E-5]*/
+
+	/* DVB-H TPS parameters*/
+	u32 CellId;		/*!< TPS Cell ID in bits 15..0, bits 31..16 zero; if set to 0xFFFFFFFF cell_id not yet recovered*/
+	u32 DvbhSrvIndHP;	/*!< DVB-H service indication info, bit 1 - Time Slicing indicator, bit 0 - MPE-FEC indicator*/
+	u32 DvbhSrvIndLP;	/*!< DVB-H service indication info, bit 1 - Time Slicing indicator, bit 0 - MPE-FEC indicator*/
+
+	u32 NumMPEReceived;	/*!< DVB-H, Num MPE section received*/
+
+	u32 ReservedFields[10];	/*!< Reserved*/
+};
 
-	u8		TextLabel[34];
+struct PID_STATISTICS_DATA_S {
+	struct PID_BURST_S {
+		u32	size;
+		u32	padding_cols;
+		u32	punct_cols;
+		u32	duration;
+		u32	cycle;
+		u32	calc_cycle;
+	} burst;
+
+	u32	tot_tbl_cnt;
+	u32	invalid_tbl_cnt;
+	u32  tot_cor_tbl;
 };
 
-struct SmsFirmware_ST {
-	u32			CheckSum;
-	u32			Length;
-	u32			StartAddress;
-	u8			Payload[1];
+struct PID_DATA_S {
+	u32 pid;
+	u32 num_rows;
+	struct PID_STATISTICS_DATA_S pid_statistics;
 };
 
-struct SMSHOSTLIB_STATISTICS_ST {
-	u32 Reserved; /* Reserved */
-
-	/* Common parameters */
-	u32 IsRfLocked; /* 0 - not locked, 1 - locked */
-	u32 IsDemodLocked; /* 0 - not locked, 1 - locked */
-	u32 IsExternalLNAOn; /* 0 - external LNA off, 1 - external LNA on */
-
-	/* Reception quality */
-	s32  SNR; /* dB */
-	u32 BER; /* Post Viterbi BER [1E-5] */
-	u32 FIB_CRC;	/* CRC errors percentage, valid only for DAB */
-	u32 TS_PER; /* Transport stream PER, 0xFFFFFFFF indicate N/A,
-		     * valid only for DVB-T/H */
-	u32 MFER; /* DVB-H frame error rate in percentage,
-		   * 0xFFFFFFFF indicate N/A, valid only for DVB-H */
-	s32  RSSI; /* dBm */
-	s32  InBandPwr; /* In band power in dBM */
-	s32  CarrierOffset; /* Carrier Offset in bin/1024 */
-
-	/* Transmission parameters, valid only for DVB-T/H */
-	u32 Frequency; /* Frequency in Hz */
-	u32 Bandwidth; /* Bandwidth in MHz */
-	u32 TransmissionMode; /* Transmission Mode, for DAB modes 1-4,
-			       * for DVB-T/H FFT mode carriers in Kilos */
-	u32 ModemState; /* from SMS_DvbModemState_ET */
-	u32 GuardInterval; /* Guard Interval, 1 divided by value */
-	u32 CodeRate; /* Code Rate from SMS_DvbModemState_ET */
-	u32 LPCodeRate; /* Low Priority Code Rate from SMS_DvbModemState_ET */
-	u32 Hierarchy; /* Hierarchy from SMS_Hierarchy_ET */
-	u32 Constellation; /* Constellation from SMS_Constellation_ET */
-
-	/* Burst parameters, valid only for DVB-H */
-	u32 BurstSize; /* Current burst size in bytes */
-	u32 BurstDuration; /* Current burst duration in mSec */
-	u32 BurstCycleTime; /* Current burst cycle time in mSec */
-	u32 CalculatedBurstCycleTime; /* Current burst cycle time in mSec,
-				       * as calculated by demodulator */
-	u32 NumOfRows; /* Number of rows in MPE table */
-	u32 NumOfPaddCols; /* Number of padding columns in MPE table */
-	u32 NumOfPunctCols; /* Number of puncturing columns in MPE table */
-	/* Burst parameters */
-	u32 ErrorTSPackets; /* Number of erroneous transport-stream packets */
-	u32 TotalTSPackets; /* Total number of transport-stream packets */
-	u32 NumOfValidMpeTlbs; /* Number of MPE tables which do not include
-				* errors after MPE RS decoding */
-	u32 NumOfInvalidMpeTlbs; /* Number of MPE tables which include errors
-				  * after MPE RS decoding */
-	u32 NumOfCorrectedMpeTlbs; /* Number of MPE tables which were corrected
-				    * by MPE RS decoding */
-
-	/* Common params */
-	u32 BERErrorCount; /* Number of errornous SYNC bits. */
-	u32 BERBitCount; /* Total number of SYNC bits. */
-
-	/* Interface information */
-	u32 SmsToHostTxErrors; /* Total number of transmission errors. */
-
-	/* DAB/T-DMB */
-	u32 PreBER; /* DAB/T-DMB only: Pre Viterbi BER [1E-5] */
-
-	/* DVB-H TPS parameters */
-	u32 CellId; /* TPS Cell ID in bits 15..0, bits 31..16 zero;
-		     * if set to 0xFFFFFFFF cell_id not yet recovered */
+#define CORRECT_STAT_RSSI(_stat) ((_stat).RSSI *= (-1))
+#define CORRECT_STAT_BANDWIDTH(_stat) _stat.Bandwidth = (8 - (_stat.Bandwidth))
+#define CORRECT_STAT_TRANSMISSON_MODE(_stat) \
+	do { \
+	if (_stat.TransmissionMode == 0) \
+		_stat.TransmissionMode = 2; \
+	else if (_stat.TransmissionMode == 1) \
+		_stat.TransmissionMode = 8; \
+	else \
+		_stat.TransmissionMode = 4; \
+	} while (0);
+
+struct TRANSMISSION_STATISTICS_S {
+	u32 Frequency;		/*!< Frequency in Hz*/
+	u32 Bandwidth;		/*!< Bandwidth in MHz*/
+	u32 TransmissionMode;	/*!< FFT mode carriers in Kilos*/
+	u32 GuardInterval;	/*!< Guard Interval from SMSHOSTLIB_GUARD_INTERVALS_ET*/
+	u32 CodeRate;		/*!< Code Rate from SMSHOSTLIB_CODE_RATE_ET*/
+	u32 LPCodeRate;		/*!< Low Priority Code Rate from SMSHOSTLIB_CODE_RATE_ET*/
+	u32 Hierarchy;		/*!< Hierarchy from SMSHOSTLIB_HIERARCHY_ET*/
+	u32 Constellation;	/*!< Constellation from SMSHOSTLIB_CONSTELLATION_ET*/
+
+	/* DVB-H TPS parameters*/
+	u32 CellId;		/*!< TPS Cell ID in bits 15..0, bits 31..16 zero; if set to 0xFFFFFFFF cell_id not yet recovered*/
+	u32 DvbhSrvIndHP;	/*!< DVB-H service indication info, bit 1 - Time Slicing indicator, bit 0 - MPE-FEC indicator*/
+	u32 DvbhSrvIndLP;	/*!< DVB-H service indication info, bit 1 - Time Slicing indicator, bit 0 - MPE-FEC indicator*/
+	u32 IsDemodLocked;	/*!< 0 - not locked, 1 - locked*/
+};
 
+struct RECEPTION_STATISTICS_S {
+	u32 IsRfLocked;		/*!< 0 - not locked, 1 - locked*/
+	u32 IsDemodLocked;	/*!< 0 - not locked, 1 - locked*/
+	u32 IsExternalLNAOn;	/*!< 0 - external LNA off, 1 - external LNA on*/
+
+	u32 ModemState;		/*!< from SMSHOSTLIB_DVB_MODEM_STATE_ET*/
+	s32 SNR;		/*!< dB*/
+	u32 BER;		/*!< Post Viterbi BER [1E-5]*/
+	u32 BERErrorCount;	/*!< Number of erronous SYNC bits.*/
+	u32 BERBitCount;	/*!< Total number of SYNC bits.*/
+	u32 TS_PER;		/*!< Transport stream PER, 0xFFFFFFFF indicate N/A*/
+	u32 MFER;		/*!< DVB-H frame error rate in percentage, 0xFFFFFFFF indicate N/A, valid only for DVB-H*/
+	s32 RSSI;		/*!< dBm*/
+	s32 InBandPwr;		/*!< In band power in dBM*/
+	s32 CarrierOffset;	/*!< Carrier Offset in bin/1024*/
+	u32 ErrorTSPackets;	/*!< Number of erroneous transport-stream packets*/
+	u32 TotalTSPackets;	/*!< Total number of transport-stream packets*/
+
+	s32 MRC_SNR;		/*!< dB*/
+	s32 MRC_RSSI;		/*!< dBm*/
+	s32 MRC_InBandPwr;	/*!< In band power in dBM*/
 };
 
-struct SmsMsgStatisticsInfo_ST {
-	u32 RequestResult;
 
-	struct SMSHOSTLIB_STATISTICS_ST Stat;
+/* Statistics information returned as response for SmsHostApiGetStatisticsEx_Req for DVB applications, SMS1100 and up*/
+struct SMSHOSTLIB_STATISTICS_DVB_S {
+	/* Reception*/
+	struct RECEPTION_STATISTICS_S ReceptionData;
 
-	/* Split the calc of the SNR in DAB */
-	u32 Signal; /* dB */
-	u32 Noise; /* dB */
+	/* Transmission parameters*/
+	struct TRANSMISSION_STATISTICS_S TransmissionData;
 
+	/* Burst parameters, valid only for DVB-H*/
+#define	SRVM_MAX_PID_FILTERS		8
+	struct PID_DATA_S PidData[SRVM_MAX_PID_FILTERS];
 };
 
+struct SRVM_SIGNAL_STATUS_S {
+	u32 result;
+	u32 snr;
+	u32 tsPackets;
+	u32 etsPackets;
+	u32 constellation;
+	u32 hpCode;
+	u32 tpsSrvIndLP;
+	u32 tpsSrvIndHP;
+	u32 cellId;
+	u32 reason;
+
+	s32 inBandPower;
+	u32 requestId;
+};
 
 struct smscore_gpio_config {
 #define SMS_GPIO_DIRECTION_INPUT  0
 #define SMS_GPIO_DIRECTION_OUTPUT 1
-	u8 direction;
+	u8 Direction;
 
 #define SMS_GPIO_PULLUPDOWN_NONE     0
 #define SMS_GPIO_PULLUPDOWN_PULLDOWN 1
 #define SMS_GPIO_PULLUPDOWN_PULLUP   2
 #define SMS_GPIO_PULLUPDOWN_KEEPER   3
-	u8 pullupdown;
+	u8 PullUpDown;
 
 #define SMS_GPIO_INPUTCHARACTERISTICS_NORMAL  0
 #define SMS_GPIO_INPUTCHARACTERISTICS_SCHMITT 1
-	u8 inputcharacteristics;
-
-#define SMS_GPIO_OUTPUTSLEWRATE_FAST 0
-#define SMS_GPIO_OUTPUTSLEWRATE_SLOW 1
-	u8 outputslewrate;
-
-#define SMS_GPIO_OUTPUTDRIVING_4mA  0
-#define SMS_GPIO_OUTPUTDRIVING_8mA  1
-#define SMS_GPIO_OUTPUTDRIVING_12mA 2
-#define SMS_GPIO_OUTPUTDRIVING_16mA 3
-	u8 outputdriving;
-};
-
-struct smsdvb_client_t {
-	struct list_head entry;
-
-	struct smscore_device_t	*coredev;
-	struct smscore_client_t	*smsclient;
-
-	struct dvb_adapter	adapter;
-	struct dvb_demux	demux;
-	struct dmxdev		dmxdev;
-	struct dvb_frontend	frontend;
-
-	fe_status_t		fe_status;
-	int			fe_ber, fe_snr, fe_unc, fe_signal_strength;
-
-	struct completion	tune_done, stat_done;
-
-	/* todo: save freq/band instead whole struct */
-	struct dvb_frontend_parameters fe_params;
-
+	u8 InputCharacteristics;
+
+#define SMS_GPIO_OUTPUTSLEWRATE_SLOW		0 /* 10xx */
+#define SMS_GPIO_OUTPUTSLEWRATE_FAST		1 /* 10xx */
+
+#define SMS_GPIO_OUTPUTSLEWRATE_0_45_V_NS	0 /* 11xx */
+#define SMS_GPIO_OUTPUTSLEWRATE_0_9_V_NS	1 /* 11xx */
+#define SMS_GPIO_OUTPUTSLEWRATE_1_7_V_NS	2 /* 11xx */
+#define SMS_GPIO_OUTPUTSLEWRATE_3_3_V_NS	3 /* 11xx */
+	u8 OutputSlewRate;
+
+#define SMS_GPIO_OUTPUTDRIVING_S_4mA		0 /* 10xx */
+#define SMS_GPIO_OUTPUTDRIVING_S_8mA		1 /* 10xx */
+#define SMS_GPIO_OUTPUTDRIVING_S_12mA		2 /* 10xx */
+#define SMS_GPIO_OUTPUTDRIVING_S_16mA		3 /* 10xx */
+
+#define SMS_GPIO_OUTPUTDRIVING_1_5mA		0 /* 11xx */
+#define SMS_GPIO_OUTPUTDRIVING_2_8mA		1 /* 11xx */
+#define SMS_GPIO_OUTPUTDRIVING_4mA			2 /* 11xx */
+#define SMS_GPIO_OUTPUTDRIVING_7mA			3 /* 11xx */
+#define SMS_GPIO_OUTPUTDRIVING_10mA			4 /* 11xx */
+#define SMS_GPIO_OUTPUTDRIVING_11mA			5 /* 11xx */
+#define SMS_GPIO_OUTPUTDRIVING_14mA			6 /* 11xx */
+#define SMS_GPIO_OUTPUTDRIVING_16mA			7 /* 11xx */
+	u8 OutputDriving;
 };
 
 extern void smscore_registry_setmode(char *devpath, int mode);
@@ -402,44 +558,99 @@ extern void smscore_unregister_device(struct smscore_device_t *coredev);
 
 extern int smscore_start_device(struct smscore_device_t *coredev);
 extern int smscore_load_firmware(struct smscore_device_t *coredev,
-				 char *filename,
-				 loadfirmware_t loadfirmware_handler);
+		char *filename, loadfirmware_t loadfirmware_handler);
 
 extern int smscore_set_device_mode(struct smscore_device_t *coredev, int mode);
 extern int smscore_get_device_mode(struct smscore_device_t *coredev);
+/*##w21558, Added*/
+extern int smscore_reset_device_mode(struct smscore_device_t *coredev);
+
+extern int smscore_register_client(struct smscore_device_t *coredev,
+		struct smsclient_params_t *params,
+		struct smscore_client_t **client);
+extern void smscore_unregister_client(struct smscore_client_t *client);
+
+extern int smsclient_sendrequest(struct smscore_client_t *client, void *buffer,
+		size_t size);
+extern void smscore_onresponse(struct smscore_device_t *coredev,
+		struct smscore_buffer_t *cb);
+
+
+extern int smscore_get_common_buffer_size(struct smscore_device_t *coredev);
+extern int smscore_map_common_buffer(struct smscore_device_t *coredev,
+		struct vm_area_struct *vma);
+extern int smscore_get_fw_filename(struct smscore_device_t *coredev, int mode,
+				   char *filename);
+extern int smscore_send_fw_file(struct smscore_device_t *coredev, u8 *ufwbuf,
+				int size);
 
 extern int smscore_register_client(struct smscore_device_t *coredev,
-				    struct smsclient_params_t *params,
-				    struct smscore_client_t **client);
+				   struct smsclient_params_t *params,
+				   struct smscore_client_t **client);
 extern void smscore_unregister_client(struct smscore_client_t *client);
 
-extern int smsclient_sendrequest(struct smscore_client_t *client,
-				 void *buffer, size_t size);
+extern int smsclient_sendrequest(struct smscore_client_t *client, void *buffer,
+		size_t size);
+
+extern int smscore_register_device(struct smsdevice_params_t *params,
+		struct smscore_device_t **coredev);
+
 extern void smscore_onresponse(struct smscore_device_t *coredev,
 			       struct smscore_buffer_t *cb);
 
+extern int smscore_get_common_buffer_size(struct smscore_device_t *coredev);
+extern int smscore_map_common_buffer(struct smscore_device_t *coredev,
+				     struct vm_area_struct *vma);
 
-extern
-struct smscore_buffer_t *smscore_getbuffer(struct smscore_device_t *coredev);
+extern struct smscore_buffer_t *smscore_getbuffer(
+		struct smscore_device_t *coredev);
 extern void smscore_putbuffer(struct smscore_device_t *coredev,
 			      struct smscore_buffer_t *cb);
 
-int smscore_configure_gpio(struct smscore_device_t *coredev, u32 pin,
-			   struct smscore_gpio_config *pinconfig);
-int smscore_set_gpio(struct smscore_device_t *coredev, u32 pin, int level);
+int smscore_gpio_configure(struct smscore_device_t *coredev, u8 PinNum,
+		struct smscore_gpio_config *pGpioConfig);
+int smscore_gpio_set_level(struct smscore_device_t *coredev, u8 PinNum,
+		u8 NewLevel);
+int smscore_gpio_get_level(struct smscore_device_t *coredev, u8 PinNum,
+		u8 *level);
 
 void smscore_set_board_id(struct smscore_device_t *core, int id);
 int smscore_get_board_id(struct smscore_device_t *core);
 
-int smscore_led_state(struct smscore_device_t *core, int led);
+#ifdef SMS_HOSTLIB_SUBSYS
+extern int smschar_register(void);
+extern void smschar_unregister(void);
+#endif
+
+#ifdef SMS_NET_SUBSYS
+extern int smsnet_register(void);
+extern void smsnet_unregister(void);
+#endif
+
+#ifdef SMS_DVB3_SUBSYS
+extern int smsdvb_register(void);
+extern void smsdvb_unregister(void);
+#endif
 
-/* smsdvb.c */
-int smsdvb_register(void);
-void smsdvb_unregister(void);
+#ifdef SMS_USB_DRV
+extern int smsusb_register(void);
+extern void smsusb_unregister(void);
+#endif
+
+#ifdef SMS_SDIO_DRV
+extern int smssdio_register(void);
+extern void smssdio_unregister(void);
+#endif
 
-/* smsusb.c */
-int smsusb_register(void);
-void smsusb_unregister(void);
+/*##w21558, general SPI driver, in sholes, OMAP34XX spi driver*/
+
+#ifdef SMS_SPI_DRV
+extern int smsspi_register(void);
+extern void smsspi_unregister(void);
+#endif
+
+/*##w21558, Added*/
+extern int smsmdtv_power_control(int pwrup_enable);
 
 /* ------------------------------------------------------------------------ */
 
@@ -464,5 +675,9 @@ extern int sms_debug;
 #define sms_debug(fmt, arg...) \
 	dprintk(KERN_DEBUG, DBG_ADV, fmt, ##arg)
 
-
-#endif /* __smscoreapi_h__ */
+/*##w21558*/
+#define DISPLAY_CURR_TIME() do {\
+	struct timeval tv; \
+	do_gettimeofday(&tv); \
+	printk(KERN_INFO "%s: time = %ld\n", __func__, tv.tv_sec * 1000 + tv.tv_usec / 1000); } while (0)
+#endif /* __SMS_CORE_API_H__ */
diff --git a/drivers/media/dvb/siano/smsdbg_prn.h b/drivers/media/dvb/siano/smsdbg_prn.h
new file mode 100644
index 0000000..a91badd
--- /dev/null
+++ b/drivers/media/dvb/siano/smsdbg_prn.h
@@ -0,0 +1,57 @@
+/****************************************************************
+
+Siano Mobile Silicon, Inc.
+MDTV receiver kernel modules.
+Copyright (C) 2006-2008, Uri Shkolnik
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+****************************************************************/
+
+#ifndef _SMS_DBG_H_
+#define _SMS_DBG_H_
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+/************************************************************************/
+/* Debug Zones definitions.                                             */
+/************************************************************************/
+#undef PERROR
+#define PERROR(fmt, args...) \
+	printk(KERN_ERR "spibus error: line %d- %s(): " fmt, __LINE__,\
+	  __func__, ## args)
+#undef PWARNING
+#define PWARNING(fmt, args...) \
+	printk(KERN_WARNING "spibus warning: line %d- %s(): " fmt, __LINE__,  \
+	__func__, ## args)
+
+/* the debug macro - conditional compilation from the makefile */
+/*#undef PDEBUG*/			/* undef it, just in case */
+/*#define SPIBUS_DEBUG*/
+#ifdef SPIBUS_DEBUG
+#define PDEBUG(fmt, args...) \
+	printk(KERN_DEBUG "spibus: line %d- %s(): " fmt, __LINE__, \
+	 __func__, ## args)
+#else
+#  define PDEBUG(fmt, args...)	/* not debugging: nothing */
+#endif
+
+/* The following defines are used for printing and
+are mandatory for compilation. */
+#define TXT(str) str
+#define PRN_DBG(str) PDEBUG str
+#define PRN_ERR(str) PERROR str
+
+#endif /*_SMS_DBG_H_*/
diff --git a/drivers/media/dvb/siano/smsdvb.c b/drivers/media/dvb/siano/smsdvb.c
index 2da953a..027d383 100644
--- a/drivers/media/dvb/siano/smsdvb.c
+++ b/drivers/media/dvb/siano/smsdvb.c
@@ -1,88 +1,239 @@
-/*
- *  Driver for the Siano SMS1xxx USB dongle
- *
- *  author: Anatoly Greenblat
- *
- *  Copyright (c), 2005-2008 Siano Mobile Silicon, Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation;
- *
- *  Software distributed under the License is distributed on an "AS IS"
- *  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
- *
- *  See the GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
+/****************************************************************
+
+Siano Mobile Silicon, Inc.
+MDTV receiver kernel modules.
+Copyright (C) 2006-2008, Uri Shkolnik
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+****************************************************************/
 
 #include <linux/module.h>
 #include <linux/init.h>
+#include <asm/byteorder.h>
+
+#include "dmxdev.h"
+#include "dvbdev.h"
+#include "dvb_demux.h"
+#include "dvb_frontend.h"
 
 #include "smscoreapi.h"
+#include "smsendian.h"
 #include "sms-cards.h"
 
 DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
 
+struct smsdvb_client_t {
+	struct list_head entry;
+
+	struct smscore_device_t *coredev;
+	struct smscore_client_t *smsclient;
+
+	struct dvb_adapter adapter;
+	struct dvb_demux demux;
+	struct dmxdev dmxdev;
+	struct dvb_frontend frontend;
+
+	fe_status_t fe_status;
+
+	struct completion tune_done;
+
+	/* todo: save freq/band instead whole struct */
+	struct dvb_frontend_parameters fe_params;
+
+	struct SMSHOSTLIB_STATISTICS_DVB_S sms_stat_dvb;
+	int event_fe_state;
+	int event_unc_state;
+};
+
 static struct list_head g_smsdvb_clients;
 static struct mutex g_smsdvb_clientslock;
 
+
+/* Events that may come from DVB v3 adapter */
+static void sms_board_dvb3_event(struct smsdvb_client_t *client,
+		enum SMS_DVB3_EVENTS event) {
+
+	struct smscore_device_t *coredev = client->coredev;
+	switch (event) {
+	case DVB3_EVENT_INIT:
+		sms_debug("DVB3_EVENT_INIT");
+		sms_board_event(coredev, BOARD_EVENT_BIND);
+		break;
+	case DVB3_EVENT_SLEEP:
+		sms_debug("DVB3_EVENT_SLEEP");
+		sms_board_event(coredev, BOARD_EVENT_POWER_SUSPEND);
+		break;
+	case DVB3_EVENT_HOTPLUG:
+		sms_debug("DVB3_EVENT_HOTPLUG");
+		sms_board_event(coredev, BOARD_EVENT_POWER_INIT);
+		break;
+	case DVB3_EVENT_FE_LOCK:
+		if (client->event_fe_state != DVB3_EVENT_FE_LOCK) {
+			client->event_fe_state = DVB3_EVENT_FE_LOCK;
+			sms_debug("DVB3_EVENT_FE_LOCK");
+			sms_board_event(coredev, BOARD_EVENT_FE_LOCK);
+		}
+		break;
+	case DVB3_EVENT_FE_UNLOCK:
+		if (client->event_fe_state != DVB3_EVENT_FE_UNLOCK) {
+			client->event_fe_state = DVB3_EVENT_FE_UNLOCK;
+			sms_debug("DVB3_EVENT_FE_UNLOCK");
+			sms_board_event(coredev, BOARD_EVENT_FE_UNLOCK);
+		}
+		break;
+	case DVB3_EVENT_UNC_OK:
+		if (client->event_unc_state != DVB3_EVENT_UNC_OK) {
+			client->event_unc_state = DVB3_EVENT_UNC_OK;
+			sms_debug("DVB3_EVENT_UNC_OK");
+			sms_board_event(coredev, BOARD_EVENT_MULTIPLEX_OK);
+		}
+		break;
+	case DVB3_EVENT_UNC_ERR:
+		if (client->event_unc_state != DVB3_EVENT_UNC_ERR) {
+			client->event_unc_state = DVB3_EVENT_UNC_ERR;
+			sms_debug("DVB3_EVENT_UNC_ERR");
+			sms_board_event(coredev, BOARD_EVENT_MULTIPLEX_ERRORS);
+		}
+		break;
+
+	default:
+		sms_err("Unknown dvb3 api event");
+		break;
+	}
+}
+
 static int smsdvb_onresponse(void *context, struct smscore_buffer_t *cb)
 {
 	struct smsdvb_client_t *client = (struct smsdvb_client_t *) context;
-	struct SmsMsgHdr_ST *phdr =
-		(struct SmsMsgHdr_ST *)(((u8 *) cb->p) + cb->offset);
+	struct SmsMsgHdr_ST *phdr = (struct SmsMsgHdr_ST *) (((u8 *) cb->p)
+			+ cb->offset);
+	u32 *pMsgData = (u32 *) phdr + 1;
+	/*u32 MsgDataLen = phdr->msgLength - sizeof(struct SmsMsgHdr_ST);*/
+	bool is_status_update = false;
+
+	smsendian_handle_rx_message((struct SmsMsgData_ST *) phdr);
 
 	switch (phdr->msgType) {
 	case MSG_SMS_DVBT_BDA_DATA:
-		dvb_dmx_swfilter(&client->demux, (u8 *)(phdr + 1),
-				 cb->size - sizeof(struct SmsMsgHdr_ST));
+		dvb_dmx_swfilter(&client->demux, (u8 *) (phdr + 1), cb->size
+				- sizeof(struct SmsMsgHdr_ST));
 		break;
 
 	case MSG_SMS_RF_TUNE_RES:
 		complete(&client->tune_done);
 		break;
 
-	case MSG_SMS_GET_STATISTICS_RES:
-	{
-		struct SmsMsgStatisticsInfo_ST *p =
-			(struct SmsMsgStatisticsInfo_ST *)(phdr + 1);
-
-		if (p->Stat.IsDemodLocked) {
-			client->fe_status = FE_HAS_SIGNAL |
-					    FE_HAS_CARRIER |
-					    FE_HAS_VITERBI |
-					    FE_HAS_SYNC |
-					    FE_HAS_LOCK;
-
-			client->fe_snr = p->Stat.SNR;
-			client->fe_ber = p->Stat.BER;
-			client->fe_unc = p->Stat.BERErrorCount;
-
-			if (p->Stat.InBandPwr < -95)
-				client->fe_signal_strength = 0;
-			else if (p->Stat.InBandPwr > -29)
-				client->fe_signal_strength = 100;
-			else
-				client->fe_signal_strength =
-					(p->Stat.InBandPwr + 95) * 3 / 2;
+	case MSG_SMS_SIGNAL_DETECTED_IND:
+		sms_info("MSG_SMS_SIGNAL_DETECTED_IND");
+		client->sms_stat_dvb.TransmissionData.IsDemodLocked = true;
+		is_status_update = true;
+		break;
+
+	case MSG_SMS_NO_SIGNAL_IND:
+		sms_info("MSG_SMS_NO_SIGNAL_IND");
+		client->sms_stat_dvb.TransmissionData.IsDemodLocked = false;
+		is_status_update = true;
+		break;
+
+	case MSG_SMS_TRANSMISSION_IND: {
+		sms_info("MSG_SMS_TRANSMISSION_IND");
+
+		pMsgData++;
+		memcpy(&client->sms_stat_dvb.TransmissionData, pMsgData,
+				sizeof(struct TRANSMISSION_STATISTICS_S));
+
+		/* Mo need to correct guard interval
+		 * (as opposed to old statistics message).
+		 */
+		CORRECT_STAT_BANDWIDTH(client->sms_stat_dvb.TransmissionData);
+		CORRECT_STAT_TRANSMISSON_MODE(
+				client->sms_stat_dvb.TransmissionData);
+		is_status_update = true;
+		break;
+	}
+	case MSG_SMS_HO_PER_SLICES_IND: {
+		struct RECEPTION_STATISTICS_S *pReceptionData =
+				&client->sms_stat_dvb.ReceptionData;
+		struct SRVM_SIGNAL_STATUS_S SignalStatusData;
+
+		/*sms_info("MSG_SMS_HO_PER_SLICES_IND");*/
+		pMsgData++;
+		SignalStatusData.result = pMsgData[0];
+		SignalStatusData.snr = pMsgData[1];
+		SignalStatusData.inBandPower = (s32) pMsgData[2];
+		SignalStatusData.tsPackets = pMsgData[3];
+		SignalStatusData.etsPackets = pMsgData[4];
+		SignalStatusData.constellation = pMsgData[5];
+		SignalStatusData.hpCode = pMsgData[6];
+		SignalStatusData.tpsSrvIndLP = pMsgData[7] & 0x03;
+		SignalStatusData.tpsSrvIndHP = pMsgData[8] & 0x03;
+		SignalStatusData.cellId = pMsgData[9] & 0xFFFF;
+		SignalStatusData.reason = pMsgData[10];
+		SignalStatusData.requestId = pMsgData[11];
+		pReceptionData->IsRfLocked = pMsgData[16];
+		pReceptionData->IsDemodLocked = pMsgData[17];
+		pReceptionData->ModemState = pMsgData[12];
+		pReceptionData->SNR = pMsgData[1];
+		pReceptionData->BER = pMsgData[13];
+		pReceptionData->RSSI = pMsgData[14];
+		CORRECT_STAT_RSSI(client->sms_stat_dvb.ReceptionData);
+
+		pReceptionData->InBandPwr = (s32) pMsgData[2];
+		pReceptionData->CarrierOffset = (s32) pMsgData[15];
+		pReceptionData->TotalTSPackets = pMsgData[3];
+		pReceptionData->ErrorTSPackets = pMsgData[4];
+
+		/* TS PER */
+		if ((SignalStatusData.tsPackets + SignalStatusData.etsPackets)
+				> 0) {
+			pReceptionData->TS_PER = (SignalStatusData.etsPackets
+					* 100) / (SignalStatusData.tsPackets
+					+ SignalStatusData.etsPackets);
 		} else {
-			client->fe_status = 0;
-			client->fe_snr =
-			client->fe_ber =
-			client->fe_unc =
-			client->fe_signal_strength = 0;
+			pReceptionData->TS_PER = 0;
 		}
 
-		complete(&client->stat_done);
-		break;
-	} }
+		pReceptionData->BERBitCount = pMsgData[18];
+		pReceptionData->BERErrorCount = pMsgData[19];
+
+		pReceptionData->MRC_SNR = pMsgData[20];
+		pReceptionData->MRC_InBandPwr = pMsgData[21];
+		pReceptionData->MRC_RSSI = pMsgData[22];
 
+		is_status_update = true;
+		break;
+	}
+	}
 	smscore_putbuffer(client->coredev, cb);
 
+	if (is_status_update) {
+	if (client->sms_stat_dvb.ReceptionData.IsDemodLocked) {
+		client->fe_status = FE_HAS_SIGNAL | FE_HAS_CARRIER
+			| FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;
+		sms_board_dvb3_event(client, DVB3_EVENT_FE_LOCK);
+		if (client->sms_stat_dvb.ReceptionData.ErrorTSPackets == 0)
+			sms_board_dvb3_event(client, DVB3_EVENT_UNC_OK);
+		else
+			sms_board_dvb3_event(client, DVB3_EVENT_UNC_ERR);
+
+		} else {
+			client->fe_status = 0;
+			sms_board_dvb3_event(client, DVB3_EVENT_FE_UNLOCK);
+		}
+	}
+
 	return 0;
 }
 
@@ -115,8 +266,7 @@ static int smsdvb_start_feed(struct dvb_demux_feed *feed)
 		container_of(feed->demux, struct smsdvb_client_t, demux);
 	struct SmsMsgData_ST PidMsg;
 
-	sms_debug("add pid %d(%x)",
-		  feed->pid, feed->pid);
+	sms_debug("add pid %d(%x)", feed->pid, feed->pid);
 
 	PidMsg.xMsgHeader.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
 	PidMsg.xMsgHeader.msgDstId = HIF_TASK;
@@ -125,8 +275,9 @@ static int smsdvb_start_feed(struct dvb_demux_feed *feed)
 	PidMsg.xMsgHeader.msgLength = sizeof(PidMsg);
 	PidMsg.msgData[0] = feed->pid;
 
-	return smsclient_sendrequest(client->smsclient,
-				     &PidMsg, sizeof(PidMsg));
+	smsendian_handle_tx_message((struct SmsMsgHdr_ST *)&PidMsg);
+	return smsclient_sendrequest(client->smsclient, &PidMsg,
+			sizeof(PidMsg));
 }
 
 static int smsdvb_stop_feed(struct dvb_demux_feed *feed)
@@ -135,8 +286,7 @@ static int smsdvb_stop_feed(struct dvb_demux_feed *feed)
 		container_of(feed->demux, struct smsdvb_client_t, demux);
 	struct SmsMsgData_ST PidMsg;
 
-	sms_debug("remove pid %d(%x)",
-		  feed->pid, feed->pid);
+	sms_debug("remove pid %d(%x)", feed->pid, feed->pid);
 
 	PidMsg.xMsgHeader.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
 	PidMsg.xMsgHeader.msgDstId = HIF_TASK;
@@ -145,100 +295,81 @@ static int smsdvb_stop_feed(struct dvb_demux_feed *feed)
 	PidMsg.xMsgHeader.msgLength = sizeof(PidMsg);
 	PidMsg.msgData[0] = feed->pid;
 
-	return smsclient_sendrequest(client->smsclient,
-				     &PidMsg, sizeof(PidMsg));
+	smsendian_handle_tx_message((struct SmsMsgHdr_ST *)&PidMsg);
+	return smsclient_sendrequest(client->smsclient, &PidMsg,
+			sizeof(PidMsg));
 }
 
 static int smsdvb_sendrequest_and_wait(struct smsdvb_client_t *client,
 					void *buffer, size_t size,
 					struct completion *completion)
 {
-	int rc = smsclient_sendrequest(client->smsclient, buffer, size);
+	int rc;
+
+	smsendian_handle_tx_message((struct SmsMsgHdr_ST *)buffer);
+	rc = smsclient_sendrequest(client->smsclient, buffer, size);
 	if (rc < 0)
 		return rc;
 
-	return wait_for_completion_timeout(completion,
-					   msecs_to_jiffies(2000)) ?
-						0 : -ETIME;
-}
-
-static int smsdvb_send_statistics_request(struct smsdvb_client_t *client)
-{
-	struct SmsMsgHdr_ST Msg = { MSG_SMS_GET_STATISTICS_REQ,
-			     DVBT_BDA_CONTROL_MSG_ID,
-			     HIF_TASK, sizeof(struct SmsMsgHdr_ST), 0 };
-	int ret = smsdvb_sendrequest_and_wait(client, &Msg, sizeof(Msg),
-					      &client->stat_done);
-	if (ret < 0)
-		return ret;
-
-	if (client->fe_status & FE_HAS_LOCK)
-		sms_board_led_feedback(client->coredev,
-				       (client->fe_unc == 0) ?
-				       SMS_LED_HI : SMS_LED_LO);
-	else
-		sms_board_led_feedback(client->coredev, SMS_LED_OFF);
-	return ret;
+	return wait_for_completion_timeout(completion, msecs_to_jiffies(2000))
+			? 0 : -ETIME;
 }
 
 static int smsdvb_read_status(struct dvb_frontend *fe, fe_status_t *stat)
 {
-	struct smsdvb_client_t *client =
-		container_of(fe, struct smsdvb_client_t, frontend);
-	int rc = smsdvb_send_statistics_request(client);
+	struct smsdvb_client_t *client;
+	client = container_of(fe, struct smsdvb_client_t, frontend);
 
-	if (!rc)
 		*stat = client->fe_status;
 
-	return rc;
+	return 0;
 }
 
 static int smsdvb_read_ber(struct dvb_frontend *fe, u32 *ber)
 {
-	struct smsdvb_client_t *client =
-		container_of(fe, struct smsdvb_client_t, frontend);
-	int rc = smsdvb_send_statistics_request(client);
+	struct smsdvb_client_t *client;
+	client = container_of(fe, struct smsdvb_client_t, frontend);
 
-	if (!rc)
-		*ber = client->fe_ber;
+	*ber = client->sms_stat_dvb.ReceptionData.BER;
 
-	return rc;
+	return 0;
 }
 
 static int smsdvb_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
 {
-	struct smsdvb_client_t *client =
-		container_of(fe, struct smsdvb_client_t, frontend);
-	int rc = smsdvb_send_statistics_request(client);
+	struct smsdvb_client_t *client;
+	client = container_of(fe, struct smsdvb_client_t, frontend);
 
-	if (!rc)
-		*strength = client->fe_signal_strength;
+	if (client->sms_stat_dvb.ReceptionData.InBandPwr < -95)
+		*strength = 0;
+		else if (client->sms_stat_dvb.ReceptionData.InBandPwr > -29)
+			*strength = 100;
+		else
+			*strength =
+				(client->sms_stat_dvb.ReceptionData.InBandPwr
+				+ 95) * 3 / 2;
 
-	return rc;
+	return 0;
 }
 
 static int smsdvb_read_snr(struct dvb_frontend *fe, u16 *snr)
 {
-	struct smsdvb_client_t *client =
-		container_of(fe, struct smsdvb_client_t, frontend);
-	int rc = smsdvb_send_statistics_request(client);
+	struct smsdvb_client_t *client;
+	client = container_of(fe, struct smsdvb_client_t, frontend);
 
-	if (!rc)
-		*snr = client->fe_snr;
+	*snr = client->sms_stat_dvb.ReceptionData.SNR;
 
-	return rc;
+	return 0;
 }
 
 static int smsdvb_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
 {
-	struct smsdvb_client_t *client =
-		container_of(fe, struct smsdvb_client_t, frontend);
-	int rc = smsdvb_send_statistics_request(client);
+	struct smsdvb_client_t *client;
+	client = container_of(fe, struct smsdvb_client_t, frontend);
 
-	if (!rc)
-		*ucblocks = client->fe_unc;
+	*ucblocks = client->sms_stat_dvb.ReceptionData.ErrorTSPackets;
 
-	return rc;
+	return 0;
 }
 
 static int smsdvb_get_tune_settings(struct dvb_frontend *fe,
@@ -263,6 +394,10 @@ static int smsdvb_set_frontend(struct dvb_frontend *fe,
 		u32		Data[3];
 	} Msg;
 
+	client->fe_status = FE_HAS_SIGNAL;
+	client->event_fe_state = -1;
+	client->event_unc_state = -1;
+
 	Msg.Msg.msgSrcId  = DVBT_BDA_CONTROL_MSG_ID;
 	Msg.Msg.msgDstId  = HIF_TASK;
 	Msg.Msg.msgFlags  = 0;
@@ -275,11 +410,19 @@ static int smsdvb_set_frontend(struct dvb_frontend *fe,
 		  fep->frequency, fep->u.ofdm.bandwidth);
 
 	switch (fep->u.ofdm.bandwidth) {
-	case BANDWIDTH_8_MHZ: Msg.Data[1] = BW_8_MHZ; break;
-	case BANDWIDTH_7_MHZ: Msg.Data[1] = BW_7_MHZ; break;
-	case BANDWIDTH_6_MHZ: Msg.Data[1] = BW_6_MHZ; break;
-	case BANDWIDTH_AUTO: return -EOPNOTSUPP;
-	default: return -EINVAL;
+	case BANDWIDTH_8_MHZ:
+		Msg.Data[1] = BW_8_MHZ;
+		break;
+	case BANDWIDTH_7_MHZ:
+		Msg.Data[1] = BW_7_MHZ;
+		break;
+	case BANDWIDTH_6_MHZ:
+		Msg.Data[1] = BW_6_MHZ;
+		break;
+	case BANDWIDTH_AUTO:
+		return -EOPNOTSUPP;
+	default:
+		return -EINVAL;
 	}
 
 	return smsdvb_sendrequest_and_wait(client, &Msg, sizeof(Msg),
@@ -306,8 +449,7 @@ static int smsdvb_init(struct dvb_frontend *fe)
 	struct smsdvb_client_t *client =
 		container_of(fe, struct smsdvb_client_t, frontend);
 
-	sms_board_power(client->coredev, 1);
-
+	sms_board_dvb3_event(client, DVB3_EVENT_INIT);
 	return 0;
 }
 
@@ -316,8 +458,7 @@ static int smsdvb_sleep(struct dvb_frontend *fe)
 	struct smsdvb_client_t *client =
 		container_of(fe, struct smsdvb_client_t, frontend);
 
-	sms_board_led_feedback(client->coredev, SMS_LED_OFF);
-	sms_board_power(client->coredev, 0);
+	sms_board_dvb3_event(client, DVB3_EVENT_SLEEP);
 
 	return 0;
 }
@@ -329,7 +470,7 @@ static void smsdvb_release(struct dvb_frontend *fe)
 
 static struct dvb_frontend_ops smsdvb_fe_ops = {
 	.info = {
-		.name			= "Siano Mobile Digital SMS1xxx",
+		 .name = "Siano Mobile Digital MDTV Receiver",
 		.type			= FE_OFDM,
 		.frequency_min		= 44250000,
 		.frequency_max		= 867250000,
@@ -340,8 +481,7 @@ static struct dvb_frontend_ops smsdvb_fe_ops = {
 			FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 |
 			FE_CAN_QAM_AUTO | FE_CAN_TRANSMISSION_MODE_AUTO |
 			FE_CAN_GUARD_INTERVAL_AUTO |
-			FE_CAN_RECOVER |
-			FE_CAN_HIERARCHY_AUTO,
+		 FE_CAN_RECOVER | FE_CAN_HIERARCHY_AUTO,
 	},
 
 	.release = smsdvb_release,
@@ -371,7 +511,7 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 	if (!arrival)
 		return 0;
 
-	if (smscore_get_device_mode(coredev) != 4) {
+	if (smscore_get_device_mode(coredev) != DEVICE_MODE_DVBT_BDA) {
 		sms_err("SMS Device mode is not set for "
 			"DVB operation.");
 		return 0;
@@ -384,10 +524,15 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 	}
 
 	/* register dvb adapter */
+#ifdef SMS_DVB_OLD_DVB_REGISTER_ADAPTER
 	rc = dvb_register_adapter(&client->adapter,
-				  sms_get_board(
-					smscore_get_board_id(coredev))->name,
-				  THIS_MODULE, device, adapter_nr);
+				  sms_get_board(smscore_get_board_id(coredev))->
+				  name, THIS_MODULE, device);
+#else
+	rc = dvb_register_adapter(&client->adapter,
+				  sms_get_board(smscore_get_board_id(coredev))->
+				  name, THIS_MODULE, device, adapter_nr);
+#endif
 	if (rc < 0) {
 		sms_err("dvb_register_adapter() failed %d", rc);
 		goto adapter_error;
@@ -442,7 +587,6 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 	client->coredev = coredev;
 
 	init_completion(&client->tune_done);
-	init_completion(&client->stat_done);
 
 	kmutex_lock(&g_smsdvb_clientslock);
 
@@ -450,10 +594,11 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 
 	kmutex_unlock(&g_smsdvb_clientslock);
 
-	sms_info("success");
-
-	sms_board_setup(coredev);
+	client->event_fe_state = -1;
+	client->event_unc_state = -1;
+	sms_board_dvb3_event(client, DVB3_EVENT_HOTPLUG);
 
+	sms_info("success");
 	return 0;
 
 client_error:
@@ -494,8 +639,12 @@ void smsdvb_unregister(void)
 	kmutex_lock(&g_smsdvb_clientslock);
 
 	while (!list_empty(&g_smsdvb_clients))
-	       smsdvb_unregister_client(
-			(struct smsdvb_client_t *) g_smsdvb_clients.next);
+		smsdvb_unregister_client((struct smsdvb_client_t *)
+					 g_smsdvb_clients.next);
 
 	kmutex_unlock(&g_smsdvb_clientslock);
 }
+
+MODULE_DESCRIPTION("SMS DVB subsystem adaptation module");
+MODULE_AUTHOR("Siano Mobile Silicon, Inc. (uris@siano-ms.com)");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/dvb/siano/smsendian.c b/drivers/media/dvb/siano/smsendian.c
new file mode 100644
index 0000000..d79aa05
--- /dev/null
+++ b/drivers/media/dvb/siano/smsendian.c
@@ -0,0 +1,100 @@
+/****************************************************************
+
+ Siano Mobile Silicon, Inc.
+ MDTV receiver kernel modules.
+ Copyright (C) 2006-2009, Uri Shkolnik
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 2 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ ****************************************************************/
+
+#include <asm/byteorder.h>
+
+#include "smsendian.h"
+#include "smscoreapi.h"
+
+void smsendian_handle_tx_message(void *buffer)
+{
+#ifdef __BIG_ENDIAN
+	struct SmsMsgData_ST *msg = (struct SmsMsgData_ST *)buffer;
+	int i;
+	int msgWords;
+
+	switch (msg->xMsgHeader.msgType) {
+	case MSG_SMS_DATA_DOWNLOAD_REQ:
+	{
+		msg->msgData[0] = le32_to_cpu(msg->msgData[0]);
+		break;
+	}
+
+	default:
+		msgWords = (msg->xMsgHeader.msgLength -
+				sizeof(struct SmsMsgHdr_ST))/4;
+
+		for (i = 0; i < msgWords; i++)
+			msg->msgData[i] = le32_to_cpu(msg->msgData[i]);
+
+		break;
+	}
+#endif /* __BIG_ENDIAN */
+}
+
+void smsendian_handle_rx_message(void *buffer)
+{
+#ifdef __BIG_ENDIAN
+	struct SmsMsgData_ST *msg = (struct SmsMsgData_ST *)buffer;
+	int i;
+	int msgWords;
+
+	switch (msg->xMsgHeader.msgType) {
+	case MSG_SMS_GET_VERSION_EX_RES:
+	{
+		struct SmsVersionRes_ST *ver =
+			(struct SmsVersionRes_ST *) msg;
+		ver->ChipModel = le16_to_cpu(ver->ChipModel);
+		break;
+	}
+
+	case MSG_SMS_DVBT_BDA_DATA:
+	case MSG_SMS_DAB_CHANNEL:
+	case MSG_SMS_DATA_MSG:
+	{
+		break;
+	}
+
+	default:
+	{
+		msgWords = (msg->xMsgHeader.msgLength -
+				sizeof(struct SmsMsgHdr_ST))/4;
+
+		for (i = 0; i < msgWords; i++)
+			msg->msgData[i] = le32_to_cpu(msg->msgData[i]);
+
+		break;
+	}
+	}
+#endif /* __BIG_ENDIAN */
+}
+
+void smsendian_handle_message_header(void *msg)
+{
+#ifdef __BIG_ENDIAN
+	struct SmsMsgHdr_ST *phdr = (struct SmsMsgHdr_ST *)msg;
+
+	phdr->msgType = le16_to_cpu(phdr->msgType);
+	phdr->msgLength = le16_to_cpu(phdr->msgLength);
+	phdr->msgFlags = le16_to_cpu(phdr->msgFlags);
+#endif /* __BIG_ENDIAN */
+}
+
diff --git a/drivers/media/dvb/siano/smsendian.h b/drivers/media/dvb/siano/smsendian.h
new file mode 100644
index 0000000..7fbedc6
--- /dev/null
+++ b/drivers/media/dvb/siano/smsendian.h
@@ -0,0 +1,32 @@
+/****************************************************************
+
+Siano Mobile Silicon, Inc.
+MDTV receiver kernel modules.
+Copyright (C) 2006-2009, Uri Shkolnik
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+****************************************************************/
+
+#ifndef __SMS_ENDIAN_H__
+#define __SMS_ENDIAN_H__
+
+#include <asm/byteorder.h>
+
+void smsendian_handle_tx_message(void *buffer);
+void smsendian_handle_rx_message(void *buffer);
+void smsendian_handle_message_header(void *msg);
+
+#endif /* __SMS_ENDIAN_H__ */
+
diff --git a/drivers/media/dvb/siano/smsir.c b/drivers/media/dvb/siano/smsir.c
new file mode 100644
index 0000000..a5f302c
--- /dev/null
+++ b/drivers/media/dvb/siano/smsir.c
@@ -0,0 +1,301 @@
+/****************************************************************
+
+ Siano Mobile Silicon, Inc.
+ MDTV receiver kernel modules.
+ Copyright (C) 2006-2009, Uri Shkolnik
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 2 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ ****************************************************************/
+
+
+#include <linux/types.h>
+#include <linux/input.h>
+
+#include "smscoreapi.h"
+#include "smsir.h"
+#include "sms-cards.h"
+
+/* In order to add new IR remote control -
+ * 1) Add it to the <enum ir_kb_type> @ smsir,h,
+ * 2) Add its map to keyboard_layout_maps below
+ * 3) Set your board (sms-cards sub-module) to use it
+ */
+
+static struct keyboard_layout_map_t keyboard_layout_maps[] = {
+		[SMS_IR_KB_DEFAULT_TV] = {
+			.ir_protocol = IR_RC5,
+			.rc5_kbd_address = KEYBOARD_ADDRESS_TV1,
+			.keyboard_layout_map = {
+					KEY_0, KEY_1, KEY_2,
+					KEY_3, KEY_4, KEY_5,
+					KEY_6, KEY_7, KEY_8,
+					KEY_9, 0, 0, KEY_POWER,
+					KEY_MUTE, 0, 0,
+					KEY_VOLUMEUP, KEY_VOLUMEDOWN,
+					KEY_BRIGHTNESSUP,
+					KEY_BRIGHTNESSDOWN, KEY_CHANNELUP,
+					KEY_CHANNELDOWN,
+					0, 0, 0, 0, 0, 0, 0, 0,
+					0, 0, 0, 0, 0, 0, 0, 0,
+					0, 0, 0, 0, 0, 0, 0, 0,
+					0, 0, 0, 0, 0, 0, 0, 0,
+					0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+			}
+		},
+		[SMS_IR_KB_HCW_SILVER] = {
+			.ir_protocol = IR_RC5,
+			.rc5_kbd_address = KEYBOARD_ADDRESS_LIGHTING1,
+			.keyboard_layout_map = {
+					KEY_0, KEY_1, KEY_2,
+					KEY_3, KEY_4, KEY_5,
+					KEY_6, KEY_7, KEY_8,
+					KEY_9, KEY_TEXT, KEY_RED,
+					KEY_RADIO, KEY_MENU,
+					KEY_SUBTITLE,
+					KEY_MUTE, KEY_VOLUMEUP,
+					KEY_VOLUMEDOWN, KEY_PREVIOUS, 0,
+					KEY_UP, KEY_DOWN, KEY_LEFT,
+					KEY_RIGHT, KEY_VIDEO, KEY_AUDIO,
+					KEY_MHP, KEY_EPG, KEY_TV,
+					0, KEY_NEXTSONG, KEY_EXIT,
+					KEY_CHANNELUP, 	KEY_CHANNELDOWN,
+					KEY_CHANNEL, 0,
+					KEY_PREVIOUSSONG, KEY_ENTER,
+					KEY_SLEEP, 0, 0, KEY_BLUE,
+					0, 0, 0, 0, KEY_GREEN, 0,
+					KEY_PAUSE, 0, KEY_REWIND,
+					0, KEY_FASTFORWARD, KEY_PLAY,
+					KEY_STOP, KEY_RECORD,
+					KEY_YELLOW, 0, 0, KEY_SELECT,
+					KEY_ZOOM, KEY_POWER, 0, 0
+			}
+		},
+		{ } /* Terminating entry */
+};
+
+u32 ir_pos;
+u32	ir_word;
+u32 ir_toggle;
+
+#define RC5_PUSH_BIT(dst, bit, pos)	\
+	{ dst <<= 1; dst |= bit; pos++; }
+
+
+static void sms_ir_rc5_event(struct smscore_device_t *coredev,
+				u32 toggle, u32 addr, u32 cmd)
+{
+	bool toggle_changed;
+	u16 keycode;
+
+	sms_info("IR RC5 word: address %d, command %d, toggle %d",
+				addr, cmd, toggle);
+
+	toggle_changed = ir_toggle != toggle;
+	/* keep toggle */
+	ir_toggle = toggle;
+
+	if (addr !=
+		keyboard_layout_maps[coredev->ir.ir_kb_type].rc5_kbd_address)
+		return; /* Check for valid address */
+
+	keycode =
+		keyboard_layout_maps
+		[coredev->ir.ir_kb_type].keyboard_layout_map[cmd];
+
+	if (!toggle_changed &&
+			(keycode != KEY_VOLUMEUP && keycode != KEY_VOLUMEDOWN))
+		return; /* accept only repeated volume, reject other keys */
+
+	sms_info("kernel input keycode (from ir) %d", keycode);
+	input_report_key(coredev->ir.input_dev, keycode, 1);
+	input_sync(coredev->ir.input_dev);
+
+}
+
+/* decode raw bit pattern to RC5 code */
+/* taken from ir-functions.c */
+static u32 ir_rc5_decode(unsigned int code)
+{
+/*	unsigned int org_code = code;*/
+	unsigned int pair;
+	unsigned int rc5 = 0;
+	int i;
+
+	for (i = 0; i < 14; ++i) {
+		pair = code & 0x3;
+		code >>= 2;
+
+		rc5 <<= 1;
+		switch (pair) {
+		case 0:
+		case 2:
+			break;
+		case 1:
+			rc5 |= 1;
+			break;
+		case 3:
+/*	dprintk(1, "ir-common: ir_rc5_decode(%x) bad code\n", org_code);*/
+			sms_info("bad code");
+			return 0;
+		}
+	}
+/*
+	dprintk(1, "ir-common: code=%x, rc5=%x, start=%x,
+		toggle=%x, address=%x, "
+		"instr=%x\n", rc5, org_code, RC5_START(rc5),
+		RC5_TOGGLE(rc5), RC5_ADDR(rc5), RC5_INSTR(rc5));
+*/
+	return rc5;
+}
+
+static void sms_rc5_parse_word(struct smscore_device_t *coredev)
+{
+	#define RC5_START(x)    (((x)>>12)&3)
+	#define RC5_TOGGLE(x)   (((x)>>11)&1)
+	#define RC5_ADDR(x)     (((x)>>6)&0x1F)
+	#define RC5_INSTR(x)    ((x)&0x3F)
+
+	int i, j;
+	u32 rc5_word = 0;
+
+	/* Reverse the IR word direction */
+	for (i = 0 ; i < 28 ; i++)
+		RC5_PUSH_BIT(rc5_word, (ir_word>>i)&1, j)
+
+	rc5_word = ir_rc5_decode(rc5_word);
+	/* sms_info("temp = 0x%x, rc5_code = 0x%x", ir_word, rc5_word); */
+
+	sms_ir_rc5_event(coredev,
+				RC5_TOGGLE(rc5_word),
+				RC5_ADDR(rc5_word),
+				RC5_INSTR(rc5_word));
+}
+
+
+static void sms_rc5_accumulate_bits(struct smscore_device_t *coredev,
+		s32 ir_sample)
+{
+	#define RC5_TIME_GRANULARITY	200
+	#define RC5_DEF_BIT_TIME		889
+	#define RC5_MAX_SAME_BIT_CONT	4
+	#define RC5_WORD_LEN			27 /* 28 bit */
+
+	u32 i, j;
+	s32 delta_time;
+	u32 time = (ir_sample > 0) ? ir_sample : (0-ir_sample);
+	u32 level = (ir_sample < 0) ? 0 : 1;
+
+	for (i = RC5_MAX_SAME_BIT_CONT; i > 0; i--) {
+		delta_time = time - (i*RC5_DEF_BIT_TIME) + RC5_TIME_GRANULARITY;
+		if (delta_time < 0)
+			continue; /* not so many consecutive bits */
+		if (delta_time > (2 * RC5_TIME_GRANULARITY)) {
+			/* timeout */
+			if (ir_pos == (RC5_WORD_LEN-1))
+				/* complete last bit */
+				RC5_PUSH_BIT(ir_word, level, ir_pos)
+
+			if (ir_pos == RC5_WORD_LEN)
+				sms_rc5_parse_word(coredev);
+			else if (ir_pos) /* timeout within a word */
+				sms_info("IR error parsing a word");
+
+			ir_pos = 0;
+			ir_word = 0;
+			/* sms_info("timeout %d", time); */
+			break;
+		}
+		/* The time is within the range of this number of bits */
+		for (j = 0 ; j < i ; j++)
+			RC5_PUSH_BIT(ir_word, level, ir_pos)
+
+		break;
+	}
+}
+
+void sms_ir_event(struct smscore_device_t *coredev, const char *buf, int len)
+{
+	#define IR_DATA_RECEIVE_MAX_LEN	520 /* 128*4 + 4 + 4 */
+	u32 i;
+	enum ir_protocol ir_protocol =
+			keyboard_layout_maps[coredev->ir.ir_kb_type]
+					     .ir_protocol;
+	s32 *samples;
+	int count = len>>2;
+
+	samples = (s32 *)buf;
+/*	sms_info("IR buffer received, length = %d", count);*/
+
+	for (i = 0; i < count; i++)
+		if (ir_protocol == IR_RC5)
+			sms_rc5_accumulate_bits(coredev, samples[i]);
+	/*  IR_RCMM not implemented */
+}
+
+int sms_ir_init(struct smscore_device_t *coredev)
+{
+	struct input_dev *input_dev;
+
+	sms_info("Allocating input device");
+	input_dev = input_allocate_device();
+	if (!input_dev)	{
+		sms_err("Not enough memory");
+		return -ENOMEM;
+	}
+
+	coredev->ir.input_dev = input_dev;
+	coredev->ir.ir_kb_type =
+		sms_get_board(smscore_get_board_id(coredev))->ir_kb_type;
+	coredev->ir.keyboard_layout_map =
+		keyboard_layout_maps[coredev->ir.ir_kb_type].
+				keyboard_layout_map;
+	sms_info("IR remote keyboard type is %d", coredev->ir.ir_kb_type);
+
+	coredev->ir.controller = 0;	/* Todo: vega/nova SPI number */
+	coredev->ir.timeout = IR_DEFAULT_TIMEOUT;
+	sms_info("IR port %d, timeout %d ms",
+			coredev->ir.controller, coredev->ir.timeout);
+
+	snprintf(coredev->ir.name,
+				IR_DEV_NAME_MAX_LEN,
+				"SMS IR w/kbd type %d",
+				coredev->ir.ir_kb_type);
+	input_dev->name = coredev->ir.name;
+	input_dev->phys = coredev->ir.name;
+	input_dev->dev.parent = coredev->device;
+
+	/* Key press events only */
+	input_dev->evbit[0] = BIT_MASK(EV_KEY);
+	input_dev->keybit[BIT_WORD(BTN_0)] = BIT_MASK(BTN_0);
+
+	sms_info("Input device (IR) %s is set for key events", input_dev->name);
+
+	if (input_register_device(input_dev)) {
+		sms_err("Failed to register device");
+		input_free_device(input_dev);
+		return -EACCES;
+	}
+
+	return 0;
+}
+
+void sms_ir_exit(struct smscore_device_t *coredev)
+{
+	if (coredev->ir.input_dev)
+		input_unregister_device(coredev->ir.input_dev);
+
+	sms_info("");
+}
+
diff --git a/drivers/media/dvb/siano/smsir.h b/drivers/media/dvb/siano/smsir.h
new file mode 100644
index 0000000..b7d703e
--- /dev/null
+++ b/drivers/media/dvb/siano/smsir.h
@@ -0,0 +1,93 @@
+/****************************************************************
+
+Siano Mobile Silicon, Inc.
+MDTV receiver kernel modules.
+Copyright (C) 2006-2009, Uri Shkolnik
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+****************************************************************/
+
+#ifndef __SMS_IR_H__
+#define __SMS_IR_H__
+
+#include <linux/input.h>
+
+#define IR_DEV_NAME_MAX_LEN		23 /* "SMS IR kbd type nn\0" */
+#define IR_KEYBOARD_LAYOUT_SIZE	64
+#define IR_DEFAULT_TIMEOUT		100
+
+enum ir_kb_type {
+	SMS_IR_KB_DEFAULT_TV,
+	SMS_IR_KB_HCW_SILVER
+};
+
+enum rc5_keyboard_address {
+	KEYBOARD_ADDRESS_TV1 = 0,
+	KEYBOARD_ADDRESS_TV2 = 1,
+	KEYBOARD_ADDRESS_TELETEXT = 2,
+	KEYBOARD_ADDRESS_VIDEO = 3,
+	KEYBOARD_ADDRESS_LV1 = 4,
+	KEYBOARD_ADDRESS_VCR1 = 5,
+	KEYBOARD_ADDRESS_VCR2 = 6,
+	KEYBOARD_ADDRESS_EXPERIMENTAL = 7,
+	KEYBOARD_ADDRESS_SAT1 = 8,
+	KEYBOARD_ADDRESS_CAMERA = 9,
+	KEYBOARD_ADDRESS_SAT2 = 10,
+	KEYBOARD_ADDRESS_CDV = 12,
+	KEYBOARD_ADDRESS_CAMCORDER = 13,
+	KEYBOARD_ADDRESS_PRE_AMP = 16,
+	KEYBOARD_ADDRESS_TUNER = 17,
+	KEYBOARD_ADDRESS_RECORDER1 = 18,
+	KEYBOARD_ADDRESS_PRE_AMP1 = 19,
+	KEYBOARD_ADDRESS_CD_PLAYER = 20,
+	KEYBOARD_ADDRESS_PHONO = 21,
+	KEYBOARD_ADDRESS_SATA = 22,
+	KEYBOARD_ADDRESS_RECORDER2 = 23,
+	KEYBOARD_ADDRESS_CDR = 26,
+	KEYBOARD_ADDRESS_LIGHTING = 29,
+	KEYBOARD_ADDRESS_LIGHTING1 = 30, /* KEYBOARD_ADDRESS_HCW_SILVER */
+	KEYBOARD_ADDRESS_PHONE = 31,
+	KEYBOARD_ADDRESS_NOT_RC5 = 0xFFFF
+};
+
+enum ir_protocol {
+	IR_RC5,
+	IR_RCMM
+};
+
+struct keyboard_layout_map_t {
+	enum ir_protocol ir_protocol;
+	enum rc5_keyboard_address rc5_kbd_address;
+	u16 keyboard_layout_map[IR_KEYBOARD_LAYOUT_SIZE];
+};
+
+struct smscore_device_t;
+
+struct ir_t {
+	struct input_dev *input_dev;
+	enum ir_kb_type ir_kb_type;
+	char name[IR_DEV_NAME_MAX_LEN+1];
+	u16 *keyboard_layout_map;
+	u32 timeout;
+	u32 controller;
+};
+
+int sms_ir_init(struct smscore_device_t *coredev);
+void sms_ir_exit(struct smscore_device_t *coredev);
+void sms_ir_event(struct smscore_device_t *coredev,
+			const char *buf, int len);
+
+#endif /* __SMS_IR_H__ */
+
diff --git a/drivers/media/dvb/siano/smsspicommon.c b/drivers/media/dvb/siano/smsspicommon.c
new file mode 100644
index 0000000..4c714f3
--- /dev/null
+++ b/drivers/media/dvb/siano/smsspicommon.c
@@ -0,0 +1,384 @@
+/****************************************************************
+
+Siano Mobile Silicon, Inc.
+MDTV receiver kernel modules.
+Copyright (C) 2006-2008, Uri Shkolnik
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+****************************************************************/
+#include "smsspicommon.h"
+#include "smsdbg_prn.h"
+
+static struct _rx_buffer_st *smsspi_handle_unused_bytes_buf(
+		struct _spi_dev *dev,
+		struct _rx_buffer_st *buf, int offset, int len,
+		int unused_bytes)
+{
+	struct _rx_buffer_st *tmp_buf;
+	tmp_buf = dev->cb.allocate_rx_buf(dev->context,
+		RX_PACKET_SIZE);
+	if (!tmp_buf) {
+		PRN_ERR((TXT
+			("Failed to allocate RX buffer.\n")));
+		return NULL;
+	}
+	if (unused_bytes > 0) {
+		/* Copy the remaining bytes to the end of
+		alignment block (256 bytes) so next read
+		will be aligned. */
+		int align_block =
+			(((unused_bytes + SPI_PACKET_SIZE -
+			1) >> SPI_PACKET_SIZE_BITS) <<
+			SPI_PACKET_SIZE_BITS);
+		memset(tmp_buf->ptr, 0,
+			align_block - unused_bytes);
+		memcpy((char *)tmp_buf->ptr +
+			(align_block - unused_bytes),
+			(char *)buf->ptr + offset + len -
+			unused_bytes, unused_bytes);
+	}
+	return tmp_buf;
+}
+
+static struct _rx_buffer_st *smsspi_common_find_msg(struct _spi_dev *dev,
+		struct _rx_buffer_st *buf, int offset, int len,
+		int *unused_bytes, int *missing_bytes)
+{
+	int i;
+	int recieved_bytes, padded_msg_len;
+	int align_fix;
+	int msg_offset;
+	char *ptr = (char *)buf->ptr + offset;
+	if (unused_bytes == NULL || missing_bytes == NULL)
+		return NULL;
+
+	*missing_bytes = 0;
+	*unused_bytes = 0;
+
+	PRN_DBG((TXT("entering with %d bytes.\n"), len));
+	for (i = 0; i < len; i++, ptr++) {
+		switch (dev->rxState) {
+		case RxsWait_a5:
+			dev->rxState =
+			    ((*ptr & 0xff) == 0xa5) ? RxsWait_5a : RxsWait_a5;
+			dev->rxPacket.msg_offset =
+			    (unsigned long)ptr - (unsigned long)buf->ptr + 4;
+			break;
+		case RxsWait_5a:
+			dev->rxState =
+			    ((*ptr & 0xff) == 0x5a) ? RxsWait_e7 : RxsWait_a5;
+			/*PRN_DBG((TXT("state %d.\n"), dev->rxState));*/
+			break;
+		case RxsWait_e7:
+			dev->rxState =
+			    ((*ptr & 0xff) == 0xe7) ? RxsWait_7e : RxsWait_a5;
+			/*PRN_DBG((TXT("state %d.\n"), dev->rxState));*/
+			break;
+		case RxsWait_7e:
+			dev->rxState =
+			    ((*ptr & 0xff) == 0x7e) ? RxsTypeH : RxsWait_a5;
+			/*PRN_DBG((TXT("state %d.\n"), dev->rxState));*/
+			break;
+		case RxsTypeH:
+			dev->rxPacket.msg_buf = buf;
+			dev->rxPacket.msg_offset =
+			    (unsigned long)ptr - (unsigned long)buf->ptr;
+			dev->rxState = RxsTypeL;
+			/*PRN_DBG((TXT("state %d.\n"), dev->rxState));*/
+			break;
+		case RxsTypeL:
+			dev->rxState = RxsGetSrcId;
+			/*PRN_DBG((TXT("state %d.\n"), dev->rxState));*/
+			break;
+		case RxsGetSrcId:
+			dev->rxState = RxsGetDstId;
+			/*PRN_DBG((TXT("state %d.\n"), dev->rxState));*/
+			break;
+		case RxsGetDstId:
+			dev->rxState = RxsGetLenL;
+			/*PRN_DBG((TXT("state %d.\n"), dev->rxState));*/
+			break;
+		case RxsGetLenL:
+			dev->rxState = RxsGetLenH;
+			dev->rxPacket.msg_len = (*ptr & 0xff);
+			/*PRN_DBG((TXT("state %d.\n"), dev->rxState));*/
+			break;
+		case RxsGetLenH:
+			dev->rxState = RxsFlagsL;
+			dev->rxPacket.msg_len += (*ptr & 0xff) << 8;
+			/*PRN_DBG((TXT("state %d.\n"), dev->rxState));*/
+			break;
+		case RxsFlagsL:
+			dev->rxState = RxsFlagsH;
+			dev->rxPacket.msg_flags = (*ptr & 0xff);
+			/*PRN_DBG((TXT("state %d.\n"), dev->rxState));*/
+			break;
+		case RxsFlagsH:
+			dev->rxState = RxsData;
+			dev->rxPacket.msg_flags += (*ptr & 0xff) << 8;
+			/*PRN_DBG((TXT("state %d.\n"), dev->rxState));*/
+			break;
+		case RxsData:
+			recieved_bytes =
+			    len + offset - dev->rxPacket.msg_offset;
+			padded_msg_len =
+			    ((dev->rxPacket.msg_len + 4 + SPI_PACKET_SIZE -
+			      1) >> SPI_PACKET_SIZE_BITS) <<
+			    SPI_PACKET_SIZE_BITS;
+			if (recieved_bytes < padded_msg_len) {
+				*unused_bytes = 0;
+				*missing_bytes = padded_msg_len -
+						recieved_bytes;
+				return buf;
+			}
+			dev->rxState = RxsWait_a5;
+			if (dev->cb.msg_found_cb) {
+				align_fix = 0;
+				if (dev->rxPacket.
+				    msg_flags & MSG_HDR_FLAG_SPLIT_MSG_HDR) {
+					align_fix =
+					    (dev->rxPacket.
+					     msg_flags >> 8) & 0x3;
+					/* The FW aligned the message data
+					therefore - alignment bytes should be
+					thrown away. Throw the alignment bytes
+					by moving the header ahead over the
+					alignment bytes. */
+					if (align_fix) {
+						int length;
+						ptr =
+						    (char *)dev->rxPacket.
+						    msg_buf->ptr +
+						    dev->rxPacket.msg_offset;
+
+						/* Restore header to original
+						state before alignment changes
+						*/
+						length =
+						    (ptr[5] << 8) | ptr[4];
+						length -= align_fix;
+						ptr[5] = length >> 8;
+						ptr[4] = length & 0xff;
+						/* Zero alignment flags */
+						ptr[7] &= 0xfc;
+
+						for (i = MSG_HDR_LEN - 1;
+						     i >= 0; i--) {
+							ptr[i + align_fix] =
+							    ptr[i];
+						}
+						dev->rxPacket.msg_offset +=
+						    align_fix;
+					}
+				}
+
+
+				/* force all messages to start on
+				 * 4-byte boundary */
+				msg_offset = dev->rxPacket.msg_offset;
+				if (msg_offset & 0x3)	{
+					msg_offset &= (~0x3);
+					memmove((unsigned char *)
+						(dev->rxPacket.msg_buf->ptr)
+						+ msg_offset,
+						(unsigned char *)
+						(dev->rxPacket.msg_buf->ptr)
+						+ dev->rxPacket.msg_offset,
+						dev->rxPacket.msg_len -
+						align_fix);
+				}
+
+				*unused_bytes =
+				    len + offset - dev->rxPacket.msg_offset -
+				    dev->rxPacket.msg_len;
+
+				/* In any case we got here - unused_bytes
+				 * should not be 0 Because we want to force
+				 * reading at least 256 after the end
+				 * of any found message */
+				if (*unused_bytes == 0)
+					*unused_bytes = -1;
+
+				buf = smsspi_handle_unused_bytes_buf(dev, buf,
+						offset, len, *unused_bytes);
+
+				dev->cb.msg_found_cb(dev->context,
+							 dev->rxPacket.msg_buf,
+							 msg_offset,
+							 dev->rxPacket.msg_len -
+							 align_fix);
+				*missing_bytes = 0;
+				return buf;
+			} else {
+				PRN_DBG((TXT
+		 ("Msg found but no callback. therefore - thrown away.\n")));
+			}
+			/*PRN_DBG((TXT("state %d.\n"), dev->rxState));*/
+			break;
+		}
+	}
+
+	if (dev->rxState == RxsWait_a5) {
+		*unused_bytes = 0;
+		*missing_bytes = 0;
+		return buf;
+	} else {
+		/* Workaround to corner case: if the last byte of the buffer
+		is "a5" (first byte of the preamble), the host thinks it should
+		send another 256 bytes.  In case the a5 is the firmware
+		underflow byte, this will cause an infinite loop, so we check
+		for this case explicity. */
+		if ((dev->rxState == RxsWait_5a) && (*(ptr - 2) == 0xa5)) {
+			dev->rxState = RxsWait_a5;
+			*unused_bytes = 0;
+			*missing_bytes = 0;
+			return buf;
+		}
+
+		if (dev->rxPacket.msg_offset >= (SPI_PACKET_SIZE + 4))
+			/* adding 4 for the preamble. */
+		{		/*The packet will be copied to a new buffer
+				   and rescaned by the state machine */
+			struct _rx_buffer_st *tmp_buf = buf;
+			*unused_bytes = dev->rxState - RxsWait_a5;
+			tmp_buf = smsspi_handle_unused_bytes_buf(dev, buf,
+					offset, len, *unused_bytes);
+			dev->rxState = RxsWait_a5;
+			dev->cb.free_rx_buf(dev->context, buf);
+			*missing_bytes = 0;
+			return tmp_buf;
+		} else {
+			/* report missing bytes and continue
+			   with message scan. */
+			*unused_bytes = 0;
+			*missing_bytes = SPI_PACKET_SIZE;
+			return buf;
+		}
+	}
+}
+
+void smsspi_common_transfer_msg(struct _spi_dev *dev, struct _spi_msg *txmsg,
+				int padding_allowed)
+{
+	int len, bytes_to_transfer;
+	unsigned long tx_phy_addr;
+	int missing_bytes, tx_bytes;
+	int offset, unused_bytes;
+	int align_block;
+	char *txbuf;
+	struct _rx_buffer_st *buf, *tmp_buf;
+
+	len = 0;
+	if (!dev->cb.transfer_data_cb) {
+		PRN_ERR((TXT
+		("function called while module is not initialized.\n")));
+		return;
+	}
+	if (txmsg == 0) {
+		bytes_to_transfer = SPI_PACKET_SIZE;
+		txbuf = 0;
+		tx_phy_addr = 0;
+		tx_bytes = 0;
+	} else {
+		tx_bytes = txmsg->len;
+		if (padding_allowed)
+			bytes_to_transfer =
+			    (((tx_bytes + SPI_PACKET_SIZE -
+			       1) >> SPI_PACKET_SIZE_BITS) <<
+			     SPI_PACKET_SIZE_BITS);
+		else
+			bytes_to_transfer = (((tx_bytes + 3) >> 2) << 2);
+		txbuf = txmsg->buf;
+		tx_phy_addr = txmsg->buf_phy_addr;
+	}
+	offset = 0;
+	unused_bytes = 0;
+	buf =
+	    dev->cb.allocate_rx_buf(dev->context,
+				    RX_PACKET_SIZE + SPI_PACKET_SIZE);
+	if (!buf) {
+		PRN_ERR((TXT("Failed to allocate RX buffer.\n")));
+		return;
+	}
+	while (bytes_to_transfer || unused_bytes) {
+		if ((unused_bytes <= 0) && (bytes_to_transfer > 0)) {
+			len = min(bytes_to_transfer, RX_PACKET_SIZE);
+			dev->cb.transfer_data_cb(dev->phy_context,
+				(unsigned char *)txbuf,
+				tx_phy_addr,
+				(unsigned char *)buf->ptr + offset,
+				buf->phy_addr + offset, len);
+		}
+
+		tmp_buf =
+		    smsspi_common_find_msg(dev, buf, offset, len,
+					   &unused_bytes, &missing_bytes);
+		if (bytes_to_transfer)
+			bytes_to_transfer -= len;
+
+		if (tx_bytes)
+			tx_bytes -= len;
+
+		if (missing_bytes)
+			offset += len;
+
+		if (unused_bytes) {
+			/* In this case tmp_buf is a new buffer allocated
+			 * in smsspi_common_find_msg
+			 * and it already contains the unused bytes */
+			if (unused_bytes > 0) {
+				align_block =
+				    (((unused_bytes + SPI_PACKET_SIZE -
+				       1) >> SPI_PACKET_SIZE_BITS) <<
+				     SPI_PACKET_SIZE_BITS);
+				len = align_block;
+			}
+			offset = 0;
+			buf = tmp_buf;
+		}
+		if (tx_bytes <= 0) {
+			txbuf = 0;
+			tx_bytes = 0;
+		}
+		if (bytes_to_transfer < missing_bytes) {
+			bytes_to_transfer =
+			    (((missing_bytes + SPI_PACKET_SIZE -
+			       1) >> SPI_PACKET_SIZE_BITS) <<
+			     SPI_PACKET_SIZE_BITS);
+			/*PRN_DBG((TXT
+	("a message was found, adding bytes to transfer, txmsg %d, total %d\n")
+			, tx_bytes, bytes_to_transfer));*/
+		}
+	}
+	dev->cb.free_rx_buf(dev->context, buf);
+}
+
+int smsspicommon_init(struct _spi_dev *dev, void *context, void *phy_context,
+		      struct _spi_dev_cb_st *cb)
+{
+	PRN_DBG((TXT("entering.\n")));
+	if (cb->transfer_data_cb == 0 ||
+	    cb->msg_found_cb == 0 ||
+	    cb->allocate_rx_buf == 0 || cb->free_rx_buf == 0) {
+		PRN_ERR((TXT("Invalid input parameters of init routine.\n")));
+		return -1;
+	}
+	dev->context = context;
+	dev->phy_context = phy_context;
+	memcpy(&dev->cb, cb, sizeof(struct _spi_dev_cb_st));
+	dev->rxState = RxsWait_a5;
+	PRN_DBG((TXT("exiting.\n")));
+	return 0;
+}
diff --git a/drivers/media/dvb/siano/smsspicommon.h b/drivers/media/dvb/siano/smsspicommon.h
new file mode 100644
index 0000000..cfcc6b1
--- /dev/null
+++ b/drivers/media/dvb/siano/smsspicommon.h
@@ -0,0 +1,96 @@
+/****************************************************************
+
+Siano Mobile Silicon, Inc.
+MDTV receiver kernel modules.
+Copyright (C) 2006-2008, Uri Shkolnik
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+****************************************************************/
+#ifndef _SMS_SPI_COMMON_H_
+#define _SMS_SPI_COMMON_H_
+
+#define RX_PACKET_SIZE  		0x1000
+#define SPI_PACKET_SIZE_BITS		8
+#define SPI_PACKET_SIZE 		(1<<SPI_PACKET_SIZE_BITS)
+#define SPI_MAX_CTRL_MSG_SIZE		0x100
+
+#define MSG_HDR_FLAG_SPLIT_MSG_HDR	0x0004
+#define MSG_HDR_LEN			8
+
+enum _spi_rx_state {
+	RxsWait_a5 = 0,
+	RxsWait_5a,
+	RxsWait_e7,
+	RxsWait_7e,
+	RxsTypeH,
+	RxsTypeL,
+	RxsGetSrcId,
+	RxsGetDstId,
+	RxsGetLenL,
+	RxsGetLenH,
+	RxsFlagsL,
+	RxsFlagsH,
+	RxsData
+};
+
+struct _rx_buffer_st {
+	void *ptr;
+	unsigned long phy_addr;
+};
+
+struct _rx_packet_request {
+	struct _rx_buffer_st *msg_buf;
+	int msg_offset;
+	int msg_len;
+	int msg_flags;
+};
+
+struct _spi_dev_cb_st{
+	void (*transfer_data_cb) (void *context, unsigned char *, unsigned long,
+				  unsigned char *, unsigned long, int);
+	void (*msg_found_cb) (void *, void *, int, int);
+	struct _rx_buffer_st *(*allocate_rx_buf) (void *, int);
+	void (*free_rx_buf) (void *, struct _rx_buffer_st *);
+};
+
+struct _spi_dev {
+	void *context;
+	void *phy_context;
+	struct _spi_dev_cb_st cb;
+	char *rxbuf;
+	enum _spi_rx_state rxState;
+	struct _rx_packet_request rxPacket;
+	char *internal_tx_buf;
+};
+
+struct _spi_msg {
+	char *buf;
+	unsigned long buf_phy_addr;
+	int len;
+};
+
+void smsspi_common_transfer_msg(struct _spi_dev *dev, struct _spi_msg *txmsg,
+				int padding_allowed);
+int smsspicommon_init(struct _spi_dev *dev, void *contex, void *phy_context,
+		      struct _spi_dev_cb_st *cb);
+
+#if defined HEXDUMP_DEBUG && defined SPIBUS_DEBUG
+/*! dump a human readable print of a binary buffer */
+void smsspi_khexdump(char *buf, int len);
+#else
+#define smsspi_khexdump(buf, len)
+#endif
+
+#endif /*_SMS_SPI_COMMON_H_*/
diff --git a/drivers/media/dvb/siano/smsspilog.c b/drivers/media/dvb/siano/smsspilog.c
new file mode 100644
index 0000000..d728cb6
--- /dev/null
+++ b/drivers/media/dvb/siano/smsspilog.c
@@ -0,0 +1,506 @@
+/****************************************************************
+
+Siano Mobile Silicon, Inc.
+MDTV receiver kernel modules.
+Copyright (C) 2006-2008, Uri Shkolnik
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+****************************************************************/
+/*!
+	\file	spibusdrv.c
+
+	\brief	spi bus driver module
+
+	This file contains implementation of the spi bus driver.
+*/
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+
+#include <linux/spi/spi.h>
+#include <linux/time.h>
+
+#include "smscoreapi.h"
+#include "smsdbg_prn.h"
+#include "smsspicommon.h"
+#include "smsspiphy.h"
+
+#define ANDROID_2_6_25
+#ifdef ANDROID_2_6_25
+#include <linux/workqueue.h>
+#endif
+
+
+#define SMS_INTR_PIN			16  /* 0 for nova sip, 26 for vega */
+#define TX_BUFFER_SIZE			0x200
+#define RX_BUFFER_SIZE			(0x1000 + SPI_PACKET_SIZE + 0x100)
+#define NUM_RX_BUFFERS			72
+
+struct _spi_device_st {
+	struct _spi_dev dev;
+	void *phy_dev;
+
+	struct completion write_operation;
+	struct list_head tx_queue;
+	int allocatedPackets;
+	int padding_allowed;
+	char *rxbuf;
+	dma_addr_t rxbuf_phy_addr;
+
+	struct smscore_device_t *coredev;
+	struct list_head txqueue;
+	char *txbuf;
+	dma_addr_t txbuf_phy_addr;
+
+#if defined(MOT_FEAT_OMAP_DMA_USE)
+  int dma_tx_channel;
+  int dma_rx_channel;
+#endif
+};
+
+struct _smsspi_txmsg {
+	struct list_head node;	/*! internal management */
+	void *buffer;
+	size_t size;
+	int alignment;
+	int add_preamble;
+	struct completion completion;
+	void (*prewrite) (void *);
+	void (*postwrite) (void *);
+};
+
+struct _spi_device_st *spi_dev;
+
+static void spi_worker_thread(void *arg);
+static DECLARE_WORK(spi_work_queue, (void *)spi_worker_thread);
+static u8 smsspi_preamble[] = { 0xa5, 0x5a, 0xe7, 0x7e };
+static u8 smsspi_startup[] = { 0, 0, 0xde, 0xc1, 0xa5, 0x51, 0xf1, 0xed };
+static u32 default_type = SMS_NOVA_B0; /*SMS_NOVA_A0;*/
+static u32 intr_pin = SMS_INTR_PIN;
+
+module_param(default_type, int, 0644);
+MODULE_PARM_DESC(default_type, "default board type.");
+
+module_param(intr_pin, int, 0644);
+MODULE_PARM_DESC(intr_pin, "interrupt pin number.");
+
+/******************************************/
+static void spi_worker_thread(void *arg)
+{
+	struct _spi_device_st *spi_device = spi_dev;
+	struct _smsspi_txmsg *msg = NULL;
+	struct _spi_msg txmsg;
+
+	/*PDEBUG("worker start\n");*/
+	do {
+		/* do we have a msg to write ? */
+		if (!msg && !list_empty(&spi_device->txqueue))
+			msg = (struct _smsspi_txmsg *)
+					list_entry(spi_device->txqueue.
+					next, struct _smsspi_txmsg, node);
+
+		if (msg) {
+			if (msg->add_preamble) {
+				txmsg.len =
+				    min(msg->size + sizeof(smsspi_preamble),
+					(size_t) TX_BUFFER_SIZE);
+				txmsg.buf = spi_device->txbuf;
+				txmsg.buf_phy_addr = spi_device->txbuf_phy_addr;
+				memcpy(txmsg.buf, smsspi_preamble,
+				       sizeof(smsspi_preamble));
+				memcpy(&txmsg.buf[sizeof(smsspi_preamble)],
+				       msg->buffer,
+				       txmsg.len - sizeof(smsspi_preamble));
+				msg->add_preamble = 0;
+				msg->buffer +=
+				    txmsg.len - sizeof(smsspi_preamble);
+				msg->size -=
+				    txmsg.len - sizeof(smsspi_preamble);
+				/* zero out the rest of aligned buffer */
+				memset(&txmsg.buf[txmsg.len], 0,
+				       TX_BUFFER_SIZE - txmsg.len);
+				smsspi_common_transfer_msg(&spi_device->dev,
+							   &txmsg, 1);
+			} else {
+				txmsg.len =
+				    min(msg->size, (size_t) TX_BUFFER_SIZE);
+				txmsg.buf = spi_device->txbuf;
+				txmsg.buf_phy_addr = spi_device->txbuf_phy_addr;
+				memcpy(txmsg.buf, msg->buffer, txmsg.len);
+
+				msg->buffer += txmsg.len;
+				msg->size -= txmsg.len;
+				/* zero out the rest of aligned buffer */
+				memset(&txmsg.buf[txmsg.len], 0,
+				       TX_BUFFER_SIZE - txmsg.len);
+				smsspi_common_transfer_msg(&spi_device->dev,
+							   &txmsg, 0);
+			}
+
+		} else {
+			smsspi_common_transfer_msg(&spi_device->dev, NULL, 1);
+		}
+
+		/* if there was write, have we finished ? */
+		if (msg && !msg->size) {
+			/* call postwrite call back */
+			if (msg->postwrite)
+				msg->postwrite(spi_device);
+
+			list_del(&msg->node);
+			complete(&msg->completion);
+			msg = NULL;
+		}
+		/* if there was read, did we read anything ? */
+
+	} while (!list_empty(&spi_device->txqueue) || msg);
+
+	/*PDEBUG("worker end\n");*/
+
+}
+
+static void msg_found(void *context, void *buf, int offset, int len)
+{
+	struct _spi_device_st *spi_device = (struct _spi_device_st *) context;
+	struct smscore_buffer_t *cb =
+	    (struct smscore_buffer_t
+	     *)(container_of(buf, struct smscore_buffer_t, p));
+
+	/*PDEBUG("entering\n");*/
+	cb->offset = offset;
+	cb->size = len;
+	/* PERROR ("buffer %p is sent back to core databuf=%p,
+		offset=%d.\n", cb, cb->p, cb->offset); */
+	smscore_onresponse(spi_device->coredev, cb);
+
+	/*PDEBUG("exiting\n");*/
+
+}
+
+static void smsspi_int_handler(void *context)
+{
+	struct _spi_device_st *spi_device = (struct _spi_device_st *) context;
+
+	PREPARE_WORK(&spi_work_queue, (void *)spi_worker_thread);
+	spi_device->padding_allowed = 1;
+	schedule_work(&spi_work_queue);
+}
+
+static int smsspi_queue_message_and_wait(struct _spi_device_st *spi_device,
+					 struct _smsspi_txmsg *msg)
+{
+	init_completion(&msg->completion);
+	list_add_tail(&msg->node, &spi_device->txqueue);
+	schedule_work(&spi_work_queue);
+	wait_for_completion(&msg->completion);
+
+	return 0;
+}
+
+/*##w21558*/
+#ifdef __SMS_DUMMY_INT__
+static int smsspi_SetIntLine(void *context)
+{
+	struct _Msg {
+		struct SmsMsgHdr_ST hdr;
+		u32 data[3];
+	} Msg = {
+		{
+		MSG_SMS_SPI_INT_LINE_SET_REQ, 0, HIF_TASK,
+			    sizeof(struct _Msg), 0}, {
+		0, intr_pin, 100}
+	};
+	struct _smsspi_txmsg msg;
+
+	PDEBUG("Sending SPI Set Interrupt command sequence\n");
+/*	fwDnlComplete(spi_device->phy_dev, 0);*/
+	msg.buffer = &Msg;
+	msg.size = sizeof(Msg);
+	msg.alignment = SPI_PACKET_SIZE;
+	msg.add_preamble = 1;
+	msg.prewrite = NULL;
+	msg.postwrite = NULL;	/* smsspiphy_restore_clock; */
+
+	return smsspi_queue_message_and_wait(context, &msg);
+/*	return 0;*/
+}
+#endif
+
+static int smsspi_preload(void *context)
+{
+	struct _smsspi_txmsg msg;
+	struct _spi_device_st *spi_device = (struct _spi_device_st *) context;
+
+	prepareForFWDnl(spi_device->phy_dev);
+	PDEBUG("Sending SPI init sequence\n");
+	msg.buffer = smsspi_startup;
+	msg.size = sizeof(smsspi_startup);
+	msg.alignment = 4;
+	msg.add_preamble = 0;
+	msg.prewrite = NULL;	/* smsspiphy_reduce_clock; */
+	msg.postwrite = NULL;
+
+	smsspi_queue_message_and_wait(context, &msg);
+	/*smsspi_SetIntLine(context);*/
+
+	return 0;
+}
+
+/*#if 0
+//ROCK 0331
+//Move INT_LINE_SET_REQ to the preload, enable the INT before FW download
+//Add MSG_SMS_SET_PERIODIC_STATS_REQ, enable the Period Statistics*/
+static int smsspi_postload(void *context)
+{
+	struct _Msg {
+		struct SmsMsgHdr_ST hdr;
+		u32 data[3];
+	} Msg = {
+		{
+		MSG_SMS_SPI_INT_LINE_SET_REQ, 0, HIF_TASK,
+			    sizeof(struct _Msg), 0}, {
+		0, intr_pin, 0}
+	};
+	struct _spi_device_st *spi_device = (struct _spi_device_st *) context;
+	struct _smsspi_txmsg msg;
+
+	PDEBUG("Sending SPI Set Interrupt command sequence\n");
+	fwDnlComplete(spi_device->phy_dev, 0);
+	msg.buffer = &Msg;
+	msg.size = sizeof(Msg);
+	msg.alignment = SPI_PACKET_SIZE;
+	msg.add_preamble = 1;
+	msg.prewrite = NULL;
+	msg.postwrite = NULL;	/* smsspiphy_restore_clock; */
+
+	return smsspi_queue_message_and_wait(context, &msg);
+}
+/*#endif*/
+
+
+static int smsspi_write(void *context, void *txbuf, size_t len)
+{
+	struct _smsspi_txmsg msg;
+
+	msg.buffer = txbuf;
+	msg.size = len;
+	msg.prewrite = NULL;
+	msg.postwrite = NULL;
+
+	if (len > 0x1000) {
+		/* The FW is the only long message. Do not add preamble,
+		and do not padd it */
+		msg.alignment = 4;
+		msg.add_preamble = 0;
+		msg.prewrite = smschipreset;
+	} else {
+		msg.alignment = SPI_PACKET_SIZE;
+		msg.add_preamble = 1;
+	}
+
+/*
+	PDEBUG("Writing message to  SPI.\n");
+	PDEBUG("msg hdr: 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\n",
+	       ((u8 *) txbuf)[0], ((u8 *) txbuf)[1], ((u8 *) txbuf)[2],
+	       ((u8 *) txbuf)[3], ((u8 *) txbuf)[4], ((u8 *) txbuf)[5],
+	       ((u8 *) txbuf)[6], ((u8 *) txbuf)[7]);
+	PDEBUG("0x%x, 0x%x,\n",    ((u8 *) txbuf)[0], ((u8 *) txbuf)[1]);
+*/
+
+	return smsspi_queue_message_and_wait(context, &msg);
+}
+
+struct _rx_buffer_st *allocate_rx_buf(void *context, int size)
+{
+	struct smscore_buffer_t *buf;
+	struct _spi_device_st *spi_device = (struct _spi_device_st *) context;
+	if (size > RX_BUFFER_SIZE) {
+		PERROR("Requested size is bigger than max buffer size.\n");
+		return NULL;
+	}
+	buf = smscore_getbuffer(spi_device->coredev);
+/*	PDEBUG("Recieved Rx buf %p physical 0x%x (contained in %p)\n", buf->p,
+		buf->phys, buf);*/
+
+	/* note: this is not mistake! the rx_buffer_st is identical to part of
+	   smscore_buffer_t and we return the address of the start of the
+	   identical part */
+	return (struct _rx_buffer_st *) &buf->p;
+}
+
+static void free_rx_buf(void *context, struct _rx_buffer_st *buf)
+{
+	struct _spi_device_st *spi_device = (struct _spi_device_st *) context;
+	struct smscore_buffer_t *cb =
+	    (struct smscore_buffer_t
+	     *)(container_of(((void *)buf), struct smscore_buffer_t, p));
+/*	PDEBUG("buffer %p is released.\n", cb);*/
+	smscore_putbuffer(spi_device->coredev, cb);
+}
+
+/*! Release device STUB
+
+\param[in]	dev:		device control block
+\return		void
+*/
+static void smsspi_release(struct device *dev)
+{
+	PDEBUG("nothing to do\n");
+	/* Nothing to release */
+}
+
+static struct platform_device smsspi_device = {
+	.name = "smsspi",
+	.id = 1,
+	.dev = {
+		.release = smsspi_release,
+		},
+};
+
+int smsspi_register(void)
+{
+	struct smsdevice_params_t params;
+	int ret;
+	struct _spi_device_st *spi_device;
+	struct _spi_dev_cb_st common_cb;
+
+	PDEBUG("entering \n");
+
+	spi_device =
+	    kmalloc(sizeof(struct _spi_device_st), GFP_KERNEL);
+	spi_dev = spi_device;
+
+	INIT_LIST_HEAD(&spi_device->txqueue);
+
+	ret = platform_device_register(&smsspi_device);
+	if (ret < 0) {
+		PERROR("platform_device_register failed\n");
+		return ret;
+	}
+
+/* w21558 */
+#if defined(MOT_FEAT_OMAP_DMA_USE)
+	spi_device->txbuf =
+	    dma_alloc_coherent(NULL, TX_BUFFER_SIZE,
+			       &spi_device->txbuf_phy_addr,
+			       GFP_KERNEL | GFP_DMA);
+	if (!spi_device->txbuf) {
+		printk(KERN_INFO "%s dma_alloc_coherent(...) failed\n",
+		       __func__);
+		ret = -ENOMEM;
+		goto txbuf_error;
+	}
+#endif
+
+	spi_device->phy_dev =
+	    smsspiphy_init(NULL, smsspi_int_handler, &spi_device);
+	if (spi_device->phy_dev == 0) {
+		printk(KERN_INFO "%s smsspiphy_init(...) failed\n", __func__);
+		goto phy_error;
+	}
+
+	common_cb.allocate_rx_buf = allocate_rx_buf;
+	common_cb.free_rx_buf = free_rx_buf;
+	common_cb.msg_found_cb = msg_found;
+	common_cb.transfer_data_cb = smsspibus_xfer;
+
+	ret =
+	    smsspicommon_init(&spi_device->dev, spi_device, spi_device->phy_dev,
+			      &common_cb);
+	if (ret) {
+		printk(KERN_INFO "%s smsspiphy_init(...) failed\n", __func__);
+		goto common_error;
+	}
+
+	/* register in smscore */
+	memset(&params, 0, sizeof(params));
+	params.context = spi_device;
+	params.device = &smsspi_device.dev;
+	params.buffer_size = RX_BUFFER_SIZE;
+	params.num_buffers = NUM_RX_BUFFERS;
+	params.flags = SMS_DEVICE_NOT_READY;
+	params.sendrequest_handler = smsspi_write;
+	strcpy(params.devpath, "spi");
+	params.device_type = default_type;
+
+	if (0) {
+		/* device family */
+		/* params.setmode_handler = smsspi_setmode; */
+	} else {
+		params.flags =
+		    SMS_DEVICE_FAMILY2 | SMS_DEVICE_NOT_READY |
+		    SMS_ROM_NO_RESPONSE;
+		params.preload_handler = smsspi_preload;
+		params.postload_handler = smsspi_postload;
+	}
+
+	ret = smscore_register_device(&params, &spi_device->coredev);
+	if (ret < 0) {
+		printk(KERN_INFO "%s smscore_register_device(...) failed\n",
+		       __func__);
+		goto reg_device_error;
+	}
+
+	ret = smscore_start_device(spi_device->coredev);
+	if (ret < 0) {
+		printk(KERN_INFO "%s smscore_start_device(...) failed\n",
+		       __func__);
+		goto start_device_error;
+	}
+
+	PDEBUG("exiting\n");
+	return 0;
+
+start_device_error:
+	smscore_unregister_device(spi_device->coredev);
+
+reg_device_error:
+
+common_error:
+	smsspiphy_deinit(spi_device->phy_dev);
+
+phy_error:
+	dma_free_coherent(NULL, TX_BUFFER_SIZE, spi_device->txbuf,
+			  spi_device->txbuf_phy_addr);
+
+txbuf_error:
+	platform_device_unregister(&smsspi_device);
+
+	PDEBUG("exiting error %d\n", ret);
+
+	return ret;
+}
+
+void smsspi_unregister(void)
+{
+	struct _spi_device_st *spi_device = spi_dev;
+	PDEBUG("entering\n");
+
+	/* stop interrupts */
+	smsspiphy_deinit(spi_device->phy_dev);
+	smscore_unregister_device(spi_device->coredev);
+
+	dma_free_coherent(NULL, TX_BUFFER_SIZE, spi_device->txbuf,
+			spi_device->txbuf_phy_addr);
+
+	platform_device_unregister(&smsspi_device);
+	PDEBUG("exiting\n");
+}
diff --git a/drivers/media/dvb/siano/smsspiphy.h b/drivers/media/dvb/siano/smsspiphy.h
new file mode 100644
index 0000000..de7da4f
--- /dev/null
+++ b/drivers/media/dvb/siano/smsspiphy.h
@@ -0,0 +1,39 @@
+/****************************************************************
+
+Siano Mobile Silicon, Inc.
+MDTV receiver kernel modules.
+Copyright (C) 2006-2008, Uri Shkolnik
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+****************************************************************/
+
+#ifndef __SMS_SPI_PHY_H__
+#define __SMS_SPI_PHY_H__
+
+void smsspibus_xfer(void *context, unsigned char *txbuf,
+		    unsigned long txbuf_phy_addr, unsigned char *rxbuf,
+		    unsigned long rxbuf_phy_addr, int len);
+void *smsspiphy_init(void *context, void (*smsspi_interruptHandler) (void *),
+		     void *intr_context);
+void smsspiphy_deinit(void *context);
+void smschipreset(void *context);
+void WriteFWtoStellar(void *pSpiPhy, unsigned char *pFW, unsigned long Len);
+void prepareForFWDnl(void *pSpiPhy);
+void fwDnlComplete(void *context, int App);
+
+/*##w21558*/
+int smsspiphy_interrupt_control(int enable);
+
+#endif /* __SMS_SPI_PHY_H__ */
diff --git a/drivers/media/dvb/siano/smsspiphy_omap34xx.c b/drivers/media/dvb/siano/smsspiphy_omap34xx.c
new file mode 100644
index 0000000..3cd7cc0
--- /dev/null
+++ b/drivers/media/dvb/siano/smsspiphy_omap34xx.c
@@ -0,0 +1,374 @@
+/****************************************************************
+
+Siano Mobile Silicon, Inc.
+MDTV receiver kernel modules.
+Copyright (C) 2006-2008, Uri Shkolnik
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+****************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/irq.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/dma-mapping.h>
+#include <asm/dma.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/spi/spi.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/vmalloc.h>
+#include <linux/i2c.h>
+
+#include "smsdbg_prn.h"
+#include "smscoreapi.h"
+
+#include <linux/time.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+#include <mach/clock.h>
+
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <mach/system.h>
+#include <mach/dma.h>
+
+#include <linux/gpio_mapping.h>
+
+/* debug macro */
+#define tdmblog(fmt, arg...) printk(KERN_DEBUG "TDMB_SEQ: "fmt, ##arg)
+
+#define SPI_PACKET_SIZE 256
+
+/*
+#define MDTV_INT_N_GPIO         38
+#define MDTV_PWDN_GPIO          53
+#define MDTV_RESET_N_GPIO       54
+*/
+
+#define MDTV_INT_N_GPIO         get_gpio_by_name("mtv_int")
+#define MDTV_PWDN_GPIO          get_gpio_by_name("mtv_pwdn")
+#define MDTV_RESET_N_GPIO       get_gpio_by_name("mtv_reset_n")
+
+/* MTV_INT */
+#define SMS_IRQ_GPIO          MDTV_INT_N_GPIO
+
+#define TX_BUFFER_SIZE			0x200
+
+/* physical layer variables */
+/*! global bus data */
+struct spiphy_dev_s {
+	struct completion transfer_in_process;
+	void (*interruptHandler) (void *);
+	void *intr_context;
+	struct spi_device *dev;	/*!< device model stuff */
+	int irq;
+
+	char *txpad;
+	dma_addr_t txpad_phy_addr;
+};
+
+struct omap2_mcspi_cs {
+	void __iomem		*base;
+	unsigned long		phys;
+	int			word_len;
+};
+
+
+#define MOT_LP3907_DEV      1
+
+#define INTERRUPT_DISABLE     0
+#define INTERRUPT_ENABLE      1
+
+static struct spi_device *smsmdtv_dev;
+
+static int smsmdtv_int_enable_flag = INTERRUPT_ENABLE;
+
+/* SPI interrupt handler */
+static irqreturn_t spibus_interrupt(int irq, void *context)
+{
+	struct spiphy_dev_s *spiphy_dev = (struct spiphy_dev_s *) context;
+
+	if (spiphy_dev->interruptHandler)
+		spiphy_dev->interruptHandler(spiphy_dev->intr_context);
+
+	printk(KERN_INFO "spibus_interrupt.\n");
+	return IRQ_HANDLED;
+
+}
+
+#define SPI_MIN_BYTES (4)
+#define SMS_MAX_BUF_SIZE (0x1000)
+
+#if defined(MOT_FEAT_OMAP_DMA_USE)
+void smsspibus_xfer(void *context, unsigned char *txbuf,
+		    unsigned long txbuf_phy_addr, unsigned char *rxbuf,
+		    unsigned long rxbuf_phy_addr, int len)
+{
+  struct spi_transfer t;
+  struct spi_message  m;
+  struct spiphy_dev_s *spiphy_dev = (struct spiphy_dev_s *) context;
+  unsigned long txdma;
+
+  int status = -1;
+
+  if (txbuf == 0) {
+    txbuf = (unsigned char *)spiphy_dev->txpad;
+    txdma  = spiphy_dev->txpad_phy_addr;
+  } else {
+    txdma = txbuf_phy_addr;
+  }
+
+  spi_message_init(&m);
+
+  m.is_dma_mapped = 1;
+  memset(&t, 0, sizeof(struct spi_transfer));
+
+  t.tx_buf    = txbuf;
+  t.tx_dma    = txdma;
+  t.len       = len;
+  t.rx_buf    = rxbuf;
+  t.rx_dma    = rxbuf_phy_addr;
+  t.delay_usecs = 1;
+
+  spi_message_add_tail(&t, &m);
+
+  status = spi_sync(spiphy_dev->dev, &m);
+}
+
+#else
+void smsspibus_xfer(void *context, unsigned char *txbuf,
+		    unsigned long txbuf_phy_addr, unsigned char *rxbuf,
+		    unsigned long rxbuf_phy_addr, int len)
+{
+	struct spi_transfer	*t = 0;
+	struct spi_message	 m;
+	struct spiphy_dev_s *spiphy_dev = (struct spiphy_dev_s *) context;
+	int i = 0;
+	int status = -1;
+
+	t = spiphy_dev->spi_xfer;
+
+	spi_message_init(&m);
+
+	for (i = 0; i < len/SPI_MIN_BYTES; i++) {
+		memset(&t[i], 0, sizeof(struct spi_transfer));
+		t[i].tx_buf	 = txbuf;
+		t[i].len		 = SPI_MIN_BYTES;
+		t[i].rx_buf	 = rxbuf;
+
+		spi_message_add_tail(&t[i], &m);
+
+		if (txbuf)
+			txbuf += SPI_MIN_BYTES;
+		rxbuf += SPI_MIN_BYTES;
+	}
+
+	status = spi_sync(spiphy_dev->dev, &m);
+
+}
+#endif
+
+void smschipreset(void *context)
+{
+  return;
+}
+
+int smsmdtv_power_control(int pwrup_enable)
+{
+  int ret = 0, line = 0;
+
+  tdmblog("power control = %d\n", pwrup_enable);
+
+  if (pwrup_enable == 1) {
+
+#ifdef CONFIG_MOT_FEAT_TDMB_SUPPORT
+	tdmb_config_gpio_on();
+#endif
+	/* PWDN High */
+	gpio_set_value(MDTV_PWDN_GPIO, 1);
+	udelay(20);  /* at least, T = 10usec */
+
+	/* Reset High */
+	gpio_set_value(MDTV_RESET_N_GPIO, 1);
+	udelay(20);  /* at least, T = 10usec */
+
+	/* SMSMDTV interrupt enable */
+	if (smsmdtv_int_enable_flag == INTERRUPT_DISABLE) {
+	enable_irq(OMAP_GPIO_IRQ(SMS_IRQ_GPIO));
+	smsmdtv_int_enable_flag = INTERRUPT_ENABLE;
+	printk(KERN_INFO "enable_irq().\n");
+	}
+  } else {
+
+    /* SMSMDTV interrupt disable */
+    if (smsmdtv_int_enable_flag == INTERRUPT_ENABLE) {
+      disable_irq(OMAP_GPIO_IRQ(SMS_IRQ_GPIO));
+      smsmdtv_int_enable_flag = INTERRUPT_DISABLE;
+      printk(KERN_INFO "disable_irq().\n");
+    }
+
+	/* Reset Low */
+	gpio_set_value(MDTV_RESET_N_GPIO, 0);
+	udelay(20);  /* at least, T = 10usec */
+
+	/* PWDN Low */
+	gpio_set_value(MDTV_PWDN_GPIO, 0);
+	msleep(1);
+
+#ifdef CONFIG_MOT_FEAT_TDMB_SUPPORT
+	tdmb_config_gpio_off();
+#endif
+	}
+
+  if (ret < 0)
+    tdmblog("Power control sequence is failed.\n");
+
+	return ret;
+}
+
+static int __devinit smsmdtv_probe(struct spi_device *spi)
+{
+/*
+	struct spi_device *slave = spi;
+	struct omap2_mcspi_cs *cs = \
+		(struct omap2_mcspi_cs *)slave->controller_state;
+*/
+	int ret;
+
+	/* SPI setup is needed */
+	spi->mode = SPI_MODE_0;
+	spi->bits_per_word = 8;
+	ret = spi_setup(spi);
+	if (ret < 0) {
+		dev_err(&spi->dev, "[SMS] SPI setup failed\n");
+		goto err;
+	}
+
+	smsmdtv_dev = spi;
+    return ret;
+err:
+	return -1;
+}
+
+static struct spi_driver smsmdtv_driver = {
+  .driver = {
+    .name = "smsmdtv",
+    .bus  = &spi_bus_type,
+    .owner = THIS_MODULE,
+  },
+  .probe = smsmdtv_probe,
+};
+
+void *smsspiphy_init(void *context,
+	void (*smsspi_interruptHandler) (void *), void *intr_context)
+{
+  struct spiphy_dev_s *spiphy_dev;
+  int ret;
+
+  smsmdtv_dev = 0;
+
+	spiphy_dev = kmalloc(sizeof(struct spiphy_dev_s), GFP_KERNEL);
+	if (spiphy_dev == 0) {
+		sms_err("malloc for spi_dev failed");
+		goto err_malloc;
+	}
+	spiphy_dev->interruptHandler = smsspi_interruptHandler;
+	spiphy_dev->intr_context     = intr_context;
+
+  ret = spi_register_driver(&smsmdtv_driver);
+
+	if (ret < 0 || smsmdtv_dev == 0) {
+		sms_info("Cann't get SPI device\n");
+		goto err_register;
+  }
+
+	spiphy_dev->dev      = smsmdtv_dev;
+
+
+  /*spi_loop_test(slave);*/
+
+  spiphy_dev->irq = OMAP_GPIO_IRQ(SMS_IRQ_GPIO);
+
+  set_irq_type(spiphy_dev->irq, IRQ_TYPE_EDGE_RISING);
+	ret = request_irq(spiphy_dev->irq, spibus_interrupt, \
+		IRQF_TRIGGER_RISING|IRQF_DISABLED, "smsmdtv", spiphy_dev);
+
+	if (ret < 0) {
+		sms_err("Unable to request irq %d", ret);
+		goto err_irq;
+	}
+
+	spiphy_dev->txpad = dma_alloc_coherent(NULL, TX_BUFFER_SIZE,
+			&spiphy_dev->txpad_phy_addr,
+			GFP_KERNEL|GFP_DMA);
+	if (!spiphy_dev->txpad) {
+    ret = -ENOMEM;
+    goto err_txpad;
+	}
+  memset(spiphy_dev->txpad, 0xFF, TX_BUFFER_SIZE);
+
+
+	PDEBUG("exiting\n");
+	return spiphy_dev;
+
+err_txpad:
+  free_irq(spiphy_dev->irq, spiphy_dev);
+err_irq:
+  gpio_free(SMS_IRQ_GPIO);
+  spi_unregister_driver(&smsmdtv_driver);
+err_register:
+  kfree(spiphy_dev);
+err_malloc:
+	return 0;
+}
+
+int smsspiphy_deinit(void *context)
+{
+	struct spiphy_dev_s *spiphy_dev = (struct spiphy_dev_s *) context;
+
+	gpio_free(SMS_IRQ_GPIO);
+  spi_unregister_driver(&smsmdtv_driver);
+	free_irq(spiphy_dev->irq, spiphy_dev);
+  dma_free_coherent(NULL, TX_BUFFER_SIZE, \
+	spiphy_dev->txpad, spiphy_dev->txpad_phy_addr);
+	kfree(spiphy_dev);
+
+	return 0;
+}
+
+void smsspiphy_set_config(struct spiphy_dev_s *spiphy_dev, int clock_divider)
+{
+	/*Omap_SPI_Enable(&(spiphy_dev->sspdev));*/
+}
+
+void prepareForFWDnl(void *context)
+{
+	struct spiphy_dev_s *spiphy_dev = (struct spiphy_dev_s *) context;
+	smsspiphy_set_config(spiphy_dev, 2);
+	msleep(100);
+}
+
+void fwDnlComplete(void *context, int App)
+{
+	struct spiphy_dev_s *spiphy_dev = (struct spiphy_dev_s *) context;
+	smsspiphy_set_config(spiphy_dev, 1);
+	msleep(100);
+}
+
diff --git a/drivers/media/dvb/siano/smsusb.c b/drivers/media/dvb/siano/smsusb.c
index 5d7ca34..87a3c24 100644
--- a/drivers/media/dvb/siano/smsusb.c
+++ b/drivers/media/dvb/siano/smsusb.c
@@ -432,56 +432,11 @@ static void smsusb_disconnect(struct usb_interface *intf)
 	smsusb_term_device(intf);
 }
 
-static int smsusb_suspend(struct usb_interface *intf, pm_message_t msg)
-{
-	struct smsusb_device_t *dev =
-		(struct smsusb_device_t *)usb_get_intfdata(intf);
-	printk(KERN_INFO "%s  Entering status %d.\n", __func__, msg.event);
-	smsusb_stop_streaming(dev);
-	return 0;
-}
-
-static int smsusb_resume(struct usb_interface *intf)
-{
-	int rc, i;
-	struct smsusb_device_t *dev =
-		(struct smsusb_device_t *)usb_get_intfdata(intf);
-	struct usb_device *udev = interface_to_usbdev(intf);
-
-	printk(KERN_INFO "%s  Entering.\n", __func__);
-	usb_clear_halt(udev, usb_rcvbulkpipe(udev, 0x81));
-	usb_clear_halt(udev, usb_rcvbulkpipe(udev, 0x02));
-
-	for (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++)
-		printk(KERN_INFO "endpoint %d %02x %02x %d\n", i,
-		       intf->cur_altsetting->endpoint[i].desc.bEndpointAddress,
-		       intf->cur_altsetting->endpoint[i].desc.bmAttributes,
-		       intf->cur_altsetting->endpoint[i].desc.wMaxPacketSize);
-
-	if (intf->num_altsetting > 0) {
-		rc = usb_set_interface(udev,
-				       intf->cur_altsetting->desc.
-				       bInterfaceNumber, 0);
-		if (rc < 0) {
-			printk(KERN_INFO
-			       "%s usb_set_interface failed, rc %d\n",
-			       __func__, rc);
-			return rc;
-		}
-	}
-
-	smsusb_start_streaming(dev);
-	return 0;
-}
-
 static struct usb_driver smsusb_driver = {
 	.name			= "sms1xxx",
 	.probe			= smsusb_probe,
 	.disconnect		= smsusb_disconnect,
 	.id_table		= smsusb_id_table,
-
-	.suspend		= smsusb_suspend,
-	.resume			= smsusb_resume,
 };
 
 int smsusb_register(void)
diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index 9e4c2ca..6669856 100644
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -316,6 +316,26 @@ config VIDEO_MT9P012
 	  MT9P012 camera.  It is currently working with the TI OMAP3
 	  camera controller.
 
+config VIDEO_MIPI_INTERFACE
+	tristate "MIPI INTERFACE functionality"
+	depends on I2C && VIDEO_V4L2
+	---help---
+	  This is for MIPI INTERFACE functiionality
+
+config VIDEO_MIPI_DLI_TEST
+	tristate "MIPI DLI TEST functionality"
+	depends on VIDEO_MIPI_INTERFACE && VIDEO_V4L2
+	---help---
+	  This is for MIPI INTERFACE functiionality
+
+config VIDEO_OV8810
+	tristate "OV8810 raw sensor driver (8MP)"
+	depends on I2C && VIDEO_V4L2
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the Omni-Vision
+	  OV8810 camera.  It is currently working with the TI OMAP3
+	  camera controller.
+
 config VIDEO_OMAP3_HPLENS
 	tristate "HP generic lens driver"
 	depends on I2C && VIDEO_V4L2
@@ -990,3 +1010,13 @@ config USB_S2255
 endif # V4L_USB_DRIVERS
 
 endif # VIDEO_CAPTURE_DRIVERS
+
+#
+# NXP HDMI TDA19989 configuration
+#
+config HDMI_TDA19989
+	tristate "NXP HDMI 1.3 Transmitter driver"
+	depends on I2C
+	help
+	  to support HDMI1.3 transmitter
+	  with 3*8bit video inputs and CEC.
diff --git a/drivers/media/video/Makefile b/drivers/media/video/Makefile
index 283a852..a987332 100644
--- a/drivers/media/video/Makefile
+++ b/drivers/media/video/Makefile
@@ -112,6 +112,8 @@ obj-$(CONFIG_VIDEO_OMAP3) += omap34xxcam.o
 
 obj-$(CONFIG_VIDEO_TCM825X) += tcm825x.o
 obj-$(CONFIG_VIDEO_MT9P012)     += mt9p012.o
+obj-$(CONFIG_VIDEO_OV8810)     += ov8810.o
+obj-$(CONFIG_VIDEO_MIPI_DLI_TEST) += mipi_dli.o
 obj-$(CONFIG_VIDEO_OMAP3_HP3A) += hp3a/
 obj-$(CONFIG_VIDEO_OMAP3_HPLENS) += hplens.o
 
@@ -162,6 +164,7 @@ obj-$(CONFIG_VIDEO_AU0828) += au0828/
 
 obj-$(CONFIG_USB_VIDEO_CLASS)	+= uvc/
 
+obj-$(CONFIG_HDMI_TDA19989) += tda19989.o
 EXTRA_CFLAGS += -Idrivers/media/dvb/dvb-core
 EXTRA_CFLAGS += -Idrivers/media/dvb/frontends
 EXTRA_CFLAGS += -Idrivers/media/common/tuners
diff --git a/drivers/media/video/hp3a/hp3a.h b/drivers/media/video/hp3a/hp3a.h
index eb3b9c8..760d224 100644
--- a/drivers/media/video/hp3a/hp3a.h
+++ b/drivers/media/video/hp3a/hp3a.h
@@ -31,6 +31,7 @@ void hp3a_frame_done(void);
 void hp3a_stream_on(void);
 void hp3a_stream_off(void);
 void hp3a_ccdc_start(void);
+void hp3a_update_wb(void);
 int hp3a_hist_busy(void);
 int hp3a_af_busy(void);
 void hp3a_set_sensor_sync(unsigned char exposure, unsigned char gain);
diff --git a/drivers/media/video/hp3a/hp3a_af.c b/drivers/media/video/hp3a/hp3a_af.c
index bb08632..d90a9dc 100644
--- a/drivers/media/video/hp3a/hp3a_af.c
+++ b/drivers/media/video/hp3a/hp3a_af.c
@@ -123,9 +123,8 @@ void hp3a_disable_af(void)
 static void hp3a_af_isr(unsigned long status, isp_vbq_callback_ptr arg1,
 			void *arg2)
 {
-	if (unlikely((H3A_AF_DONE & status) != H3A_AF_DONE)) {
+	if (unlikely((H3A_AF_DONE & status) != H3A_AF_DONE))
 		return;
-	}
 
 	/* clear IRQ status bit.*/
 	/*
@@ -158,9 +157,8 @@ int hp3a_config_af(struct hp3a_af_config *config, struct hp3a_fh *fh)
 		/* Install AF callback. */
 		ret = isp_set_callback(CBK_H3A_AF_DONE, hp3a_af_isr,
 					(void *)NULL, (void *)NULL);
-		if (ret) {
+		if (ret)
 			return ret;
-		}
 
 		if (hp3a_af_busy()) {
 			dev_info(device->dev, "Error: AF engine is busy!\n");
@@ -206,7 +204,8 @@ int hp3a_config_af(struct hp3a_af_config *config, struct hp3a_fh *fh)
 
 		/* Validate paxel dimessions. */
 		if (config->paxel.width < 16 || config->paxel.width > 256 ||
-			config->paxel.height < 2 ||  config->paxel.height > 256) {
+			config->paxel.height < 2 ||
+			config->paxel.height > 256) {
 			dev_info(device->dev,
 				"Error: Invalid paxel dimention %d-%d\n",
 				config->paxel.width, config->paxel.height);
@@ -222,12 +221,13 @@ int hp3a_config_af(struct hp3a_af_config *config, struct hp3a_fh *fh)
 		/* IIR filter hz start setup. */
 		WRITE_REG(isp_af_regs[4].val, config->iir.hz_start_pos);
 
-		/* Setup paxel start position after IIR filter hz start setup. */
+		/* Setup paxel start position after */
+		/* IIR filter hz start setup. */
 		if (config->paxel.hz_start < (config->iir.hz_start_pos + 1) ||
 			config->paxel.hz_start > 4095 ||
 			config->paxel.vt_start > 4095) {
 			dev_info(device->dev,
-				"Error : Invalid paxel start position. (hz=%d vt=%d)\n",
+				"Error : Invalid paxel start. (hz=%d vt=%d)\n",
 				config->paxel.hz_start, config->paxel.vt_start);
 			goto func_exit;
 		}
@@ -250,7 +250,8 @@ int hp3a_config_af(struct hp3a_af_config *config, struct hp3a_fh *fh)
 			goto func_exit;
 		}
 
-		if (config->paxel.line_incr > 8 || config->paxel.line_incr < 2) {
+		if (config->paxel.line_incr > 8 ||
+			config->paxel.line_incr < 2) {
 			dev_info(device->dev,
 				"Error: Invalid paxel line increment %d\n",
 				config->paxel.line_incr);
@@ -262,18 +263,23 @@ int hp3a_config_af(struct hp3a_af_config *config, struct hp3a_fh *fh)
 		OR_REG(isp_af_regs[2].val,
 			(config->paxel.vt_cnt - 1) << AF_VT_COUNT_SHIFT);
 		OR_REG(isp_af_regs[2].val,
-			((config->paxel.line_incr >> 1) - 1) << AF_LINE_INCR_SHIFT);
+			((config->paxel.line_incr >> 1) - 1) <<
+			AF_LINE_INCR_SHIFT);
 
 		/* Validate IIR filter coefficients. */
 		for (index = 0; index < AF_NUMBER_OF_COEF; ++index) {
 			if ((config->iir.coeff_set0[index]) > AF_COEF_MAX) {
 				dev_info(device->dev,
-					"Error : Coefficient(%d) for set 0 is incorrect\n", index);
+					"Err : Coefficient %d for set 0 "
+					" is incorrect\n",
+					index);
 				goto func_exit;
 			}
 			if ((config->iir.coeff_set1[index]) > AF_COEF_MAX) {
 				dev_info(device->dev,
-					"Error : Coefficient for(%d) set 1 is incorrect\n", index);
+					"Err : Coefficient %d for set 1 "
+					"wrong\n",
+					index);
 				goto func_exit;
 			}
 		}
diff --git a/drivers/media/video/hp3a/hp3a_common.h b/drivers/media/video/hp3a/hp3a_common.h
index 700733f..54141b5 100644
--- a/drivers/media/video/hp3a/hp3a_common.h
+++ b/drivers/media/video/hp3a/hp3a_common.h
@@ -43,7 +43,7 @@
 #define  AND_REG(x, v)		(x &= (u32)v)
 
 /* hp3a specific default values. */
-#define  MIN_RAW_CAPTURE_INTERVAL	2
+#define  MIN_RAW_CAPTURE_INTERVAL	1
 #define  MAX_STAT_BUFFERS_PER_FRAME	3
 
 enum {
@@ -127,6 +127,7 @@ struct hp3a_3x3with_offset {
 struct hp3a_sensor_param {
 	u32 exposure;
 	u16 gain;
+	u16 fps;
 };
 
 /**
@@ -140,6 +141,7 @@ struct hp3a_sensor_param_internal {
 	u32 frame_id;
 	u32 exposure;
 	u16 gain;
+	u16 fps;
 };
 
 /**
@@ -167,9 +169,9 @@ struct hp3a_histogram_config {
    u32 enable;
 	u8 hist_source;		/* CCDC or Memory */
 	u8 input_bit_width;	/* Needed o know the size per pixel */
-	u8 hist_frames;		/* Numbers of frames to be processed and accumulated */
-	u8 hist_h_v_info;	/* frame-input width and height if source is memory */
-	u8 hist_packed_pxl;	/* If data is packed packed 8-bit into 16 bits */
+	u8 hist_frames;	/* Num frames to be processed, accumulated */
+	u8 hist_h_v_info;	/* input width and height if source is memory */
+	u8 hist_packed_pxl;	/* If data is packed packed 8 into 16 bits */
 	u16 hist_radd;		/* frame-input address in memory */
 	u16 hist_radd_off;	/* line-offset for frame-input */
 	u16 hist_bins;		/* number of bins: 32, 64, 128, or 256 */
@@ -245,6 +247,7 @@ struct hp3a_statistics {
  **/
 struct hp3a_context {
 	int initialized;
+	int default_v4l2_dev;
 	int v4l2_streaming;
 	int update_hardpipe;
 	int hist_done;
@@ -259,10 +262,9 @@ struct hp3a_context {
 	u8 exposure_sync;
 	u8 gain_sync;
 	u32 hist_bin_size;
-	u32 current_exposure;
-	u32 current_gain;
-	u32 exposure;
-	u16 gain;
+	struct hp3a_sensor_param sensor_current;
+	struct hp3a_sensor_param sensor_requested;
+	struct hp3a_sensor_param sensor_stats;
 	u32 frame_count;
 	u32 req_af_buffer_size;
 	u32 req_raw_buffer_size;
diff --git a/drivers/media/video/hp3a/hp3a_ext.c b/drivers/media/video/hp3a/hp3a_ext.c
index b0f82c2..49faf20 100644
--- a/drivers/media/video/hp3a/hp3a_ext.c
+++ b/drivers/media/video/hp3a/hp3a_ext.c
@@ -33,7 +33,6 @@
  **/
 void hp3a_ccdc_done(void)
 {
-	++g_tc.frame_count;
 	hp3a_update_stats_readout_done();
 }
 EXPORT_SYMBOL(hp3a_ccdc_done);
@@ -45,6 +44,7 @@ EXPORT_SYMBOL(hp3a_ccdc_done);
  **/
 void hp3a_ccdc_start(void)
 {
+	++g_tc.frame_count;
 	hp3a_schedule_task();
 }
 EXPORT_SYMBOL(hp3a_ccdc_start);
@@ -57,11 +57,21 @@ EXPORT_SYMBOL(hp3a_ccdc_start);
 void hp3a_frame_done(void)
 {
 	hp3a_update_stats_pipe_done();
-	hp3a_update_hardpipe();
 }
 EXPORT_SYMBOL(hp3a_frame_done);
 
 /**
+ * hp3a_update_wb - Update WB related hw settings.
+ *
+ * No return value.
+ **/
+void hp3a_update_wb(void)
+{
+	hp3a_update_hardpipe();
+}
+EXPORT_SYMBOL(hp3a_update_wb);
+
+/**
  * hp3a_stream_on - Perform stream on specific tasks.
  *
  * No return value.
@@ -69,6 +79,11 @@ EXPORT_SYMBOL(hp3a_frame_done);
 void hp3a_stream_on(void)
 {
 	g_tc.frame_count = 0;
+
+	memset(&g_tc.sensor_current, 0, sizeof(struct hp3a_sensor_param));
+	memset(&g_tc.sensor_requested, 0, sizeof(struct hp3a_sensor_param));
+	memset(&g_tc.sensor_stats, 0, sizeof(struct hp3a_sensor_param));
+
 	g_tc.v4l2_streaming = 1;
 	g_tc.raw_cap_sched_count = 0;
 
diff --git a/drivers/media/video/hp3a/hp3a_hardpipe.c b/drivers/media/video/hp3a/hp3a_hardpipe.c
index eb5efcd..f83ace3 100644
--- a/drivers/media/video/hp3a/hp3a_hardpipe.c
+++ b/drivers/media/video/hp3a/hp3a_hardpipe.c
@@ -28,8 +28,8 @@
  **/
 void hp3a_update_hardpipe(void)
 {
-	if (!(omap_readl(ISPPRV_PCR) & ISPPRV_PCR_BUSY) &&
-		g_tc.update_hardpipe == 1) {
+	if (g_tc.update_hardpipe == 1 &&
+		!(omap_readl(ISPPRV_PCR) & ISPPRV_PCR_BUSY)) {
 		omap_writel(g_tc.hpipe_param.dgain, ISPPRV_WB_DGAIN);
 
 		omap_writel(g_tc.hpipe_param.r_gain |
diff --git a/drivers/media/video/hp3a/hp3a_histogram.c b/drivers/media/video/hp3a/hp3a_histogram.c
index 755834e..25919ea 100644
--- a/drivers/media/video/hp3a/hp3a_histogram.c
+++ b/drivers/media/video/hp3a/hp3a_histogram.c
@@ -106,19 +106,18 @@ static void hp3a_histogram_isr(unsigned long status, isp_vbq_callback_ptr arg1,
 	u32 i;
 	struct hp3a_internal_buffer *ibuffer = NULL;
 
-	if (unlikely((HIST_DONE & status) != HIST_DONE)) {
+	if (unlikely((HIST_DONE & status) != HIST_DONE))
 		return;
-	}
 
 	omap_writel(omap_readl(ISPHIST_PCR) & ~(ISPHIST_PCR_EN), ISPHIST_PCR);
 
-	if (unlikely(g_tc.v4l2_streaming == 0)) {
+	if (unlikely(g_tc.v4l2_streaming == 0))
 		return;
-	}
 
 	if (hp3a_dequeue(&g_tc.hist_hw_queue,  &ibuffer) == 0) {
 		/* If there is a buffer available then fill it. */
-		hist_buffer = (u32 *)phys_to_virt(page_to_phys(ibuffer->pages[0]));
+		hist_buffer = (u32 *)phys_to_virt(
+			page_to_phys(ibuffer->pages[0]));
 
 		omap_writel((omap_readl(ISPHIST_CNT)) | \
 			ISPHIST_CNT_CLR_EN, ISPHIST_CNT);
@@ -129,10 +128,10 @@ static void hp3a_histogram_isr(unsigned long status, isp_vbq_callback_ptr arg1,
 		omap_writel((omap_readl(ISPHIST_CNT)) & ~ISPHIST_CNT_CLR_EN,
 			ISPHIST_CNT);
 	} else {
-		/* There are no buffers availavle so just clear internal histogram memory. */
-		for (i = g_tc.hist_bin_size; i--;) {
+		/* There are no buffers availavle so just */
+		/* clear internal histogram memory. */
+		for (i = g_tc.hist_bin_size; i--;)
 			omap_writel(0, ISPHIST_DATA);
-		}
 	}
 
 	/* Set memory HW memory address and enable. */
@@ -169,12 +168,12 @@ int hp3a_config_histogram(struct hp3a_histogram_config *config,
 		/* Install HIST_IRQ callback. */
 		ret = isp_set_callback(CBK_HIST_DONE, hp3a_histogram_isr,
 					(void *)NULL, (void *)NULL);
-		if (ret) {
+		if (ret)
 			return ret;
-		}
 
 		if (hp3a_hist_busy()) {
-			dev_info(device->dev, "Error: Histogram engine is busy!\n");
+			dev_info(device->dev, \
+				"Error: Histogram engine is busy\n");
 			return -EINVAL;
 		}
 
@@ -190,27 +189,35 @@ int hp3a_config_histogram(struct hp3a_histogram_config *config,
 
 		if (config->hist_source) {
 			/* source is memory. */
-			WRITE_HV_INFO(isp_hist_regs[14].val, config->hist_h_v_info);
+			WRITE_HV_INFO(isp_hist_regs[14].val,
+				config->hist_h_v_info);
 
-			if ((config->hist_radd & ISP_32B_BOUNDARY_BUF) == config->hist_radd) {
-				WRITE_RADD(isp_hist_regs[12].val, config->hist_radd);
+			if ((config->hist_radd & ISP_32B_BOUNDARY_BUF) ==
+				config->hist_radd) {
+				WRITE_RADD(isp_hist_regs[12].val,
+					config->hist_radd);
 			} else {
-				dev_info(device->dev, "Error: Address should be in 32 byte boundary\n");
+				dev_info(device->dev,
+					"Err: Addr needs 32 byte boundary\n");
 				goto func_exit;
 			}
 
-			if ((config->hist_radd_off & ISP_32B_BOUNDARY_OFFSET) == config->hist_radd_off) {
-				WRITE_RADD_OFF(isp_hist_regs[13].val, config->hist_radd_off);
+			if ((config->hist_radd_off &
+				ISP_32B_BOUNDARY_OFFSET) ==
+				config->hist_radd_off) {
+				WRITE_RADD_OFF(isp_hist_regs[13].val, \
+					config->hist_radd_off);
 			} else {
-				dev_info(device->dev, "Error: Offset should be in 32 byte boundary\n");
+				dev_info(device->dev,
+					"Err: Offset needs 32 byte boundary\n");
 				goto func_exit;
 			}
 		}
 
-		/* set data size bit if the pixel data is 8-bit wide and 2 pixels are packed in to 16-bits. */
-		if (config->hist_packed_pxl) {
+		/* set data size bit if the pixel data is 8-bit wide and */
+		/* 2 pixels are packed in to 16-bits. */
+		if (config->hist_packed_pxl)
 			WRITE_DATA_SIZE(isp_hist_regs[1].val, 1);
-		}
 
 		/* White Balance Field-to-Pattern Assignments */
 		if (unlikely((config->wb_gain_R > MAX_WB_GAIN)
@@ -227,9 +234,8 @@ int hp3a_config_histogram(struct hp3a_histogram_config *config,
 		}
 
 		/* Regions size and position */
-		if (config->num_regions > MAX_REGIONS) {
+		if (config->num_regions > MAX_REGIONS)
 			goto func_exit;
-		}
 
 		/* Region 0. */
 		WRITE_REG_HORIZ(isp_hist_regs[3].val, config->reg0_hor);
@@ -251,8 +257,10 @@ int hp3a_config_histogram(struct hp3a_histogram_config *config,
 		/* Number of Bins. */
 		if (unlikely(((config->hist_bins > BINS_256) &&
 			(config->hist_bins != BINS_32)) ||
-			((config->hist_bins == BINS_256) && config->num_regions != 0) ||
-			((config->hist_bins == BINS_128) && config->num_regions >= 2))) {
+			((config->hist_bins == BINS_256) &&
+			config->num_regions != 0) ||
+			((config->hist_bins == BINS_128) &&
+			config->num_regions >= 2))) {
 			dev_info(device->dev,
 				"Error: Invalid Bins Number: %d\n",
 				config->hist_bins);
@@ -273,13 +281,16 @@ int hp3a_config_histogram(struct hp3a_histogram_config *config,
 				g_tc.hist_bin_size = HIST_MEM_SIZE;
 			} else if (config->hist_bins == BINS_128) {
 				bit_shift = config->input_bit_width - 7;
-				g_tc.hist_bin_size = (HIST_MEM_SIZE>>(1-config->num_regions));
+				g_tc.hist_bin_size = (HIST_MEM_SIZE>>
+					(1-config->num_regions));
 			} else if (config->hist_bins == BINS_64) {
 				bit_shift = config->input_bit_width - 6;
-				g_tc.hist_bin_size = (HIST_MEM_SIZE>>(2-config->num_regions));
+				g_tc.hist_bin_size = (HIST_MEM_SIZE>>
+					(2-config->num_regions));
 			} else if (config->hist_bins == BINS_32) {
 				bit_shift = config->input_bit_width - 5;
-				g_tc.hist_bin_size = (HIST_MEM_SIZE>>(3-config->num_regions));
+				g_tc.hist_bin_size = (HIST_MEM_SIZE>>
+					(3-config->num_regions));
 			} else {
 				goto func_exit;
 			}
diff --git a/drivers/media/video/hp3a/hp3a_ioctl.c b/drivers/media/video/hp3a/hp3a_ioctl.c
index ffc3ad3..32be4f0 100644
--- a/drivers/media/video/hp3a/hp3a_ioctl.c
+++ b/drivers/media/video/hp3a/hp3a_ioctl.c
@@ -60,9 +60,9 @@ long hp3a_unlocked_ioctl(struct file *file, unsigned int cmd,
 		ret = hp3a_collect_statistics(&statistics);
 		if (SUCCEEDED(ret)) {
 			if (copy_to_user((struct hp3a_statistics *)arg,
-				&statistics, sizeof(struct hp3a_statistics)) != 0) {
+				&statistics,
+				sizeof(struct hp3a_statistics)) != 0)
 				ret = -EFAULT;
-			}
 		}
 		break;
 	}
@@ -107,7 +107,8 @@ long hp3a_unlocked_ioctl(struct file *file, unsigned int cmd,
 
 		if (index < fh->buffer_count && index > -1) {
 			ibuffer = &(fh->buffers[index]);
-			ret = hp3a_enqueue_irqsave(&g_tc.hist_stat_queue, &ibuffer);
+			ret = hp3a_enqueue_irqsave(&g_tc.hist_stat_queue,
+				&ibuffer);
 		}
 
 		break;
@@ -122,16 +123,19 @@ long hp3a_unlocked_ioctl(struct file *file, unsigned int cmd,
 		if (index < fh->buffer_count && index > -1) {
 			ibuffer = &(fh->buffers[index]);
 			if (ibuffer->isp_addr == 0) {
-				ibuffer->isp_addr = ispmmu_map_pages(ibuffer->pages,
+				ibuffer->isp_addr =
+					ispmmu_map_pages(ibuffer->pages,
 					NR_PAGES((unsigned long)ibuffer->user_addr,
 					ibuffer->buffer_size));
 				if (ibuffer->isp_addr == 0) {
-					dev_err(device->dev , "isp mmu failed to map memory!\n");
+					dev_err(device->dev , \
+						"isp mmu fail to map memory\n");
 					return -EFAULT;
 				}
 			}
 			flush_dcache_ibuffer(ibuffer);
-			ret = hp3a_enqueue_irqsave(&g_tc.af_stat_queue, &ibuffer);
+			ret = hp3a_enqueue_irqsave(&g_tc.af_stat_queue,
+				&ibuffer);
 		}
 
 		break;
@@ -146,15 +150,18 @@ long hp3a_unlocked_ioctl(struct file *file, unsigned int cmd,
 		if (index < fh->buffer_count && index > -1) {
 			ibuffer = &(fh->buffers[index]);
 			if (ibuffer->isp_addr == 0) {
-				ibuffer->isp_addr = ispmmu_map_pages(ibuffer->pages,
+				ibuffer->isp_addr =
+					ispmmu_map_pages(ibuffer->pages,
 					NR_PAGES((unsigned long)ibuffer->user_addr,
 					ibuffer->buffer_size));
 				if (ibuffer->isp_addr == 0) {
-					dev_err(device->dev , "isp mmu failed to map memory!\n");
+					dev_err(device->dev , \
+						"isp mmu fail to map memory\n");
 					return -EFAULT;
 				}
 			}
-			ret = hp3a_enqueue_irqsave(&g_tc.raw_frame_queue, &ibuffer);
+			ret = hp3a_enqueue_irqsave(&g_tc.raw_frame_queue,
+				&ibuffer);
 		}
 
 		break;
@@ -172,13 +179,12 @@ long hp3a_unlocked_ioctl(struct file *file, unsigned int cmd,
 			ret = -1;
 			if (req_buf.count > 0) {
 				fh->buffers = kzalloc(req_buf.count * \
-						sizeof(struct hp3a_internal_buffer),
-						GFP_KERNEL);
+					sizeof(struct hp3a_internal_buffer),
+					GFP_KERNEL);
 				if (fh->buffers) {
 					fh->buffer_count = req_buf.count;
-					for (i = 0; i < fh->buffer_count; ++i) {
+					for (i = 0; i < fh->buffer_count; ++i)
 						fh->buffers[i].index = i;
-					}
 					ret = 0;
 				}
 			}
@@ -198,10 +204,12 @@ long hp3a_unlocked_ioctl(struct file *file, unsigned int cmd,
 				(struct hp3a_buffer *)arg,
 				sizeof(struct hp3a_buffer)) == 0) {
 			ret = -1;
-			if (buffer.index >= 0 && buffer.index < fh->buffer_count) {
-				if (fh->buffers[buffer.index].buffer_size == 0) {
+			if (buffer.index >= 0 && buffer.index <
+				fh->buffer_count) {
+				if (fh->buffers[buffer.index].buffer_size
+					==	0) {
 					ret = map_user_to_kernel(&buffer,
-							&(fh->buffers[buffer.index]));
+						&(fh->buffers[buffer.index]));
 				}
 			}
 		} else {
@@ -220,10 +228,12 @@ long hp3a_unlocked_ioctl(struct file *file, unsigned int cmd,
 				(struct hp3a_buffer *)arg,
 				sizeof(struct hp3a_buffer)) == 0) {
 			ret = -1;
-			if (buffer.index >= 0 && buffer.index < fh->buffer_count) {
+			if (buffer.index >= 0 && buffer.index <
+				fh->buffer_count) {
 				if (fh->buffers[buffer.index].buffer_size &&
-						fh->buffers[buffer.index].pages) {
-					unmap_buffer_from_kernel(&(fh->buffers[buffer.index]));
+					fh->buffers[buffer.index].pages) {
+					unmap_buffer_from_kernel(
+						&(fh->buffers[buffer.index]));
 					ret = 0;
 				}
 			}
@@ -278,10 +288,9 @@ long hp3a_unlocked_ioctl(struct file *file, unsigned int cmd,
 			ret = hp3a_configure_raw(&config);
 			if (SUCCEEDED(ret)) {
 				if (copy_to_user((struct hp3a_raw_config *)arg,
-						&config,
-						sizeof(struct hp3a_raw_config)) != 0) {
+					&config,
+					sizeof(struct hp3a_raw_config)) != 0)
 					ret = -EFAULT;
-				}
 			}
 		} else {
 			ret = -EFAULT;
@@ -318,6 +327,7 @@ long hp3a_unlocked_ioctl(struct file *file, unsigned int cmd,
 	 */
 	case HP3A_S_V4L2_DEV_INDEX: {
 		fh->v4l2_dev = (int)arg;
+		g_tc.default_v4l2_dev = fh->v4l2_dev;
 		ret = 0;
 		break;
 	}
diff --git a/drivers/media/video/hp3a/hp3a_queue.c b/drivers/media/video/hp3a/hp3a_queue.c
index 9d7e553..0f374a0 100644
--- a/drivers/media/video/hp3a/hp3a_queue.c
+++ b/drivers/media/video/hp3a/hp3a_queue.c
@@ -29,7 +29,8 @@
  *
  * No return value.
  **/
-int hp3a_initialize_queue(struct hp3a_queue *queue, int queue_size, unsigned int element_size)
+int hp3a_initialize_queue(struct hp3a_queue *queue,
+		int queue_size, unsigned int element_size)
 {
 	if (queue_size > 0 && element_size > 0) {
 		queue->data = kmalloc(queue_size * element_size,  GFP_KERNEL);
@@ -161,7 +162,6 @@ int hp3a_dequeue(struct hp3a_queue *queue, void *element)
 
 		/* copy data from queue to element. */
 		memcpy(element, item, queue->element_size);
-
 		ret = 0;
 	}
 
@@ -195,7 +195,6 @@ int hp3a_dequeue_irqsave(struct hp3a_queue *queue, void *element)
 
 		/* copy data from queue to element. */
 		memcpy(element, item, queue->element_size);
-
 		ret = 0;
 	}
 
diff --git a/drivers/media/video/hp3a/hp3a_raw.c b/drivers/media/video/hp3a/hp3a_raw.c
index dc92e2e..2e81c0a 100644
--- a/drivers/media/video/hp3a/hp3a_raw.c
+++ b/drivers/media/video/hp3a/hp3a_raw.c
@@ -24,11 +24,7 @@
 
 static struct hp3a_reg isp_raw_regs[] = {
 	{HP3A_REG_32BIT, ISPCCDC_SYN_MODE, 0},
-	{HP3A_REG_32BIT, ISPCCDC_HORZ_INFO, 0},
-	{HP3A_REG_32BIT, ISPCCDC_VERT_START, 0},
-	{HP3A_REG_32BIT, ISPCCDC_VERT_LINES, 0},
 	{HP3A_REG_32BIT, ISPCCDC_HSIZE_OFF, 0},
-	{HP3A_REG_32BIT, ISPCCDC_SDOFST, 0},
 	{HP3A_REG_32BIT, ISPCCDC_SDR_ADDR, 0},
 	{HP3A_REG_32BIT, ISPCCDC_CFG, 0},
 	{HP3A_REG_TOK_TERM, 0, 0}
@@ -42,7 +38,7 @@ static struct hp3a_reg isp_raw_regs[] = {
 void hp3a_enable_raw(unsigned long buffer_addr)
 {
 	if (likely(buffer_addr != 0)) {
-		if (likely(g_tc.isp_ctx_saved == 0)) {
+		if (g_tc.isp_ctx_saved == 0) {
 			/* Save ISP registers. */
 			hp3a_read_ispregs(isp_raw_regs);
 			g_tc.isp_ctx_saved = 1;
@@ -60,19 +56,22 @@ void hp3a_enable_raw(unsigned long buffer_addr)
 		omap_writel(buffer_addr, ISPCCDC_SDR_ADDR);
 
 		/* Set register for line memory offset*/
-		omap_writel(ALIGN_TO((g_tc.raw_width << 1), 32), ISPCCDC_HSIZE_OFF);
+		omap_writel(ALIGN_TO((g_tc.raw_width << 1), 32),
+					ISPCCDC_HSIZE_OFF);
 
-		/*0 - By default Donot inverse the field identification */
-		omap_writel((omap_readl(ISPCCDC_SDOFST) & (~ISPCCDC_SDOFST_FINV)),
-								ISPCCDC_SDOFST);
-
-		/*0 - By default one line offset*/
-		omap_writel(omap_readl(ISPCCDC_SDOFST) & ISPCCDC_SDOFST_FOFST_1L,
-				ISPCCDC_SDOFST);
+		/*
+			The following registers must be set during CCDC config.
+			CCDC_HORZ_INFO
+			CCDC_VERT_START
+			CCDC_VERT_LINES
+			CCDC_SDOFST
+		*/
 
 		/* ISPCCDC_SYN_MODE must be set last. */
-		omap_writel((omap_readl(ISPCCDC_SYN_MODE) | ISPCCDC_SYN_MODE_WEN |
-				ISPCCDC_SYN_MODE_EXWEN | ISPCCDC_SYN_MODE_VP2SDR),
+		omap_writel((omap_readl(ISPCCDC_SYN_MODE) |
+				ISPCCDC_SYN_MODE_WEN |
+				ISPCCDC_SYN_MODE_EXWEN |
+				ISPCCDC_SYN_MODE_VP2SDR),
 				ISPCCDC_SYN_MODE);
 	}
 }
@@ -84,7 +83,7 @@ void hp3a_enable_raw(unsigned long buffer_addr)
  **/
 void hp3a_disable_raw(void)
 {
-	if (likely(g_tc.isp_ctx_saved == 1)) {
+	if (g_tc.isp_ctx_saved == 1) {
 		/* Restore ISP registers. */
 		hp3a_write_ispregs(isp_raw_regs);
 		g_tc.isp_ctx_saved = 0;
@@ -123,7 +122,8 @@ int hp3a_configure_raw(struct hp3a_raw_config *raw)
 		if (likely(g_tc.raw_width != 0 && g_tc.raw_height != 0)) {
 			g_tc.raw_hw_configured = 1;
 			g_tc.req_raw_buffer_size = (u32)ALIGN_TO(((ALIGN_TO( \
-				g_tc.raw_width, 16)*g_tc.raw_height)<<1), 0x1000);
+				g_tc.raw_width, 16)*g_tc.raw_height)<<1), \
+				0x1000);
 		} else {
 			g_tc.raw_hw_configured = 0;
 			g_tc.req_raw_buffer_size = -1;
diff --git a/drivers/media/video/hp3a/hp3a_stats.c b/drivers/media/video/hp3a/hp3a_stats.c
index f74b237..094b7ed 100644
--- a/drivers/media/video/hp3a/hp3a_stats.c
+++ b/drivers/media/video/hp3a/hp3a_stats.c
@@ -24,6 +24,7 @@
 
 #include "hp3a_common.h"
 #include "hp3a_queue.h"
+#include "hp3a_ispreg.h"
 #include "../oldomap34xxcam.h"
 #include "ispccdc.h"
 
@@ -62,10 +63,11 @@ void initialize_hp3a_framework(struct hp3a_dev *device)
 		g_tc.raw_width = 0;
 		g_tc.raw_height = 0;
 		g_tc.histogram_buffer = NULL;
-		g_tc.af_buffer  = NULL;
-		g_tc.raw_buffer  = NULL;
+		g_tc.af_buffer = NULL;
+		g_tc.raw_buffer = NULL;
 		g_tc.exposure_sync = 2;
 		g_tc.gain_sync = 1;
+		g_tc.default_v4l2_dev = 0;
 
 		/* Initialize task queues. */
 		hp3a_initialize_queue(&g_tc.hist_stat_queue, 8,
@@ -117,15 +119,14 @@ void hp3a_framework_start(struct hp3a_fh *fh)
 	fh->buffer_count = 0;
 	fh->buffers = NULL;
 	g_tc.frame_done.done = 0;
-	g_tc.current_exposure = 0;
-	g_tc.current_gain = 0;
-	g_tc.exposure = 0;
-	g_tc.gain = 0;
 	g_tc.hist_done = 0;
 	g_tc.hist_hw_enable = 0;
 	g_tc.af_hw_enable = 0;
-	g_tc.raw_hw_configured = 0;
 	g_tc.isp_ctx_saved = 0;
+
+	memset(&g_tc.sensor_current, 0, sizeof(struct hp3a_sensor_param));
+	memset(&g_tc.sensor_requested, 0, sizeof(struct hp3a_sensor_param));
+	memset(&g_tc.sensor_stats, 0, sizeof(struct hp3a_sensor_param));
 }
 
 /**
@@ -140,22 +141,17 @@ void hp3a_framework_stop(struct hp3a_fh *fh)
 
 	spin_lock_irqsave(&g_tc.stats_lock, irqflags);
 
-	/* Reset flags. */
-	g_tc.v4l2_streaming = 0;
-
 	/* Need to flush queue. */
 	hp3a_flush_queue(&g_tc.sensor_write_queue);
 	hp3a_flush_queue(&g_tc.sensor_read_queue);
 	hp3a_flush_queue(&g_tc.raw_frame_queue);
 	hp3a_flush_queue(&g_tc.af_stat_queue);
 	hp3a_flush_queue(&g_tc.hist_stat_queue);
-	hp3a_flush_queue(&g_tc.hist_hw_queue);
-	hp3a_flush_queue(&g_tc.ready_stats_queue);
 
 	/* Internal buffer clean up. */
-	for (i = 0; i < fh->buffer_count; ++i) {
+	for (i = 0; i < fh->buffer_count; ++i)
 		unmap_buffer_from_kernel(&(fh->buffers[i]));
-	}
+
 	kfree(fh->buffers);
 	fh->buffers = NULL;
 
@@ -186,40 +182,63 @@ void hp3a_framework_stop(struct hp3a_fh *fh)
 int hp3a_set_sensor_param(struct hp3a_sensor_param *param, struct hp3a_fh *fh)
 {
 	int ret = -1;
-	struct hp3a_sensor_param_internal sensor_param;
+	struct hp3a_sensor_param_internal sensor_param = {
+		.exposure = 0,
+		.gain = 0,
+		.fps = 0};
 
 	if (likely(fh->v4l2_dev > -1)) {
 		if (likely(g_tc.v4l2_streaming == 1)) {
 			sensor_param.v4l2_dev = fh->v4l2_dev;
 			ret = 0;
 
-			if (g_tc.current_exposure != param->exposure) {
+			/* queue fps & exposure together */
+			if (param->fps && g_tc.sensor_requested.fps != \
+					param->fps) {
+				g_tc.sensor_requested.fps = param->fps;
+				sensor_param.fps = param->fps;
+			}
+
+			if (param->exposure &&
+					abs(g_tc.sensor_requested.exposure - \
+					param->exposure) > 2) {
+				g_tc.sensor_requested.exposure = \
+					param->exposure;
 				sensor_param.exposure = param->exposure;
-				sensor_param.gain = 0;
+			}
 
-				ret = hp3a_enqueue(&g_tc.sensor_write_queue,
-							&sensor_param);
+			if (sensor_param.fps || sensor_param.exposure) {
+				ret = hp3a_enqueue(
+				&g_tc.sensor_write_queue,
+				&sensor_param);
 			}
 
-			if (g_tc.current_gain != param->gain) {
-				sensor_param.exposure = 0;
+			if (param->gain &&
+				abs(g_tc.sensor_requested.gain - \
+					param->gain) > 2) {
+				g_tc.sensor_requested.gain = param->gain;
 				sensor_param.gain = param->gain;
-
-				ret = hp3a_enqueue(&g_tc.sensor_write_queue,
-						&sensor_param);
+				sensor_param.exposure = 0;
+				sensor_param.fps = 0;
+				ret = hp3a_enqueue(
+					&g_tc.sensor_write_queue,
+					&sensor_param);
 			}
 		} else {
 			struct cam_sensor_settings sensor_settings = {
 			.flags = 0,
 			.exposure = 0,
 			.gain = 0,
+			.fps = 0,
 			.regs = 0,
 			.reg_data = 0};
 
 			sensor_settings.exposure = param->exposure;
 			sensor_settings.gain = param->gain;
+			sensor_settings.fps = param->fps;
 			sensor_settings.flags = (OMAP34XXCAM_SET_GAIN | \
-						OMAP34XXCAM_SET_EXPOSURE);
+						OMAP34XXCAM_SET_EXPOSURE | \
+						OMAP34XXCAM_SET_FPS);
 
 			/**
 			* Write and read sensor settings.
@@ -228,7 +247,9 @@ int hp3a_set_sensor_param(struct hp3a_sensor_param *param, struct hp3a_fh *fh)
 							&sensor_settings);
 		}
 	} else {
-		dev_err(fh->device->dev, "hp3a: Invalid sensor id(%d)\n", fh->v4l2_dev);
+		dev_err(fh->device->dev,
+			"hp3a: Invalid sensor id(%d)\n",
+			fh->v4l2_dev);
 	}
 
 	return ret;
@@ -251,9 +272,8 @@ int hp3a_set_hardpipe_param(struct hp3a_hardpipe_param *param,
 	g_tc.update_hardpipe = 1;
 	spin_unlock_irqrestore(&g_tc.hardpipe_lock, irqflags);
 
-	if (g_tc.v4l2_streaming == 0) {
+	if (g_tc.v4l2_streaming == 0)
 		hp3a_update_hardpipe();
-	}
 
 	return 0;
 }
@@ -268,9 +288,8 @@ int hp3a_collect_statistics(struct hp3a_statistics *stat)
 {
 	unsigned long irqflags = 0;
 
-	if (unlikely(g_tc.v4l2_streaming == 0)) {
+	if (unlikely(g_tc.v4l2_streaming == 0))
 		return -1;
-	}
 
 	/* Initialize buffer indexes. */
 	stat->hist_stat_index = -1;
@@ -293,8 +312,8 @@ int hp3a_collect_statistics(struct hp3a_statistics *stat)
 
 		/* Frame meta data. */
 		stat->frame_id = g_tc.frame_count;
-		stat->exposure = g_tc.exposure;
-		stat->gain = g_tc.gain;
+		stat->exposure = g_tc.sensor_stats.exposure;
+		stat->gain = g_tc.sensor_stats.gain;
 
 		/* Raw bayer frame. */
 		if (g_tc.raw_buffer != NULL) {
@@ -313,15 +332,16 @@ int hp3a_collect_statistics(struct hp3a_statistics *stat)
 		/* Histogram. */
 		if (g_tc.histogram_buffer != NULL) {
 			if (g_tc.hist_done  == 1) {
-				stat->hist_stat_index = g_tc.histogram_buffer->index;
+				stat->hist_stat_index = \
+					g_tc.histogram_buffer->index;
 			} else {
-				hp3a_enqueue(&g_tc.hist_stat_queue, &g_tc.histogram_buffer);
+				hp3a_enqueue(&g_tc.hist_stat_queue,
+					&g_tc.histogram_buffer);
 			}
 			g_tc.histogram_buffer = NULL;
 		}
 
 		g_tc.hist_done = 0;
-
 		spin_unlock_irqrestore(&g_tc.stats_lock, irqflags);
 	}
 
@@ -336,10 +356,12 @@ int hp3a_collect_statistics(struct hp3a_statistics *stat)
 void hp3a_update_stats_readout_done(void)
 {
 	int i;
+	bool allow_exp_update = true;
+	bool allow_gain_update = true;
 	struct hp3a_internal_buffer *ibuffer;
 	struct hp3a_sensor_param_internal sensor_param;
 
-	if (unlikely(g_tc.v4l2_streaming == 0)) {
+	if (g_tc.v4l2_streaming == 0) {
 		hp3a_disable_histogram();
 		hp3a_disable_af();
 		return;
@@ -369,15 +391,18 @@ void hp3a_update_stats_readout_done(void)
 	for (i = MAX_STAT_BUFFERS_PER_FRAME; i--;) {
 		ibuffer = NULL;
 		if (hp3a_dequeue(&g_tc.ready_stats_queue, &ibuffer) == 0) {
-			if (ibuffer->type == HISTOGRAM && g_tc.histogram_buffer == NULL)
+			if (ibuffer->type == HISTOGRAM &&
+					g_tc.histogram_buffer == NULL)
 				g_tc.histogram_buffer = ibuffer;
-			else if (ibuffer->type == PAXEL && g_tc.af_buffer == NULL)
+			else if (ibuffer->type == PAXEL &&
+						g_tc.af_buffer == NULL)
 				g_tc.af_buffer = ibuffer;
-			else if (ibuffer->type == BAYER && g_tc.raw_buffer == NULL)
+			else if (ibuffer->type == BAYER &&
+						g_tc.raw_buffer == NULL)
 				g_tc.raw_buffer = ibuffer;
 			else {
-				printk(KERN_ERR "hp3a: Error unknown buffer type(%d) in"
-							" ready queue\n", ibuffer->type);
+				printk(KERN_ERR "hp3a: Error unknown "
+				"buffer type(%d)\n", ibuffer->type);
 			}
 		} else {
 			break;
@@ -387,12 +412,25 @@ void hp3a_update_stats_readout_done(void)
 	for (i = QUEUE_COUNT(g_tc.sensor_read_queue); i--;) {
 		if (hp3a_dequeue(&g_tc.sensor_read_queue, &sensor_param) == 0) {
 			if (sensor_param.frame_id == g_tc.frame_count) {
-				if (sensor_param.exposure)
-					g_tc.exposure = sensor_param.exposure;
-				if (sensor_param.gain)
-					g_tc.gain = sensor_param.gain;
+				if (sensor_param.exposure == -1) {
+					g_tc.sensor_stats.exposure = 0;
+					allow_exp_update = false;
+				} else if (sensor_param.exposure && \
+						allow_exp_update) {
+					g_tc.sensor_stats.exposure = \
+						sensor_param.exposure;
+				}
+				if (sensor_param.gain == -1) {
+					g_tc.sensor_stats.gain = 0;
+					allow_gain_update = false;
+				} else if (sensor_param.gain && \
+						allow_gain_update) {
+					g_tc.sensor_stats.gain = \
+						sensor_param.gain;
+				}
 			} else if (sensor_param.frame_id > g_tc.frame_count) {
-				hp3a_enqueue(&g_tc.sensor_read_queue, &sensor_param);
+				hp3a_enqueue(&g_tc.sensor_read_queue,
+								&sensor_param);
 			}
 		} else {
 			break;
@@ -417,25 +455,30 @@ void hp3a_update_stats_pipe_done(void)
 {
 	struct hp3a_internal_buffer *ibuffer;
 
-	if (unlikely(g_tc.v4l2_streaming == 0)) {
-		hp3a_disable_raw();
+	hp3a_disable_raw();
+
+	if (g_tc.v4l2_streaming == 0)
 		return;
-	}
 
 	/* RAW stat buffer processing. */
 	if (g_tc.raw_hw_configured == 1) {
 		if ((++g_tc.raw_cap_sched_count) == g_tc.raw_frequency) {
+			if (omap_readl(ISPCCDC_PCR) & ISPCCDC_PCR_BUSY) {
+				--g_tc.raw_cap_sched_count;
+				return;
+			}
 			g_tc.raw_cap_sched_count = 0;
 			ibuffer = NULL;
-			if (hp3a_dequeue(&g_tc.raw_frame_queue, &ibuffer) == 0) {
-				if (ibuffer->buffer_size >= g_tc.req_raw_buffer_size) {
+			if (hp3a_dequeue(&g_tc.raw_frame_queue, &ibuffer)
+				== 0) {
+				if (ibuffer->buffer_size >=
+					g_tc.req_raw_buffer_size) {
 					hp3a_enable_raw(ibuffer->isp_addr);
 					ibuffer->type = BAYER;
-					hp3a_enqueue(&g_tc.ready_stats_queue, &ibuffer);
+					hp3a_enqueue(&g_tc.ready_stats_queue,
+						&ibuffer);
 				}
 			}
-		} else if (g_tc.raw_cap_sched_count == 1) {
-			hp3a_disable_raw();
 		}
 	}
 }
@@ -463,49 +506,84 @@ static void hp3a_task(struct work_struct *work)
 {
 	/* Place holder for deferred tasks. */
 	struct hp3a_sensor_param_internal sensor_param;
+	struct hp3a_sensor_param_internal empty_param = {
+		.exposure = 0,
+		.gain = 0,
+		.fps = 0};
 	struct cam_sensor_settings sensor_settings = {
 		.flags = 0,
 		.exposure = 0,
 		.gain = 0,
 		.regs = 0,
+		.fps = 0,
 		.reg_data = 0};
-	u32 frame_index = (g_tc.frame_count+1);
+	u32 cur_frame = g_tc.frame_count;
 
 	/**
 	 * Setup exposure and gain for next frame.
 	 */
-	if (hp3a_dequeue(&g_tc.sensor_write_queue, &sensor_param) == 0) {
+	if (hp3a_dequeue(&g_tc.sensor_write_queue,
+							&sensor_param) == 0) {
 		sensor_settings.exposure = sensor_param.exposure;
 		sensor_settings.gain = sensor_param.gain;
+		sensor_settings.fps = sensor_param.fps;
+
+		if (sensor_param.fps)
+			sensor_settings.flags |= OMAP34XXCAM_SET_FPS;
 
 		if (sensor_param.exposure)
 			sensor_settings.flags |= OMAP34XXCAM_SET_EXPOSURE;
+
 		if (sensor_param.gain)
 			sensor_settings.flags |= OMAP34XXCAM_SET_GAIN;
 
 		/**
-		* Write and read sensor settings.
-		*/
-		omap34xxcam_sensor_settings(sensor_param.v4l2_dev, &sensor_settings);
-
-		if (g_tc.current_gain != sensor_settings.gain) {
-			sensor_param.frame_id = (frame_index + g_tc.gain_sync);
+		 * Write and read sensor settings.
+		 */
+		omap34xxcam_sensor_settings(sensor_param.v4l2_dev,
+			&sensor_settings);
+
+		if (g_tc.sensor_current.gain != sensor_settings.gain) {
+			if (g_tc.gain_sync > 1) {
+				empty_param.frame_id = cur_frame + 1;
+				empty_param.gain = -1;
+				hp3a_enqueue_irqsave(
+					&g_tc.sensor_read_queue,
+					&empty_param);
+			}
+			sensor_param.frame_id = \
+				(cur_frame + g_tc.gain_sync);
+			sensor_param.fps = sensor_settings.fps;
 			sensor_param.exposure = 0;
 			sensor_param.gain = sensor_settings.gain;
 			/* Queue new value for stats collecton. */
-			hp3a_enqueue_irqsave(&g_tc.sensor_read_queue, &sensor_param);
+			hp3a_enqueue_irqsave(&g_tc.sensor_read_queue,
+				&sensor_param);
 			/* Save new programmed in gain value. */
-			g_tc.current_gain = sensor_settings.gain;
+			g_tc.sensor_current.gain = sensor_settings.gain;
 		}
 
-		if (g_tc.current_exposure != sensor_settings.exposure) {
-			sensor_param.frame_id = (frame_index + g_tc.exposure_sync);
+		if (g_tc.sensor_current.exposure != sensor_settings.exposure) {
+			if (g_tc.exposure_sync > 1) {
+				empty_param.frame_id = cur_frame + 1;
+				empty_param.gain = 0;
+				empty_param.exposure = -1;
+				hp3a_enqueue_irqsave(
+					&g_tc.sensor_read_queue,
+					&empty_param);
+			}
+			sensor_param.frame_id = \
+				(cur_frame + g_tc.exposure_sync);
+			sensor_param.fps = sensor_settings.fps;
 			sensor_param.exposure = sensor_settings.exposure;
 			sensor_param.gain = 0;
 			/* Queue new value for stats collecton. */
-			hp3a_enqueue_irqsave(&g_tc.sensor_read_queue, &sensor_param);
+			hp3a_enqueue_irqsave(&g_tc.sensor_read_queue,
+				&sensor_param);
 			/* Save new programmed in exposure value. */
-			g_tc.current_exposure = sensor_settings.exposure;
+			g_tc.sensor_current.exposure = sensor_settings.exposure;
 		}
+
+		g_tc.sensor_current.fps = sensor_settings.fps;
 	}
 }
diff --git a/drivers/media/video/hplens.c b/drivers/media/video/hplens.c
index ad29e04..d687519 100644
--- a/drivers/media/video/hplens.c
+++ b/drivers/media/video/hplens.c
@@ -258,7 +258,8 @@ static int hplens_ioctl_s_power(struct v4l2_int_device *s, enum v4l2_power on)
  * from the video_control[] array.  Otherwise, returns -EINVAL if the
  * control is not supported.
  */
-static int hplens_ioctl_queryctrl(struct v4l2_int_device *s, struct v4l2_queryctrl *qc)
+static int hplens_ioctl_queryctrl(struct v4l2_int_device *s,
+			struct v4l2_queryctrl *qc)
 {
 	int i;
 
@@ -298,36 +299,42 @@ static int hplens_ioctl_s_ctrl(struct v4l2_int_device *s,
 
 	switch (vc->id) {
 	case V4L2_CID_HPLENS_CMD_READ: {
-		ret = copy_from_user(&reg, (void *)vc->value,  sizeof(struct hplens_reg));
+		ret = copy_from_user(&reg, (void *)vc->value,  \
+			sizeof(struct hplens_reg));
 		if (ret == 0) {
-			if (reg.addr[0] != 0xff) {   /* valid register address */
+			if (reg.addr[0] != 0xff) {
+				/* valid register address */
 				/* write the register address to read */
-				ret = hplens_reg_write(reg.dev_addr, reg.addr, reg.len_addr);
+				ret = hplens_reg_write(reg.dev_addr, \
+					reg.addr, reg.len_addr);
 			}
 			/* Read the register */
-			ret = hplens_reg_read(reg.dev_addr, reg.data, reg.len_data);
+			ret = hplens_reg_read(reg.dev_addr, \
+				reg.data, reg.len_data);
 			if (ret == 0) {
-				ret = copy_to_user((void *)vc->value, &reg, sizeof(struct hplens_reg));
+				ret = copy_to_user((void *)vc->value, &reg, \
+					sizeof(struct hplens_reg));
 			}
 		}
 	}
 	break;
 	case V4L2_CID_HPLENS_CMD_WRITE: {
-		ret = copy_from_user(&reg, (void *)vc->value,  sizeof(struct hplens_reg));
+		ret = copy_from_user(&reg, (void *)vc->value,  \
+			sizeof(struct hplens_reg));
 		if (ret == 0) {
 			if (reg.addr[0] != 0xff) { /* valid register address */
 				while (fdb < reg.len_addr) {
-					/* put the register address to write in the buffer first */
+					/* write register address in buffer */
 					write_buffer[fdb] = reg.addr[fdb];
 					fdb++;
 				}
 			}
 
-			for (idx = fdb; idx <= reg.len_data; idx++) {
+			for (idx = fdb; idx <= reg.len_data; idx++)
 				write_buffer[idx] = reg.data[idx-fdb];
-			}
 
-			ret = hplens_reg_write(reg.dev_addr, write_buffer, reg.len_data + fdb);
+			ret = hplens_reg_write(reg.dev_addr, \
+				write_buffer, reg.len_data + fdb);
 		}
 	}
 	break;
@@ -335,22 +342,25 @@ static int hplens_ioctl_s_ctrl(struct v4l2_int_device *s,
 
 		/* Using dynamic memory. */
 		eeprom = kmalloc(sizeof(struct hplens_eeprom), GFP_KERNEL);
-		if(eeprom == NULL){
+		if (eeprom == NULL)
 			return -EINVAL;
-		}
 
-		ret = copy_from_user(eeprom, (void *)vc->value,  sizeof(struct hplens_eeprom));
+		ret = copy_from_user(eeprom, (void *)vc->value,  \
+			sizeof(struct hplens_eeprom));
 		if (ret == 0) {
-			if (eeprom->addr[0] != 0xff) {   /* valid register address */
+			if (eeprom->addr[0] != 0xff) {
+				/* valid register address */
 				/* write the register address to read */
-				ret = hplens_reg_write(eeprom->dev_addr, eeprom->addr, eeprom->len_addr);
+				ret = hplens_reg_write(eeprom->dev_addr, \
+					eeprom->addr, eeprom->len_addr);
 			}
 
 			/* Read the register */
-			ret = hplens_reg_read(eeprom->dev_addr, eeprom->data, eeprom->len_data);
-			if (ret == 0) {
-				ret = copy_to_user((void *)vc->value, eeprom, sizeof(struct hplens_eeprom));
-			}
+			ret = hplens_reg_read(eeprom->dev_addr, \
+				eeprom->data, eeprom->len_data);
+			if (ret == 0)
+				ret = copy_to_user((void *)vc->value, eeprom, \
+					sizeof(struct hplens_eeprom));
 		}
 
 		/* clean up. */
@@ -401,7 +411,8 @@ static struct v4l2_int_device hplens_int_device = {
  *
  * Returns 0 if successful, or -EBUSY if unable to get client attached data.
  **/
-static int hplens_probe(struct i2c_client *client, const struct i2c_device_id *id)
+static int hplens_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
 {
 	struct hplens_device *lens = &hplens;
 	int err;
@@ -427,7 +438,8 @@ static int hplens_probe(struct i2c_client *client, const struct i2c_device_id *i
 
 	err = v4l2_int_device_register(lens->v4l2_int_device);
 	if (err) {
-		printk(KERN_ERR "Failed to Register " DRIVER_NAME " as V4L2 device.\n");
+		printk(KERN_ERR "Failed to Register " \
+			DRIVER_NAME " as V4L2 device.\n");
 		i2c_set_clientdata(client, NULL);
 	} else {
 		printk(KERN_ERR "Registered " DRIVER_NAME " as V4L2 device.\n");
diff --git a/drivers/media/video/mipi_dli.c b/drivers/media/video/mipi_dli.c
new file mode 100644
index 0000000..4ee87ba
--- /dev/null
+++ b/drivers/media/video/mipi_dli.c
@@ -0,0 +1,185 @@
+/*
+ * driver/media/video/mipi_dli.c
+ *
+ * Copyright 2009 Motorola Corporation.
+ *
+ * Authors: DongSun Yang. <mbr863@motorola.com>
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/fs.h>		/* everything... */
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include <linux/io.h>
+#include "oldisp/ispreg.h"
+#include <linux/uaccess.h>
+
+#include <linux/mipi_dli.h>
+
+struct mipi_dli_platform_data {
+	struct mutex lock;		    /* Mutex lock */
+	unsigned long FrameCount;    /* total frames after last reset */
+	unsigned long ECCErrors;       /* ECC errors after last reset */
+	unsigned long CRCErrors;       /* CRC errors after last reset */
+};
+
+/*Counters for MIPI DLI.*/
+unsigned long frame_counter;
+unsigned long ecc_counter;
+unsigned long crc_counter;
+
+static int mipi_dli_open(struct inode *inode, struct file *file)
+{
+  printk(KERN_ERR "%s is called.\n", __func__);
+  return nonseekable_open(inode, file);
+}
+
+static int mipi_dli_release(struct inode *inode, struct file *file)
+{
+  printk(KERN_ERR "%s is called.\n", __func__);
+  return 0;
+}
+
+static int mipi_dli_ioctl(struct inode *inode, struct file *file,\
+				unsigned int cmd, unsigned long arg)
+{
+	unsigned long mipi_counter;
+	void __user *argp = (void __user *)arg;
+
+	int ret = 0;
+
+	printk(KERN_ERR "mipi_dli_ioctl function start.\n");
+
+	if (copy_from_user(&mipi_counter, argp, sizeof(mipi_counter)))
+		return -EFAULT;
+
+	printk(KERN_ERR "mipi_dli_ioctl operation start.\n");
+
+	if (mipi_counter == 0) {
+		/*Reset counter.*/
+		switch (cmd) {
+		case MIPI_DLI_IOCTL_FRAME_COUNT:
+			mipi_counter = omap_readl(ISPCSI2_CTX_CTRL2(0));
+			mipi_counter = (mipi_counter & 0xFFFF0000) >> 16;
+			frame_counter = mipi_counter;
+			break;
+
+		case MIPI_DLI_IOCTL_ECC_COUNT:
+			ecc_counter = 0;
+			break;
+
+		case MIPI_DLI_IOCTL_CRC_COUNT:
+			crc_counter = 0;
+			break;
+
+		default:
+			printk(KERN_ERR "Unexpected parameter.\n");
+			ret = -EINVAL;
+			break;
+		}
+	} else {
+		/*Get counter.*/
+		switch (cmd)	{
+		case MIPI_DLI_IOCTL_FRAME_COUNT:
+			mipi_counter = omap_readl(ISPCSI2_CTX_CTRL2(0));
+			mipi_counter = (mipi_counter & 0xFFFF0000) >> 16;
+			mipi_counter -= frame_counter;
+			break;
+
+		case MIPI_DLI_IOCTL_ECC_COUNT:
+			mipi_counter = ecc_counter;
+			break;
+
+		case MIPI_DLI_IOCTL_CRC_COUNT:
+			mipi_counter = crc_counter;
+			break;
+
+		default:
+			printk(KERN_ERR "Unexpected parameter.\n");
+			ret = -EINVAL;
+			break;
+		}
+
+		if (ret != 0) {
+			printk(KERN_ERR "mipi_dli cmd fail %d.\n", cmd);
+			return -EFAULT;
+		} else
+			printk(KERN_ERR "mipi_counter = %ld.\n",\
+				mipi_counter);
+
+		if (copy_to_user(argp, &mipi_counter, sizeof(mipi_counter)))
+			ret = -EFAULT;
+	}
+
+	return ret;
+}
+
+static const struct file_operations mipi_dli_fops = {
+	.owner   = THIS_MODULE,
+	.open    = mipi_dli_open,
+	.release = mipi_dli_release,
+	.ioctl   = mipi_dli_ioctl,
+};
+
+static struct miscdevice mipi_dli_device = {
+  .minor = MISC_DYNAMIC_MINOR,
+  .name = MIPI_DLI_DEVICE_NAME,
+  .fops = &mipi_dli_fops,
+};
+
+
+static int __init mipi_dli_probe(struct platform_device *pdev)
+{
+	struct mipi_dli_platform_data *mipi_dli;
+	int ret = 0;
+
+	mipi_dli = kzalloc(sizeof(struct mipi_dli_platform_data), GFP_KERNEL);
+	if (!mipi_dli)
+		return -ENOMEM;
+
+	ret = misc_register(&mipi_dli_device);
+
+	if (ret != 0)
+		printk(KERN_ERR "misc_register failed\n");
+
+	mutex_init(&mipi_dli->lock);
+
+	printk(KERN_ERR "MIPI DLI tester probe is finished.\n");
+
+	return ret;
+}
+
+static int mipi_dli_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static void mipi_dli_shutdown(struct platform_device *pdev)
+{
+}
+
+static struct platform_driver mipi_dli_driver = {
+	.driver		= {
+		.name	= "mipi_dli_tester",
+	},
+	.remove		= __devexit_p(mipi_dli_remove),
+	.shutdown	= mipi_dli_shutdown,
+};
+
+static int __init mipi_dli_init(void)
+{
+	int retval = 0;
+	retval = platform_driver_probe(&mipi_dli_driver, mipi_dli_probe);
+	if (retval != 0) {
+		printk(KERN_ERR "failed mipi dli register/probe %d\n", retval);
+		return -ENODEV;
+	}
+	return retval;
+}
+
+subsys_initcall(mipi_dli_init);
+
+MODULE_AUTHOR("Motorola Corporation");
+MODULE_DESCRIPTION("MIPI DLI test Module");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/oldisp/isp.c b/drivers/media/video/oldisp/isp.c
index c407905..7566b0f 100644
--- a/drivers/media/video/oldisp/isp.c
+++ b/drivers/media/video/oldisp/isp.c
@@ -66,13 +66,11 @@
 #endif
 
 
-#if ISP_WORKAROUND
 void *buff_addr;
 dma_addr_t buff_addr_mapped;
 struct scatterlist *sglist_alloc;
 static int alloc_done, num_sc;
 unsigned long offset_value;
-#endif
 
 struct completion isp_wfc;
 
@@ -218,6 +216,7 @@ struct isp_sgdma ispsg;
 struct ispmodule {
 	unsigned int isp_pipeline;
 	int isp_temp_state;
+	int isp_lsc_workaround;
 	int applyCrop;
 	struct v4l2_pix_format pix;
 	unsigned int ccdc_input_width;
@@ -237,6 +236,7 @@ struct ispmodule {
 static struct ispmodule ispmodule_obj = {
 	.isp_pipeline = OMAP_ISP_CCDC,
 	.isp_temp_state = ISP_BUF_INIT,
+	.isp_lsc_workaround = ISP_WORKAROUND,
 	.applyCrop = 0,
 	.pix = {
 		.width = ISP_OUTPUT_WIDTH_DEFAULT,
@@ -278,6 +278,11 @@ static struct isp_reg isp_reg_list[] = {
 	{ISP_TOK_TERM, 0}
 };
 
+int isp_lsc_workaround_enabled(void)
+{
+	return ispmodule_obj.isp_lsc_workaround;
+}
+
 /*
  *
  * V4L2 Handling
@@ -347,30 +352,6 @@ void isp_release_resources(void)
 /* Flag to check first time of isp_get */
 static int off_mode;
 
-static void isp_lsc_isr(unsigned long status, isp_vbq_callback_ptr arg1,
-			void *arg2)
-{
-	(void) arg1;
-	(void) arg2;
-
-	if (status & LSC_PRE_ERR) {
-		/* printk(KERN_ERR "isp_sr: LSC_PRE_ERR \n"); */
-		ispccdc_enable_lsc(0);
-		ispccdc_enable_lsc(1);
-	}
-}
-
-static void isp_csia_isr(unsigned long status, isp_vbq_callback_ptr arg1,
-			void *arg2)
-{
-	(void) arg1;
-	(void) arg2;
-
-	if (status & CSIA) {
-		isp_csi2_isr();
-	}
-}
-
 /**
  * isp_set_sgdma_callback - Set Scatter-Gather DMA Callback.
  * @sgdma_state: Pointer to structure with the SGDMA state for each videobuffer
@@ -396,7 +377,8 @@ static int isp_set_sgdma_callback(struct isp_sgdma_state *sgdma_state,
 							sgdma_state->arg);
 		isp_set_callback(CBK_CCDC_VD1, sgdma_state->callback, func_ptr,
 							sgdma_state->arg);
-		isp_set_callback(CBK_LSC_ISR, isp_lsc_isr, NULL, NULL);
+		isp_set_callback(CBK_LSC_ISR, (isp_callback_t)isp_lsc_isr,
+		NULL, NULL);
 	}
 
 	/* isp_set_callback(CBK_SBL_OVF, NULL, NULL, NULL); */
@@ -588,7 +570,7 @@ int isp_unset_callback(enum isp_callback_type type)
 		break;
 	case CBK_SBL_OVF:
 		omap_writel((omap_readl(ISP_IRQ0ENABLE)) &
-						~IRQ0ENABLE_OVF_IRQ, ISP_IRQ0ENABLE);
+			~IRQ0ENABLE_OVF_IRQ, ISP_IRQ0ENABLE);
 		break;
 	default:
 		break;
@@ -960,9 +942,6 @@ int isp_configure_interface(struct isp_interface_config *config)
 		ispctrl_val &= ~ISPCTRL_PAR_BRIDGE_BENDIAN;
 		ispctrl_val |= (0x03 << ISPCTRL_PAR_BRIDGE_SHIFT);
 
-		isp_csi2_ctx_config_format(0, config->u.csi.format);
-		isp_csi2_ctx_update(0, false);
-
 		if (config->u.csi.crc)
 			isp_csi2_ctrl_config_ecc_enable(true);
 
@@ -971,7 +950,11 @@ int isp_configure_interface(struct isp_interface_config *config)
 		isp_csi2_ctrl_config_vp_clk_enable(true);
 		isp_csi2_ctrl_update(false);
 
-		isp_set_callback(CBK_CSIA, isp_csia_isr, NULL, NULL);
+		isp_csi2_ctx_config_format(0, config->u.csi.format);
+		isp_csi2_ctx_update(0, false);
+
+		isp_set_callback(CBK_CSIA, (isp_callback_t)isp_csia_isr,
+		NULL, NULL);
 
 		isp_csi2_irq_complexio1_set(1);
 		isp_csi2_irq_status_set(1);
@@ -996,12 +979,15 @@ int isp_configure_interface(struct isp_interface_config *config)
 	omap_writel(ispctrl_val, ISP_CTRL);
 	spin_unlock(&isp_obj.isp_temp_buf_lock);
 	ispccdc_vdint_val = omap_readl(ISPCCDC_VDINT);
+
 	ispccdc_vdint_val &= ~(ISPCCDC_VDINT_0_MASK << ISPCCDC_VDINT_0_SHIFT);
 	ispccdc_vdint_val &= ~(ISPCCDC_VDINT_1_MASK << ISPCCDC_VDINT_1_SHIFT);
+/* - disabled, causing VDINT to be reset to 0 at start_streaming
 	omap_writel((config->vdint0_timing << ISPCCDC_VDINT_0_SHIFT) |
 						(config->vdint1_timing <<
 						ISPCCDC_VDINT_1_SHIFT),
 						ISPCCDC_VDINT);
+*/
 
 	/* Set sensor specific fields in CCDC and Previewer module.*/
 	ispccdc_set_wenlog(config->wenlog);
@@ -1038,11 +1024,15 @@ EXPORT_SYMBOL(isp_configure_interface_bridge);
  **/
 void isp_CCDC_VD01_enable(void)
 {
-	omap_writel(IRQ0STATUS_CCDC_VD0_IRQ | IRQ0STATUS_CCDC_VD1_IRQ,
-							ISP_IRQ0STATUS);
-	omap_writel(omap_readl(ISP_IRQ0ENABLE) | IRQ0ENABLE_CCDC_VD0_IRQ |
-						IRQ0ENABLE_CCDC_VD1_IRQ,
-						ISP_IRQ0ENABLE);
+	u32 irq_enable = omap_readl(ISP_IRQ0ENABLE);
+
+	if (!(irq_enable & (IRQ0ENABLE_CCDC_VD0_IRQ | \
+		IRQ0ENABLE_CCDC_VD1_IRQ))) {
+		omap_writel(IRQ0STATUS_CCDC_VD0_IRQ | \
+			IRQ0STATUS_CCDC_VD1_IRQ, ISP_IRQ0STATUS);
+		omap_writel(irq_enable | (IRQ0ENABLE_CCDC_VD0_IRQ | \
+			IRQ0ENABLE_CCDC_VD1_IRQ), ISP_IRQ0ENABLE);
+	}
 }
 
 /**
@@ -1074,14 +1064,18 @@ static irqreturn_t omap34xx_isp_isr(int irq, void *ispirq_disp)
 	int i;
 	struct ispirq *irqdis = (struct ispirq *)ispirq_disp;
 	u32 irqstatus;
+	unsigned long irqflags = 0;
 
+	spin_lock_irqsave(&isp_obj.lock, irqflags);
 	irqstatus = omap_readl(ISP_IRQ0STATUS);
 	omap_writel(irqstatus, ISP_IRQ0STATUS);
 	/* The following register read is for write sync. */
 	omap_readl(ISP_IRQ0STATUS);
+	spin_unlock_irqrestore(&isp_obj.lock, irqflags);
 
 	for (i = 0; i < CBK_END; ++i) {
-		if ((irqstatus & irqdis->irq_events[i]) == irqdis->irq_events[i]) {
+		if ((irqstatus & irqdis->irq_events[i]) == \
+				irqdis->irq_events[i]) {
 			if (irqdis->isp_callbk[i]) {
 				irqdis->isp_callbk[i](irqdis->irq_events[i],
 				irqdis->isp_callbk_arg1[i],
@@ -1124,35 +1118,41 @@ void omapisp_unset_callback()
 		/* isp_unset_callback(CBK_SBL_OVF); */
 	}
 
-	if (isp_obj.if_status & ISP_CSIA) {
+	if (isp_obj.if_status & ISP_CSIA)
 		isp_unset_callback(CBK_CSIA);
-	}
 
 	omap_writel(omap_readl(ISP_IRQ0STATUS) | ISP_INT_CLR, ISP_IRQ0STATUS);
 }
 EXPORT_SYMBOL(omapisp_unset_callback);
 
-#if ISP_WORKAROUND
 /**
- *  isp_buf_allocation - To allocate a 10MB memory
+ *  isp_buf_allocation - To allocate isp workaround buffer
  *
  **/
 u32 isp_buf_allocation(void)
 {
-	buff_addr = (void *) vmalloc(ISP_BUFFER_MAX_SIZE);
+	if (alloc_done == 0) {
+		buff_addr = (void *) vmalloc(ISP_BUFFER_MAX_SIZE);
 
-	if (!buff_addr) {
-		printk(KERN_ERR "ISP_ERR: Cannot allocate "
-			"ISP_WORKAROUND memory\n");
-		return -ENOMEM;
-	}
+		if (!buff_addr) {
+			printk(KERN_ERR "ISP_ERR: Cannot allocate "
+				"ISP_WORKAROUND memory\n");
+			return -ENOMEM;
+		}
 
-	sglist_alloc = videobuf_vmalloc_to_sg(buff_addr, ISP_BUFFER_MAX_PAGES);
-	if (!sglist_alloc) {
-		printk(KERN_ERR "ISP_ERR: videobuf_vmalloc_to_sg failed\n");
-		return -ENOMEM;
+		sglist_alloc = videobuf_vmalloc_to_sg(buff_addr,
+		ISP_BUFFER_MAX_PAGES);
+		if (!sglist_alloc) {
+			printk(KERN_ERR "ISP_ERR: videobuf_vmalloc_to_sg failed\n");
+			vfree(buff_addr);
+			buff_addr = NULL;
+			return -ENOMEM;
+		}
+		num_sc = dma_map_sg(NULL, sglist_alloc,
+		ISP_BUFFER_MAX_PAGES, 1);
+		alloc_done = 1;
 	}
-	num_sc = dma_map_sg(NULL, sglist_alloc, ISP_BUFFER_MAX_PAGES, 1);
+
 	return 0;
 }
 
@@ -1162,16 +1162,34 @@ u32 isp_buf_allocation(void)
  **/
 u32 isp_buf_mmap(void)
 {
-	buff_addr_mapped = ispmmu_map_sg(sglist_alloc, ISP_BUFFER_MAX_PAGES);
-	if (!buff_addr_mapped) {
-		printk(KERN_ERR "ISP_ERR: ispmmu_map_sg mapping failed\n");
+	if (alloc_done == 0)
+		isp_buf_allocation();
+
+	if (alloc_done == 1) {
+		if (buff_addr_mapped == 0) {
+			buff_addr_mapped = ispmmu_map_sg(sglist_alloc,
+			ISP_BUFFER_MAX_PAGES);
+			if (!buff_addr_mapped) {
+				printk(KERN_ERR "ISP_ERR: ispmmu_map_sg mapping failed\n");
+				return -ENOMEM;
+			}
+		}
+	} else {
+		printk(KERN_ERR "ISP_ERR: no buffer allocated for mapping!\n");
 		return -ENOMEM;
 	}
-	isppreview_set_outaddr(buff_addr_mapped);
-	alloc_done = 1;
+
 	return 0;
 }
 
+void isp_buf_unmmap(void)
+{
+	if (buff_addr_mapped) {
+		ispmmu_unmap(buff_addr_mapped);
+		buff_addr_mapped = 0;
+	}
+}
+
 /**
  *  isp_buf_get - Get the buffer pointer address
  **/
@@ -1179,28 +1197,29 @@ dma_addr_t isp_buf_get(void)
 {
 	dma_addr_t retaddr;
 
-	if (alloc_done == 1)
+	if (ispmodule_obj.isp_lsc_workaround == 1 && buff_addr_mapped)
 		retaddr = buff_addr_mapped + offset_value;
 	else
 		retaddr = 0;
+
 	return retaddr;
 }
 
 /**
- *  isp_buf_free - To free allocated 10MB memory
+ *  isp_buf_free - To free allocated ISP workaround buffer
  *
  **/
 void isp_buf_free(void)
 {
 	if (alloc_done == 1) {
-		ispmmu_unmap(buff_addr_mapped);
+		isp_buf_unmmap();
 		dma_unmap_sg(NULL, sglist_alloc, ISP_BUFFER_MAX_PAGES, 1);
 		kfree(sglist_alloc);
 		vfree(buff_addr);
+		buff_addr = NULL;
 		alloc_done = 0;
 	}
 }
-#endif
 
 /**
  * isp_start - Starts ISP submodule
@@ -1236,23 +1255,23 @@ void isp_stop()
 	omapisp_unset_callback();
 	ispccdc_enable_lsc(0);
 	ispccdc_enable(0);
-	while (ispccdc_busy() && (timeout < 100)) {
+	while (ispccdc_busy() && (timeout < 1000)) {
 		timeout++;
-		mdelay(10);
+		msleep(1);
 	}
 
 	timeout = 0;
 	isppreview_enable(0);
-	while (isppreview_busy() && (timeout < 100)) {
+	while (isppreview_busy() && (timeout < 1000)) {
 		timeout++;
-		mdelay(10);
+		msleep(1);
 	}
 
 	timeout = 0;
 	ispresizer_enable(0);
-	while (ispresizer_busy() && (timeout < 100)) {
+	while (ispresizer_busy() && (timeout < 1000)) {
 		timeout++;
-		mdelay(10);
+		msleep(1);
 	}
 
 	timeout = 0;
@@ -1270,7 +1289,8 @@ void isp_stop()
 		msleep(1);
 	}
 
-	/* omap_writel(omap_readl(ISP_IRQ0STATUS) | ISP_INT_CLR, ISP_IRQ0STATUS); */
+	/* omap_writel(omap_readl(ISP_IRQ0STATUS) | */
+	/* 	ISP_INT_CLR, ISP_IRQ0STATUS); */
 
 	isp_restore_ctx();
 }
@@ -1282,16 +1302,15 @@ void isp_stop()
 void isp_set_buf(struct isp_sgdma_state *sgdma_state)
 {
 	if ((ispmodule_obj.isp_pipeline & OMAP_ISP_RESIZER) &&
-						is_ispresizer_enabled())
+						is_ispresizer_enabled()) {
 		ispresizer_set_outaddr(sgdma_state->isp_addr);
-#if (ISP_WORKAROUND == 0)
-	else if ((ispmodule_obj.isp_pipeline & OMAP_ISP_PREVIEW) &&
-						is_isppreview_enabled())
-		isppreview_set_outaddr(sgdma_state->isp_addr);
-#endif
-	else if (ispmodule_obj.isp_pipeline & OMAP_ISP_CCDC)
+	} else if ((ispmodule_obj.isp_pipeline & OMAP_ISP_PREVIEW) &&
+						is_isppreview_enabled()) {
+		if (ispmodule_obj.isp_lsc_workaround == 0)
+			isppreview_set_outaddr(sgdma_state->isp_addr);
+	} else if (ispmodule_obj.isp_pipeline & OMAP_ISP_CCDC) {
 		ispccdc_set_outaddr(sgdma_state->isp_addr);
-
+	}
 }
 
 /**
@@ -1302,9 +1321,7 @@ void isp_set_buf(struct isp_sgdma_state *sgdma_state)
 u32 isp_calc_pipeline(struct v4l2_pix_format *pix_input,
 					struct v4l2_pix_format *pix_output)
 {
-#if ISP_WORKAROUND
 	int rval;
-#endif
 
 	isp_release_resources();
 	if ((pix_input->pixelformat == V4L2_PIX_FMT_SGRBG10) &&
@@ -1316,23 +1333,27 @@ u32 isp_calc_pipeline(struct v4l2_pix_format *pix_input,
 			isppreview_request();
 			ispresizer_request();
 		ispccdc_config_datapath(CCDC_RAW, CCDC_OTHERS_VP);
-#if ISP_WORKAROUND
-		isppreview_config_datapath(PRV_RAW_CCDC, PREVIEW_MEM);
-		ispresizer_config_datapath(RSZ_MEM_YUV);
-		if (alloc_done == 0) {
-#if !defined(CONFIG_VIDEO_OLDOMAP3_BUFFALLOC)
-			rval = isp_buf_allocation();
-			if (rval)
-				return -EINVAL;
-#endif
+
+		if (ispmodule_obj.isp_lsc_workaround == 1) {
+			DPRINTK_ISPCTRL("Using ISP workaround!\n");
+			isppreview_config_datapath(PRV_RAW_CCDC, PREVIEW_MEM);
+			ispresizer_config_datapath(RSZ_MEM_YUV);
+
 			rval = isp_buf_mmap();
-			if (rval)
+			if (rval) {
+				printk(KERN_ERR "ISP_ERR:  isp_buf_mmap() failed!\n");
 				return -EINVAL;
+			}
+
+			isppreview_set_outaddr(buff_addr_mapped);
+		} else {
+			DPRINTK_ISPCTRL("NOT using ISP workaround!\n");
+
+			isppreview_config_datapath(PRV_RAW_CCDC, PREVIEW_RSZ);
+			ispresizer_config_datapath(RSZ_OTFLY_YUV);
+			isppreview_set_outaddr(0);
+			ispccdc_enable_lsc(0);
 		}
-#else
-		isppreview_config_datapath(PRV_RAW_CCDC, PREVIEW_RSZ);
-		ispresizer_config_datapath(RSZ_OTFLY_YUV);
-#endif
 	} else if (pix_input->pixelformat == pix_output->pixelformat) {
 		ispmodule_obj.isp_pipeline = OMAP_ISP_CCDC;
 		ispccdc_request();
@@ -1405,95 +1426,122 @@ void isp_config_pipeline(struct v4l2_pix_format *pix_input,
  **/
 void isp_vbq_done(unsigned long status, isp_vbq_callback_ptr arg1, void *arg2)
 {
+	unsigned long flags = 0;
 	struct videobuf_buffer *vb = (struct videobuf_buffer *) arg2;
 	int notify = 0;
 	int rval = 0;
-	unsigned long flags;
 
 	switch (status) {
 	case CCDC_VD0:
-   #ifdef CONFIG_VIDEO_OMAP3_HP3A
-      hp3a_ccdc_done();
-   #else
-	  ispccdc_config_shadow_registers();
-   #endif
+#ifdef CONFIG_VIDEO_OMAP3_HP3A
+		hp3a_ccdc_done();
+#else
+		ispccdc_config_shadow_registers();
+#endif
+		spin_lock_irqsave(&isp_obj.isp_temp_buf_lock, flags);
 		if ((ispmodule_obj.isp_pipeline & OMAP_ISP_RESIZER) ||
-			(ispmodule_obj.isp_pipeline & OMAP_ISP_PREVIEW))
+			(ispmodule_obj.isp_pipeline & OMAP_ISP_PREVIEW)) {
+			spin_unlock_irqrestore(&isp_obj.isp_temp_buf_lock,
+			flags);
+			return;
+		} else if (ispmodule_obj.isp_temp_state != ISP_BUF_INIT) {
+			spin_unlock_irqrestore(&isp_obj.isp_temp_buf_lock,
+			flags);
 			return;
-		else {
-			spin_lock(&isp_obj.isp_temp_buf_lock);
-			if (ispmodule_obj.isp_temp_state != ISP_BUF_INIT) {
-				spin_unlock(&isp_obj.isp_temp_buf_lock);
-				return;
-
-			} else {
-				spin_unlock(&isp_obj.isp_temp_buf_lock);
-				break;
-			}
 		}
+		spin_unlock_irqrestore(&isp_obj.isp_temp_buf_lock,
+		flags);
 		break;
 	case CCDC_VD1:
 		if ((ispmodule_obj.isp_pipeline & OMAP_ISP_RESIZER) ||
-			(ispmodule_obj.isp_pipeline & OMAP_ISP_PREVIEW))
-			return;
-		spin_lock(&isp_obj.isp_temp_buf_lock);
-		if (ispmodule_obj.isp_temp_state == ISP_BUF_INIT) {
-			spin_unlock(&isp_obj.isp_temp_buf_lock);
-			ispccdc_enable(0);
+			(ispmodule_obj.isp_pipeline & OMAP_ISP_PREVIEW)) {
 			return;
 		}
-		spin_unlock(&isp_obj.isp_temp_buf_lock);
+		spin_lock_irqsave(&isp_obj.isp_temp_buf_lock, flags);
+		if (ispmodule_obj.isp_temp_state == ISP_BUF_INIT)
+			ispccdc_enable(0);
+		spin_unlock_irqrestore(&isp_obj.isp_temp_buf_lock, flags);
 		return;
-		break;
 	case PREV_DONE:
+#ifdef CONFIG_VIDEO_OMAP3_HP3A
+		hp3a_frame_done();
+#endif
 		if (is_isppreview_enabled()) {
-			if (ispmodule_obj.isp_pipeline & OMAP_ISP_RESIZER) {
-				spin_lock(&isp_obj.isp_temp_buf_lock);
+			spin_lock_irqsave(&isp_obj.isp_temp_buf_lock, flags);
+			if (ispmodule_obj.isp_pipeline & OMAP_ISP_RESIZER &&
+				!ispresizer_busy()) {
 				if (!ispmodule_obj.applyCrop &&
+				    ispmodule_obj.isp_lsc_workaround &&
 					(ispmodule_obj.isp_temp_state ==
-					 ISP_BUF_INIT))
+					 ISP_BUF_INIT)) {
 					ispresizer_enable(1);
-				spin_unlock(&isp_obj.isp_temp_buf_lock);
-				if (ispmodule_obj.applyCrop &&
-						!ispresizer_busy()) {
+				} else if (ispmodule_obj.applyCrop) {
 					ispresizer_enable(0);
 					ispresizer_applycrop();
 					ispmodule_obj.applyCrop = 0;
 				}
 			}
+			spin_unlock_irqrestore(&isp_obj.isp_temp_buf_lock,
+				flags);
 
+#ifdef CONFIG_VIDEO_OMAP3_HP3A
+			if (!isppreview_busy())
+				isppreview_config_shadow_registers();
+			hp3a_update_wb();
+		}
+#else
 			if (!isppreview_busy()) {
 				isppreview_config_shadow_registers();
-#ifdef CONFIG_VIDEO_OMAP3_HP3A
+				isph3a_update_wb();
 			}
-			hp3a_frame_done();
-#else
-			isph3a_update_wb();
 		}
 #endif
-
 		if (ispmodule_obj.isp_pipeline & OMAP_ISP_RESIZER)
 			return;
-		}
+
 		break;
 	case RESZ_DONE:
 		if (is_ispresizer_enabled()) {
-			ispresizer_config_shadow_registers();
-			spin_lock(&isp_obj.isp_temp_buf_lock);
+			spin_lock_irqsave(&isp_obj.isp_temp_buf_lock, flags);
+			if (!ispresizer_busy() && !ispccdc_busy())
+				ispresizer_config_shadow_registers();
+
+
 			if (ispmodule_obj.isp_temp_state != ISP_BUF_INIT) {
-				spin_unlock(&isp_obj.isp_temp_buf_lock);
+				spin_unlock_irqrestore
+				(&isp_obj.isp_temp_buf_lock, flags);
 				return;
 			}
-			spin_unlock(&isp_obj.isp_temp_buf_lock);
+			spin_unlock_irqrestore(&isp_obj.isp_temp_buf_lock,
+			flags);
 		}
 		break;
 	case HS_VS:
-		spin_lock(&isp_obj.isp_temp_buf_lock);
+		spin_lock_irqsave(&isp_obj.isp_temp_buf_lock, flags);
 		if (ispmodule_obj.isp_temp_state == ISP_BUF_TRAN) {
 			isp_CCDC_VD01_enable();
 			ispmodule_obj.isp_temp_state = ISP_BUF_INIT;
 		}
-		spin_unlock(&isp_obj.isp_temp_buf_lock);
+
+		if (!ispmodule_obj.isp_lsc_workaround &&
+			(ispmodule_obj.isp_pipeline & OMAP_ISP_RESIZER) &&
+			 !ispresizer_busy() &&
+			 !isppreview_busy()) {
+			if (!ispmodule_obj.applyCrop &&
+				 (ispmodule_obj.isp_temp_state ==
+				 ISP_BUF_INIT)) {
+				ispresizer_enable(1);
+			} else if (ispmodule_obj.applyCrop) {
+				ispresizer_enable(0);
+				ispresizer_applycrop();
+				ispmodule_obj.applyCrop = 0;
+			}
+		}
+
+		spin_unlock_irqrestore(&isp_obj.isp_temp_buf_lock, flags);
+
+		ktime_get_ts((struct timespec *)&vb->ts);
+
 #ifdef CONFIG_VIDEO_OMAP3_HP3A
 		hp3a_ccdc_start();
 #endif
@@ -1510,9 +1558,8 @@ void isp_vbq_done(unsigned long status, isp_vbq_callback_ptr arg1, void *arg2)
 
 	rval = arg1(vb);
 
-	if (rval) {
+	if (rval)
 		isp_sgdma_process(&ispsg, 1, &notify, arg1);
-	}
 
 	return;
 }
@@ -1540,10 +1587,11 @@ EXPORT_SYMBOL(isp_stop);
 void isp_sgdma_cancel()
 {
 	int sg;
-	unsigned long flags;
 	struct videobuf_buffer *vb;
+	unsigned long flags = 0;
 
 	spin_lock_irqsave(&ispsg.lock, flags);
+
 	for (sg = 0; sg < NUM_SG_DMA; sg++) {
 		if (ispsg.sg_state[sg].arg) {
 			vb = ispsg.sg_state[sg].arg;
@@ -1552,6 +1600,7 @@ void isp_sgdma_cancel()
 			ispsg.sg_state[sg].arg = NULL;
 		}
 	}
+
 	spin_unlock_irqrestore(&ispsg.lock, flags);
 }
 EXPORT_SYMBOL(isp_sgdma_cancel);
@@ -1933,6 +1982,20 @@ int isp_handle_private(int cmd, void *arg)
       ispresizer_config_filter_coef(resizer_coef);
       }
    break;
+   case VIDIOC_PRIVATE_ISP_CCDC_BAYER_CFG:
+	   {
+		   struct ispccdc_color_offset *offset;
+		   offset = (struct ispccdc_color_offset *)arg;
+		   ispccdc_set_crop_offset_dynamic(*offset);
+	   }
+	   break;
+	case VIDIOC_PRIVATE_ISP_LSC_WORKAROUND_CFG:
+	  {
+		 ispmodule_obj.isp_lsc_workaround = (*(int *)arg ? 1 : 0);
+		if (ispmodule_obj.isp_lsc_workaround == 0)
+			isp_buf_free();
+	  }
+	  break;
 	default:
 		rval = -EINVAL;
 		break;
@@ -2043,50 +2106,55 @@ EXPORT_SYMBOL(isp_s_fmt_cap);
  **/
 void isp_config_crop(struct v4l2_pix_format *croppix)
 {
-	u8 crop_scaling_w;
-	u8 crop_scaling_h;
-#if ISP_WORKAROUND
 	unsigned long org_left, num_pix, new_top, new_height;
-#endif
-
 	struct v4l2_pix_format *pix = croppix;
 
-	crop_scaling_w = (ispmodule_obj.preview_output_width * 10) /
-								pix->width;
-	crop_scaling_h = (ispmodule_obj.preview_output_height * 10) /
-								pix->height;
-
-	cur_rect.left = (ispcroprect.left * crop_scaling_w) / 10;
-	cur_rect.top = (ispcroprect.top * crop_scaling_h) / 10;
-	cur_rect.width = (ispcroprect.width * crop_scaling_w) / 10;
-	cur_rect.height = (ispcroprect.height * crop_scaling_h) / 10;
-
-#if ISP_WORKAROUND
-	org_left = cur_rect.left;
-	cur_rect.left = ALIGN_NEAR(cur_rect.left, 16);
-
-	num_pix = org_left - cur_rect.left;
-	new_top = (int)(num_pix * 3) / 4;
-	cur_rect.top = (cur_rect.top - new_top);
-	if ((int)cur_rect.top < 0)
-			cur_rect.top = 0;
-
-	new_height = (2 * new_top) + cur_rect.height;
-	if (new_height < cur_rect.height)
-		cur_rect.height = new_height;
-
-	cur_rect.width = cur_rect.width + (2 * num_pix);
-	cur_rect.width = ALIGN_NEAR(cur_rect.width, 16);
-
-	offset_value = ((cur_rect.left * 2) + \
-		((ispmodule_obj.preview_output_width) * 2 * cur_rect.top));
-#endif
+	cur_rect.left = (u32)(ispcroprect.left *
+		ispmodule_obj.preview_output_width)/(u32)pix->width;
+	cur_rect.top = (u32)(ispcroprect.top
+		* ispmodule_obj.preview_output_height)/(u32)pix->height;
+	cur_rect.width = (u32)(ispcroprect.width *
+		ispmodule_obj.preview_output_width)/(u32)pix->width;
+	cur_rect.height = (u32)(ispcroprect.height *
+		ispmodule_obj.preview_output_height)/(u32)pix->height;
+
+	if (ispmodule_obj.isp_lsc_workaround == 1) {
+		org_left = cur_rect.left;
+		cur_rect.left = ALIGN_NEAR(cur_rect.left, 16);
+
+		num_pix = org_left - cur_rect.left;
+		new_top = (int)(num_pix * 3) / 4;
+		cur_rect.top = (cur_rect.top - new_top);
+		if ((int)cur_rect.top < 0)
+				cur_rect.top = 0;
+
+		new_height = (2 * new_top) + cur_rect.height;
+		if (new_height < cur_rect.height)
+			cur_rect.height = new_height;
+
+		cur_rect.width = cur_rect.width + (2 * num_pix);
+		cur_rect.width = ALIGN_NEAR(cur_rect.width, 16);
+
+		offset_value = ((cur_rect.left * 2) + \
+			((ispmodule_obj.preview_output_width) * 2
+			* cur_rect.top));
+	} else {
+		offset_value = 0;
+		cur_rect.width = ALIGN_NEAR(cur_rect.width, 16);
+		cur_rect.height = ALIGN_NEAR(cur_rect.height, 8);
+	}
 
-	ispresizer_trycrop(cur_rect.left, cur_rect.top, cur_rect.width,
+	ispresizer_trycrop(cur_rect.left, cur_rect.top,
+					cur_rect.width,
 					cur_rect.height,
 					ispmodule_obj.resizer_output_width,
 					ispmodule_obj.resizer_output_height);
 
+	ispmodule_obj.applyCrop = 1;
+
+	DPRINTK_ISPCTRL("ISP: resizer crop (%d-%d-%d-%d) \n",
+		cur_rect.left, cur_rect.top, cur_rect.width, cur_rect.height);
+
 	return;
 }
 EXPORT_SYMBOL(isp_config_crop);
@@ -2120,26 +2188,32 @@ int isp_s_crop(struct v4l2_crop *a, struct v4l2_pix_format *pix)
 
 	if ((crop->c.left + crop->c.width) > pix->width) {
 		rval = -EINVAL;
-		DPRINTK_ISPCTRL("isp_s_crop(): crop->left=%d crop->width=%d pix->width=%d\n",
+		DPRINTK_ISPCTRL("isp_s_crop() crop->left = %d " \
+			"crop->width = %d pix->width = %d\n",
 			crop->c.left, crop->c.width, pix->width);
 		goto out;
 	}
 
 	if ((crop->c.top + crop->c.height) > pix->height) {
 		rval = -EINVAL;
-		DPRINTK_ISPCTRL("isp_s_crop(): crop->top=%d crop->height=%d pix->height=%d\n",
+		DPRINTK_ISPCTRL("isp_s_crop() crop->top = %d " \
+			"crop->height = %d pix->height = %d\n",
 			crop->c.top, crop->c.height, pix->height);
 		goto out;
 	}
 
+
 	ispcroprect.left = crop->c.left;
 	ispcroprect.top = crop->c.top;
 	ispcroprect.width = crop->c.width;
 	ispcroprect.height = crop->c.height;
 
+	DPRINTK_ISPCTRL("ISP: isp_s_crop -> crop (%d-%d-%d-%d)\n",
+		ispcroprect.left, ispcroprect.top,
+		ispcroprect.width, ispcroprect.height);
+
 	isp_config_crop(pix);
 
-	ispmodule_obj.applyCrop = 1;
 out:
 	return rval;
 }
@@ -2166,14 +2240,16 @@ int isp_try_fmt_cap(struct v4l2_pix_format *pix_input,
 		out_aspect_ratio = (pix_output->width * 256)/pix_output->height;
 	}
 
-	if ((out_aspect_ratio - in_aspect_ratio) > 25 &&  (out_aspect_ratio - in_aspect_ratio) < 180) {
+	if ((out_aspect_ratio - in_aspect_ratio) > 25 &&
+		(out_aspect_ratio - in_aspect_ratio) < 180) {
 		/* Adjusted for output aspect ratio. */
-		adjusted_height = ALIGN_TO(((pix_input->width*256)/out_aspect_ratio), 2);
+		adjusted_height = ALIGN_TO(
+			((pix_input->width*256)/out_aspect_ratio), 2);
 
 		ispccdc_config_crop(0,
-			((pix_input->height-adjusted_height)/2),
-			(adjusted_height + (pix_input->height-adjusted_height)/2),
-			pix_input->width);
+		(pix_input->height-adjusted_height)/2,
+		adjusted_height + (pix_input->height-adjusted_height)/2,
+		pix_input->width);
 	} else {
 		ispccdc_config_crop(0, 0, 0, 0);
 	}
@@ -2377,44 +2453,44 @@ EXPORT_SYMBOL(isp_restore_ctx);
 int isp_get(void)
 {
 	int ret_err = 0;
-	DPRINTK_ISPCTRL("isp_get: old %d\n", isp_obj.ref_count);
+	DPRINTK_ISPCTRL("isp_get() old %d\n", isp_obj.ref_count);
 	mutex_lock(&(isp_obj.isp_mutex));
 	if (isp_obj.ref_count == 0) {
 		isp_obj.cam_ick = clk_get(&camera_dev, "cam_ick");
 		if (IS_ERR(isp_obj.cam_ick)) {
-			DPRINTK_ISPCTRL("ISP_ERR: clk_get for "
+			DPRINTK_ISPCTRL("ISP_ERR : clk_get for "
 							"cam_ick failed\n");
 			ret_err = PTR_ERR(isp_obj.cam_ick);
 			goto out_clk_get_ick;
 		}
 		isp_obj.cam_mclk = clk_get(&camera_dev, "cam_mclk");
 		if (IS_ERR(isp_obj.cam_mclk)) {
-			DPRINTK_ISPCTRL("ISP_ERR: clk_get for "
+			DPRINTK_ISPCTRL("ISP_ERR : clk_get for "
 							"cam_mclk failed\n");
 			ret_err = PTR_ERR(isp_obj.cam_mclk);
 			goto out_clk_get_mclk;
 		}
 		isp_obj.csi2_fck = clk_get(&camera_dev, "csi2_96m_fck");
 		if (IS_ERR(isp_obj.csi2_fck)) {
-			DPRINTK_ISPCTRL("ISP_ERR: clk_get for csi2_fclk"
+			DPRINTK_ISPCTRL("ISP_ERR : clk_get for csi2_fclk"
 								" failed\n");
 			ret_err = PTR_ERR(isp_obj.csi2_fck);
 			goto out_clk_get_csi2_fclk;
 		}
 		ret_err = clk_enable(isp_obj.cam_ick);
 		if (ret_err) {
-			DPRINTK_ISPCTRL("ISP_ERR: clk_en for ick failed\n");
+			DPRINTK_ISPCTRL("ISP_ERR : clk_en for ick failed\n");
 			goto out_clk_enable_ick;
 		}
 		ret_err = clk_enable(isp_obj.cam_mclk);
 		if (ret_err) {
-			DPRINTK_ISPCTRL("ISP_ERR: clk_en for mclk failed\n");
+			DPRINTK_ISPCTRL("ISP_ERR : clk_en for mclk failed\n");
 			goto out_clk_enable_mclk;
 		}
 		ret_err = clk_enable(isp_obj.csi2_fck);
 		if (ret_err) {
-			DPRINTK_ISPCTRL("ISP_ERR: clk_en for csi2_fclk"
-								" failed\n");
+			DPRINTK_ISPCTRL("ISP_ERR : "
+				"clk_en for csi2_fclk failed\n");
 			goto out_clk_enable_csi2_fclk;
 		}
 		if (off_mode == 1)
@@ -2423,8 +2499,7 @@ int isp_get(void)
 	isp_obj.ref_count++;
 	mutex_unlock(&(isp_obj.isp_mutex));
 
-
-	DPRINTK_ISPCTRL("isp_get: new %d\n", isp_obj.ref_count);
+	DPRINTK_ISPCTRL("isp_get : new %d\n", isp_obj.ref_count);
 	return isp_obj.ref_count;
 
 out_clk_enable_csi2_fclk:
@@ -2452,17 +2527,16 @@ EXPORT_SYMBOL(isp_get);
  **/
 int isp_put(void)
 {
-	DPRINTK_ISPCTRL("isp_put: old %d\n", isp_obj.ref_count);
+	DPRINTK_ISPCTRL("isp_put old %d \n", isp_obj.ref_count);
 	mutex_lock(&(isp_obj.isp_mutex));
 	if (isp_obj.ref_count)
 		if (--isp_obj.ref_count == 0) {
 			isp_save_ctx();
 			off_mode = 1;
-#if ISP_WORKAROUND && !defined(CONFIG_VIDEO_OLDOMAP3_BUFFALLOC)
-			isp_buf_free();
-#endif
+
 			isp_release_resources();
 			ispmodule_obj.isp_pipeline = 0;
+			ispmodule_obj.isp_lsc_workaround = ISP_WORKAROUND;
 			clk_disable(isp_obj.cam_ick);
 			clk_disable(isp_obj.cam_mclk);
 			clk_disable(isp_obj.csi2_fck);
@@ -2473,7 +2547,7 @@ int isp_put(void)
 			memset(&cur_rect, 0, sizeof(cur_rect));
 		}
 	mutex_unlock(&(isp_obj.isp_mutex));
-	DPRINTK_ISPCTRL("isp_put: new %d\n", isp_obj.ref_count);
+	DPRINTK_ISPCTRL("isp_put new %d \n", isp_obj.ref_count);
 	return isp_obj.ref_count;
 }
 EXPORT_SYMBOL(isp_put);
@@ -2511,9 +2585,7 @@ EXPORT_SYMBOL(isp_restore_context);
  **/
 static int __init isp_init(void)
 {
-#if ISP_WORKAROUND && defined(CONFIG_VIDEO_OLDOMAP3_BUFFALLOC)
 	int rval;
-#endif
 	int i;
 
 	DPRINTK_ISPCTRL("+isp_init for Omap 3430 Camera ISP\n");
@@ -2527,13 +2599,13 @@ static int __init isp_init(void)
 	init_completion(&isp_wfc);
 	isp_wfc.done = 0;
 
-#if ISP_WORKAROUND && defined(CONFIG_VIDEO_OLDOMAP3_BUFFALLOC)
-	if (alloc_done == 0) {
-		rval = isp_buf_allocation();
-		if (rval)
-			return -EINVAL;
-	}
-#endif
+	buff_addr = NULL;
+	buff_addr_mapped = 0;
+	alloc_done = 0;
+	offset_value = 0;
+	rval = isp_buf_allocation();
+	if (rval)
+		return -EINVAL;
 
 	for (i = 0; i < CBK_END; ++i) {
 		ispirq_obj.irq_events[i] = 0;
@@ -2597,9 +2669,7 @@ static void __exit isp_cleanup(void)
 #endif
 	isp_ccdc_cleanup();
 	free_irq(INT_34XX_CAM_IRQ, &ispirq_obj);
-#if ISP_WORKAROUND && defined(CONFIG_VIDEO_OLDOMAP3_BUFFALLOC)
 	isp_buf_free();
-#endif
 }
 
 /**
@@ -2624,7 +2694,10 @@ static void rsz_isr(unsigned long status, isp_vbq_callback_ptr arg1, void *arg2)
  *
  * Interrupt Service Routine for Preview wrapper
  **/
-static void preview_isr(unsigned long status, isp_vbq_callback_ptr arg1, void *arg2)
+static void preview_isr(
+		unsigned long status,
+		isp_vbq_callback_ptr arg1,
+		void *arg2)
 {
 	isppreview_enable(0);
 	ispresizer_enable(1);
@@ -2638,7 +2711,10 @@ static void preview_isr(unsigned long status, isp_vbq_callback_ptr arg1, void *a
  *
  * Return a pointer to a page array.
  **/
-struct page **map_user_memory_to_kernel(unsigned long addr, u32 size, u32 *nr_pages_mapped)
+struct page **map_user_memory_to_kernel(
+			unsigned long addr,
+			u32 size,
+			u32 *nr_pages_mapped)
 {
 	struct page **ppages = NULL;
 	int nr_pages;
@@ -2663,15 +2739,13 @@ struct page **map_user_memory_to_kernel(unsigned long addr, u32 size, u32 *nr_pa
 			if (unlikely(ret != nr_pages)) {
 				kfree(ppages);
 				ppages = NULL;
-				printk(KERN_ERR "isp: Mapping user pages"
-						" to kernel failed!\n");
+				printk(KERN_ERR "isp : Mapping user pages"
+						" to kernel failed\n");
 			}
-			if (nr_pages_mapped) {
+			if (nr_pages_mapped)
 				*nr_pages_mapped = nr_pages;
-			}
-		} else {
-			printk(KERN_ERR "isp: Error allocating kernel memory!\n");
-		}
+		} else
+			printk(KERN_ERR "isp : Error allocating kernel memory\n");
 	}
 
 	return ppages;
@@ -2687,15 +2761,14 @@ void unmap_user_memory_from_kernel(struct page **pages, int nr_pages)
 	u32 i;
 
 	if (pages != NULL) {
-		for (i = 0; i < nr_pages; ++i) {
+		for (i = 0; i < nr_pages; ++i)
 			page_cache_release(pages[i]);
-		}
 	}
 }
 
 /**
  * isp_run_resizer - Run the resizer on memory based input
- *									and output.
+ * and output.
  * @userdata: address to the passed in data structure.
  *
  * Returns 0 on success, < 0 otherwise.
@@ -2705,7 +2778,7 @@ int isp_run_resizer(void *userdata)
 	int i;
 	int ret = -1;
 	struct ispprv_run_resizer *presizer_user = \
-							(struct ispprv_run_resizer *)userdata;
+		(struct ispprv_run_resizer *)userdata;
 	u32 input_buffer_size, output_buffer_size;
 	u32 input_nr_pages, output_nr_pages;
 	struct page **input_pages = NULL;
@@ -2715,23 +2788,24 @@ int isp_run_resizer(void *userdata)
 	struct ispprv_run_resizer resizer_param;
 
 	if (presizer_user == NULL) {
-		printk(KERN_ERR "isp_run_resizer: Invalid user data!\n");
+		printk(KERN_ERR "isp_run_resizer : Invalid user data\n");
 		return -EINVAL;
 	}
 
-	memcpy(&resizer_param, presizer_user, sizeof(struct ispprv_run_resizer));
+	memcpy(&resizer_param, presizer_user, \
+		sizeof(struct ispprv_run_resizer));
 
-	DPRINTK_ISPCTRL("\nisp_run_resizer: input(%d-%d) - output(%d-%d)\n",
-										resizer_param.input_width,
-										resizer_param.input_height,
-										resizer_param.output_width,
-										resizer_param.output_height);
+	DPRINTK_ISPCTRL("\nisp_run_resizer : input(%d-%d) - output(%d-%d)\n",
+		resizer_param.input_width,
+		resizer_param.input_height,
+		resizer_param.output_width,
+		resizer_param.output_height);
 
-	DPRINTK_ISPCTRL("isp_run_resizer: start(%d-%d) - end(%d-%d)\n",
-										resizer_param.left,
-										resizer_param.top,
-										resizer_param.crop_width,
-										resizer_param.crop_height);
+	DPRINTK_ISPCTRL("isp_run_resizer : start(%d-%d) - end(%d-%d)\n",
+		resizer_param.left,
+		resizer_param.top,
+		resizer_param.crop_width,
+		resizer_param.crop_height);
 
 	if (presizer_user->datain == 0 || presizer_user->dataout == 0)
 		return -EINVAL;
@@ -2739,60 +2813,59 @@ int isp_run_resizer(void *userdata)
 	ispresizer_save_context();
 
 	input_buffer_size = ALIGN_TO(presizer_user->input_width* \
-										presizer_user->input_height*2 , 0x100);
+		presizer_user->input_height*2 , 0x100);
 	input_pages = map_user_memory_to_kernel(presizer_user->datain,
-									input_buffer_size, &input_nr_pages);
+		input_buffer_size, &input_nr_pages);
 	if (input_pages == NULL) {
 		ret = -EINVAL;
-		printk(KERN_ERR "isp_run_resizer: memory allocation failed!\n");
+		printk(KERN_ERR "isp_run_resizer : memory allocation failed\n");
 		goto exit_cleanup;
 	}
 
 	output_buffer_size = ALIGN_TO(presizer_user->output_width* \
-											presizer_user->output_height*2, 0x1000);
+		presizer_user->output_height*2, 0x1000);
 	output_pages = map_user_memory_to_kernel(presizer_user->dataout,
-									output_buffer_size, &output_nr_pages);
+		output_buffer_size, &output_nr_pages);
 	if (output_pages == NULL) {
 		ret = -EINVAL;
-		printk(KERN_ERR "isp_run_resizer: memory allocation failed!\n");
+		printk(KERN_ERR "isp_run_resizer() memory allocation failed\n");
 		goto exit_cleanup;
 	}
-	for (i = 0; i < output_nr_pages; ++i) {
+	for (i = 0; i < output_nr_pages; ++i)
 		flush_dcache_page(output_pages[i]);
-	}
 
 	isp_addr_in = ispmmu_map_pages(input_pages, input_nr_pages);
 	if (isp_addr_in == 0) {
 		ret = -EINVAL;
-		printk(KERN_ERR "isp_run_resizer: isp mmu map failed!\n");
+		printk(KERN_ERR "isp_run_resizer() isp mmu map failed\n");
 		goto exit_cleanup;
 	}
 	isp_addr_out = ispmmu_map_pages(output_pages, output_nr_pages);
 	if (isp_addr_out == 0) {
 		ret = -EINVAL;
-		printk(KERN_ERR "isp_run_resizer: isp mmu map failed!\n");
+		printk(KERN_ERR "isp_run_resizer()  isp mmu map failed\n");
 		goto exit_cleanup;
 	}
 
 	if ((resizer_param.left == 0) && (resizer_param.top == 0)) {
-		ret = ispresizer_try_size(&resizer_param.input_width,
-												&resizer_param.input_height,
-												&resizer_param.output_width,
-												&resizer_param.output_height);
+			ret = ispresizer_try_size(&resizer_param.input_width,
+			&resizer_param.input_height,
+			&resizer_param.output_width,
+			&resizer_param.output_height);
 
-		ret = ispresizer_config_size(resizer_param.input_width,
-													resizer_param.input_height,
-													resizer_param.output_width,
-													resizer_param.output_height);
+			ret = ispresizer_config_size(resizer_param.input_width,
+			resizer_param.input_height,
+			resizer_param.output_width,
+			resizer_param.output_height);
 
 		ispresizer_set_inaddr(isp_addr_in);
 	} else {
 		ispresizer_trycrop(resizer_param.left,
-										resizer_param.top,
-										resizer_param.crop_width,
-										resizer_param.crop_height,
-										resizer_param.output_width,
-										resizer_param.output_height);
+			resizer_param.top,
+			resizer_param.crop_width,
+			resizer_param.crop_height,
+			resizer_param.output_width,
+			resizer_param.output_height);
 
 		ispresizer_applycrop();
 
@@ -2828,12 +2901,10 @@ int isp_run_resizer(void *userdata)
 exit_cleanup:
 	ispresizer_restore_context();
 
-	if (isp_addr_in != 0) {
+	if (isp_addr_in != 0)
 		ispmmu_unmap(isp_addr_in);
-	}
-	if (isp_addr_out != 0) {
+	if (isp_addr_out != 0)
 		ispmmu_unmap(isp_addr_out);
-	}
 	if (input_pages != NULL) {
 		unmap_user_memory_from_kernel(input_pages, input_nr_pages);
 		kfree(input_pages);
@@ -2843,14 +2914,14 @@ exit_cleanup:
 		kfree(output_pages);
 	}
 
-	DPRINTK_ISPCTRL("isp_run_resizer: exit.\n");
+	DPRINTK_ISPCTRL("isp_run_resizer : exit.\n");
 	return ret;
 }
 EXPORT_SYMBOL(isp_run_resizer);
 
 /**
  * isp_run_preview - Run the preview on memory based input
- *									and output.
+ * and output.
  * @userdata: address to the passed in data structure.
  *
  * Returns 0 on success, < 0 otherwise.
@@ -2859,7 +2930,8 @@ int isp_run_preview(void *userdata)
 {
 	int i;
 	int ret = -1;
-	struct ispprv_run_hardpipe *ppreview_user = (struct ispprv_run_hardpipe *)userdata;
+	struct ispprv_run_hardpipe *ppreview_user = \
+		(struct ispprv_run_hardpipe *)userdata;
 	struct ispprv_run_hardpipe preview_param;
 	u32 input_buffer_size, output_buffer_size;
 	u32 input_nr_pages, output_nr_pages;
@@ -2869,25 +2941,27 @@ int isp_run_preview(void *userdata)
 	unsigned long  isp_addr_out = 0;
 	u32 isppreview_pcr;
 	struct ispprv_run_resizer resizer_param;
+	u16 cropadjust = 0;
 
 	if (ppreview_user == NULL) {
-		printk(KERN_ERR "isp_run_preview: Invalid user data!\n");
+		printk(KERN_ERR "isp_run_preview() Invalid user data\n");
 		return -EINVAL;
 	}
 
-	memcpy(&preview_param, ppreview_user, sizeof(struct ispprv_run_hardpipe));
+	memcpy(&preview_param, ppreview_user, \
+		sizeof(struct ispprv_run_hardpipe));
 
-	DPRINTK_ISPCTRL("\nnisp_run_preview: input(%d-%d) - output(%d-%d)\n",
-										preview_param.input_width,
-										preview_param.input_height,
-										preview_param.output_width,
-										preview_param.output_height);
+	DPRINTK_ISPCTRL("\nnisp_run_preview() input(%d-%d) - output(%d-%d)\n",
+		preview_param.input_width,
+		preview_param.input_height,
+		preview_param.output_width,
+		preview_param.output_height);
 
-	DPRINTK_ISPCTRL("isp_run_preview: start(%d-%d) - end(%d-%d)\n",
-										preview_param.left,
-										preview_param.top,
-										preview_param.crop_width,
-										preview_param.crop_height);
+	DPRINTK_ISPCTRL("isp_run_preview() start(%d-%d) - end(%d-%d)\n",
+		preview_param.left,
+		preview_param.top,
+		preview_param.crop_width,
+		preview_param.crop_height);
 
 	if (ppreview_user->datain == 0 || ppreview_user->dataout == 0)
 		return -EINVAL;
@@ -2898,53 +2972,50 @@ int isp_run_preview(void *userdata)
 	ispccdc_config_crop(0, 0, 0, 0);
 
 	ret = isppreview_try_size(preview_param.input_width,
-											preview_param.input_height,
-											&preview_param.output_width,
-											&preview_param.output_height);
-	if (ret < 0) {
+		preview_param.input_height,
+		&preview_param.output_width,
+		&preview_param.output_height);
+	if (ret < 0)
 		goto exit_cleanup;
-	}
 	ret = isppreview_config_size(preview_param.input_width,
-													preview_param.input_height,
-													preview_param.output_width,
-													preview_param.output_height);
-	if (ret < 0) {
+		preview_param.input_height,
+		preview_param.output_width,
+		preview_param.output_height);
+	if (ret < 0)
 		goto exit_cleanup;
-	}
 
 	input_buffer_size = ALIGN_TO(ppreview_user->input_width* \
-										ppreview_user->input_height*2 , 0x100);
+		ppreview_user->input_height*2 , 0x100);
 	input_pages = map_user_memory_to_kernel(preview_param.datain,
-									input_buffer_size, &input_nr_pages);
+		input_buffer_size, &input_nr_pages);
 	if (input_pages == NULL) {
 		ret = -EINVAL;
-		printk(KERN_ERR "isp_run_preview: memory allocation failed!\n");
+		printk(KERN_ERR "isp_run_preview : memory allocation failed\n");
 		goto exit_cleanup;
 	}
 
 	output_buffer_size = ALIGN_TO(ppreview_user->output_width* \
-											ppreview_user->output_height*2, 0x1000);
+		ppreview_user->output_height*2, 0x1000);
 	output_pages = map_user_memory_to_kernel(preview_param.dataout,
-									output_buffer_size, &output_nr_pages);
+		output_buffer_size, &output_nr_pages);
 	if (output_pages == NULL) {
 		ret = -EINVAL;
-		printk(KERN_ERR "isp_run_preview: memory allocation failed!\n");
+		printk(KERN_ERR "isp_run_preview memory allocation failed\n");
 		goto exit_cleanup;
 	}
-	for (i = 0; i < output_nr_pages; ++i) {
+	for (i = 0; i < output_nr_pages; ++i)
 		flush_dcache_page(output_pages[i]);
-	}
 
 	isp_addr_in = ispmmu_map_pages(input_pages, input_nr_pages);
 	if (isp_addr_in == 0) {
 		ret = -EINVAL;
-		printk(KERN_ERR "isp_run_preview: isp mmu map failed!\n");
+		printk(KERN_ERR "isp_run_preview : isp mmu map failed\n");
 		goto exit_cleanup;
 	}
 	isp_addr_out = ispmmu_map_pages(output_pages, output_nr_pages);
 	if (isp_addr_out == 0) {
 		ret = -EINVAL;
-		printk(KERN_ERR "isp_run_preview: isp mmu map failed!\n");
+		printk(KERN_ERR "isp_run_preview isp mmu map failed\n");
 		goto exit_cleanup;
 	}
 
@@ -2974,47 +3045,56 @@ int isp_run_preview(void *userdata)
 
 	if ((preview_param.left == 0) && (preview_param.top == 0)) {
 		ret = ispresizer_try_size(&resizer_param.input_width,
-												&resizer_param.input_height,
-												&resizer_param.output_width,
-												&resizer_param.output_height);
-		if (ret < 0) {
+				&resizer_param.input_height,
+				&resizer_param.output_width,
+				&resizer_param.output_height);
+		if (ret < 0)
 			goto exit_cleanup;
-		}
 		ret = ispresizer_config_size(resizer_param.input_width,
-													resizer_param.input_height,
-													resizer_param.output_width,
-													resizer_param.output_height);
-		if (ret < 0) {
+				resizer_param.input_height,
+				resizer_param.output_width,
+				resizer_param.output_height);
+		if (ret < 0)
 			goto exit_cleanup;
-		}
 		ispresizer_set_inaddr(buff_addr_mapped);
 	} else {
 		ispresizer_trycrop(preview_param.left,
-										preview_param.top,
-										preview_param.crop_width,
-										preview_param.crop_height,
-										resizer_param.output_width,
-										resizer_param.output_height);
+				preview_param.top,
+				preview_param.crop_width,
+				preview_param.crop_height,
+				resizer_param.output_width,
+				resizer_param.output_height);
 
 		ispresizer_applycrop();
 
+      /*account for pixel loss when using crop*/
+		if ((preview_param.input_height > preview_param.output_height)
+				&& (preview_param.top > 16))
+			cropadjust = 8;
+		else
+			cropadjust = 0;
+
+
 		/*pixel alignment in 32bit space, vertical must be 0 per TRM */
 		omap_writel(((preview_param.left%16) <<
-							ISPRSZ_IN_START_HORZ_ST_SHIFT) |
-							(0 <<
-							ISPRSZ_IN_START_VERT_ST_SHIFT),
-							ISPRSZ_IN_START);
+					ISPRSZ_IN_START_HORZ_ST_SHIFT) |
+					(0 <<
+					ISPRSZ_IN_START_VERT_ST_SHIFT),
+					ISPRSZ_IN_START);
 
 		/* Align input address for cropping, per TRM  */
-		ispresizer_set_inaddr(buff_addr_mapped +
-							(preview_param.top*resizer_param.input_width*2)
-							+ ((preview_param.left/16)*32));
+		ispresizer_set_inaddr(buff_addr_mapped -
+				(resizer_param.input_width*2*cropadjust) +
+				(preview_param.top*resizer_param.input_width*2)
+				+ ((preview_param.left/16)*32));
 	}
 
 	ispresizer_set_outaddr(isp_addr_out);
 	ispresizer_config_inlineoffset(resizer_param.input_width*2);
-	isp_set_callback(CBK_PREV_DONE, preview_isr, (void *) NULL, (void *)NULL);
-	isp_set_callback(CBK_RESZ_DONE, rsz_isr, (void *) NULL, (void *)NULL);
+	isp_set_callback(CBK_PREV_DONE, preview_isr,
+			(void *) NULL, (void *)NULL);
+	isp_set_callback(CBK_RESZ_DONE, rsz_isr,
+			(void *) NULL, (void *)NULL);
 
 	omap_writel(RESZ_DONE|PREV_DONE, ISP_IRQ0STATUS);
 	isp_wfc.done = 0;
@@ -3031,12 +3111,10 @@ exit_cleanup:
 	isppreview_restore_context();
 	ispresizer_restore_context();
 
-	if (isp_addr_in != 0) {
+	if (isp_addr_in != 0)
 		ispmmu_unmap(isp_addr_in);
-	}
-	if (isp_addr_out != 0) {
+	if (isp_addr_out != 0)
 		ispmmu_unmap(isp_addr_out);
-	}
 	if (input_pages != NULL) {
 		unmap_user_memory_from_kernel(input_pages, input_nr_pages);
 		kfree(input_pages);
@@ -3046,7 +3124,7 @@ exit_cleanup:
 		kfree(output_pages);
 	}
 
-	DPRINTK_ISPCTRL("isp_run_preview: exit.\n");
+	DPRINTK_ISPCTRL("isp_run_preview : exit.\n");
 	return ret;
 }
 EXPORT_SYMBOL(isp_run_preview);
@@ -3061,33 +3139,34 @@ void isp_print_status(void)
 	if (!is_ispctrl_debug_enabled())
 		return;
 
-	DPRINTK_ISPCTRL("###CM_FCLKEN_CAM=0x%x\n",
+	DPRINTK_ISPCTRL("###CM_FCLKEN_CAM = 0x%x\n",
 					omap_readl(OMAP3_CM_FCLKEN_CAM));
-	DPRINTK_ISPCTRL("###CM_ICLKEN_CAM=0x%x\n",
+	DPRINTK_ISPCTRL("###CM_ICLKEN_CAM = 0x%x\n",
 					omap_readl(OMAP3_CM_ICLKEN_CAM));
-	DPRINTK_ISPCTRL("###CM_CLKSEL_CAM=0x%x\n",
+	DPRINTK_ISPCTRL("###CM_CLKSEL_CAM = 0x%x\n",
 					omap_readl(OMAP3_CM_CLKSEL_CAM));
-	DPRINTK_ISPCTRL("###CM_AUTOIDLE_CAM=0x%x\n",
+	DPRINTK_ISPCTRL("###CM_AUTOIDLE_CAM = 0x%x\n",
 					omap_readl(OMAP3_CM_AUTOIDLE_CAM));
-	DPRINTK_ISPCTRL("###CM_CLKEN_PLL[18:16] should be 0x7, = 0x%x\n",
+	DPRINTK_ISPCTRL("###CM_CLKEN_PLL[18 : 16] should be 0x7, = 0x%x\n",
 					omap_readl(OMAP3_CM_CLKEN_PLL));
-	DPRINTK_ISPCTRL("###CM_CLKSEL2_PLL[18:8] should be 0x2D, [6:0] should "
-			"be 1 = 0x%x\n", omap_readl(OMAP3_CM_CLKSEL2_PLL));
-	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_HS=0x%x\n",
+	DPRINTK_ISPCTRL("###CM_CLKSEL2_PLL[18 : 8] should be 0x2D, "
+			"[6 : 0] should be 1 = 0x%x\n",
+			omap_readl(OMAP3_CM_CLKSEL2_PLL));
+	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_HS = 0x%x\n",
 					omap_readl(CTRL_PADCONF_CAM_HS));
-	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_XCLKA=0x%x\n",
+	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_XCLKA = 0x%x\n",
 					omap_readl(CTRL_PADCONF_CAM_XCLKA));
-	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D1=0x%x\n",
+	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D1 = 0x%x\n",
 					omap_readl(CTRL_PADCONF_CAM_D1));
-	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D3=0x%x\n",
+	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D3 = 0x%x\n",
 					omap_readl(CTRL_PADCONF_CAM_D3));
-	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D5=0x%x\n",
+	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D5 = 0x%x\n",
 					omap_readl(CTRL_PADCONF_CAM_D5));
-	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D7=0x%x\n",
+	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D7 = 0x%x\n",
 					omap_readl(CTRL_PADCONF_CAM_D7));
-	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D9=0x%x\n",
+	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D9 = 0x%x\n",
 					omap_readl(CTRL_PADCONF_CAM_D9));
-	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D11=0x%x\n",
+	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D11 = 0x%x\n",
 					omap_readl(CTRL_PADCONF_CAM_D11));
 }
 EXPORT_SYMBOL(isp_print_status);
diff --git a/drivers/media/video/oldisp/isp.h b/drivers/media/video/oldisp/isp.h
index 8d6cd17..895fd73 100644
--- a/drivers/media/video/oldisp/isp.h
+++ b/drivers/media/video/oldisp/isp.h
@@ -74,7 +74,7 @@
 #define NUM_ISP_CAPTURE_FORMATS 	(sizeof(isp_formats) /\
 							sizeof(isp_formats[0]))
 #define ISP_WORKAROUND 1
-#define ISP_BUFFER_MAX_SIZE (1024 * 1024 * 10)
+#define ISP_BUFFER_MAX_SIZE (1024 * 1024 * 16)
 #define ISP_BUFFER_MAX_PAGES (ISP_BUFFER_MAX_SIZE / ISPMMU_PAGE_SIZE)
 
 #define NR_PAGES(x, y)		((((y + x - 1) & PAGE_MASK) >> PAGE_SHIFT) - \
@@ -364,10 +364,13 @@ void __exit isp_hist_cleanup(void);
 void __exit isp_resizer_cleanup(void);
 void __exit isp_af_exit(void);
 
-struct page **map_user_memory_to_kernel(unsigned long addr, u32 size, u32 *nr_pages_mapped);
+struct page **map_user_memory_to_kernel(unsigned long addr, u32 size,
+		u32 *nr_pages_mapped);
 void unmap_user_memory_from_kernel(struct page **pages, int nr_pages);
 
 int isp_run_resizer(void *userdata);
 int isp_run_preview(void *userdata);
 
+int isp_lsc_workaround_enabled(void);
+
 #endif	/* OMAP_ISP_TOP_H */
diff --git a/drivers/media/video/oldisp/ispccdc.c b/drivers/media/video/oldisp/ispccdc.c
index 044e247..d8c8654 100644
--- a/drivers/media/video/oldisp/ispccdc.c
+++ b/drivers/media/video/oldisp/ispccdc.c
@@ -47,6 +47,8 @@ static unsigned long fpc_table_add_m;
  * @ccdcout_h: CCDC output height.
  * @ccdcin_w: CCDC input width.
  * @ccdcin_h: CCDC input height.
+ * @ccdcin_wstart: CCDC input horizontal offset due to color order.
+ * @ccdcin_hstart: CCDC input vertical offset due to color order.
  * @ccdcin_woffset: CCDC input horizontal offset.
  * @ccdcin_hoffset: CCDC input vertical offset.
  * @crop_w: Crop width.
@@ -68,6 +70,8 @@ static struct isp_ccdc {
 	u32 ccdcout_h;
 	u32 ccdcin_w;
 	u32 ccdcin_h;
+	u8 ccdcin_wstart;
+	u8 ccdcin_hstart;
 	u32 ccdcin_woffset;
 	u32 ccdcin_hoffset;
 	u32 crop_w;
@@ -142,6 +146,22 @@ static struct isp_reg ispccdc_reg_list[] = {
 };
 
 /**
+ * isp_lsc_isr - LSC prefetch error interrupt handling.
+ **/
+void isp_lsc_isr(unsigned long status, void  *arg1, void *arg2)
+{
+	unsigned long irqflags = 0;
+
+	if (status & LSC_PRE_ERR) {
+		spin_lock_irqsave(&ispccdc_obj.ispccdc_lock, irqflags);
+		ispccdc_enable_lsc(0);
+		ispccdc_enable_lsc(1);
+		spin_unlock_irqrestore(&ispccdc_obj.ispccdc_lock, irqflags);
+		/* printk(KERN_ERR "isp_sr: LSC_PRE_ERR \n"); */
+	}
+}
+
+/**
  * omap34xx_isp_ccdc_config - Sets CCDC configuration from userspace
  * @userspace_add: Structure containing CCDC configuration sent from userspace.
  *
@@ -282,8 +302,8 @@ int omap34xx_isp_ccdc_config(void *userspace_add)
 			ispccdc_enable_lsc(1);
 		} else if ((ISP_ABS_CCDC_CONFIG_LSC & ccdc_struct->update) ==
 						ISP_ABS_CCDC_CONFIG_LSC) {
-				ispccdc_enable_lsc(0);
-				ccdc_use_lsc = 0;
+			ispccdc_enable_lsc(0);
+			ccdc_use_lsc = 0;
 		}
 		mutex_lock(&ispccdc_obj.ispccdc_mutex);
 		if ((ISP_ABS_TBL_LSC & ccdc_struct->update)
@@ -299,18 +319,22 @@ int omap34xx_isp_ccdc_config(void *userspace_add)
 						"Cannot allocate\
 						memory for \
 						gain tables \n");
-					mutex_unlock(&ispccdc_obj.ispccdc_mutex);
+					mutex_unlock(
+						&ispccdc_obj.ispccdc_mutex);
 					return -ENOMEM;
 				}
 				lsc_ispmmu_addr = ispmmu_map(
-					virt_to_phys((u8 *)ALIGN_TO(lsc_gain_table, 0x1000)),
+					virt_to_phys((u8 *)ALIGN_TO(
+						lsc_gain_table,
+						0x1000)),
 					lsc_config.size);
 				omap_writel(lsc_ispmmu_addr,
 					ISPCCDC_LSC_TABLE_BASE);
 				lsc_initialized = 1;
 				size_mismatch = 0;
 			}
-			if (copy_from_user((u8 *)ALIGN_TO(lsc_gain_table, 0x1000),
+			if (copy_from_user((u8 *)ALIGN_TO(lsc_gain_table,
+				0x1000),
 				(ccdc_struct->lsc), lsc_config.size)) {
 				mutex_unlock(&ispccdc_obj.ispccdc_mutex);
 				goto copy_from_user_err;
@@ -371,7 +395,7 @@ int ispccdc_request(void)
 							ISPCTRL_CCDC_CLK_EN |
 							ISPCTRL_SBL_WR1_RAM_EN,
 							ISP_CTRL);
-	omap_writel((omap_readl(ISPCCDC_CFG)) | ISPCCDC_CFG_VDLC, ISPCCDC_CFG);
+	omap_writel((omap_readl(ISPCCDC_CFG) | ISPCCDC_CFG_VDLC), ISPCCDC_CFG);
 	spin_unlock(&ispccdc_obj.ispccdc_lock);
 	return 0;
 }
@@ -479,20 +503,40 @@ void ispccdc_enable_lsc(u8 enable)
 		return;
 
 	if (enable) {
-		omap_writel(omap_readl(ISP_CTRL) | ISPCTRL_SBL_SHARED_RPORTB |
-					ISPCTRL_SBL_RD_RAM_EN, ISP_CTRL);
-		omap_writel(omap_readl(ISPCCDC_LSC_CONFIG) | 0x1,
-							ISPCCDC_LSC_CONFIG);
+		omap_writel((omap_readl(ISP_CTRL) | (ISPCTRL_SBL_SHARED_RPORTB |
+					ISPCTRL_SBL_RD_RAM_EN)), ISP_CTRL);
+		omap_writel((omap_readl(ISPCCDC_LSC_CONFIG) | 0x1),
+			ISPCCDC_LSC_CONFIG);
 		ispccdc_obj.lsc_en = 1;
 	} else {
-		omap_writel(omap_readl(ISPCCDC_LSC_CONFIG) & 0xFFFE,
-							ISPCCDC_LSC_CONFIG);
+		omap_writel((omap_readl(ISPCCDC_LSC_CONFIG) & ~0x1),
+			ISPCCDC_LSC_CONFIG);
+		omap_writel((omap_readl(ISP_CTRL) &
+					~(ISPCTRL_SBL_SHARED_RPORTB |
+					ISPCTRL_SBL_RD_RAM_EN)), ISP_CTRL);
 		ispccdc_obj.lsc_en = 0;
 	}
 }
 EXPORT_SYMBOL(ispccdc_enable_lsc);
 
 /**
+ * ispccdc_set_crop_offset_dynamic - Store the component order as component offset.
+ * @raw_fmt: Input data component order.
+ *
+ * Turns the component order into a horizontal & vertical offset and store
+ * offsets to be used later.
+ **/
+void ispccdc_set_crop_offset_dynamic(struct ispccdc_color_offset offset)
+{
+	printk(KERN_INFO "ipsccdc crop offset dyn(%d)\n", offset.offsetcode);
+	if (offset.offsetcode > ISPCCDC_INPUT_FMT_GB_RG)
+		offset.offsetcode = 0;
+	ispccdc_set_crop_offset(offset.offsetcode);
+
+}
+EXPORT_SYMBOL(ispccdc_set_crop_offset_dynamic);
+
+/**
  * ispccdc_set_crop_offset - Store the component order as component offset.
  * @raw_fmt: Input data component order.
  *
@@ -503,22 +547,26 @@ void ispccdc_set_crop_offset(enum ispccdc_raw_fmt raw_fmt)
 {
 	switch (raw_fmt) {
 	case ISPCCDC_INPUT_FMT_GR_BG:
-		ispccdc_obj.ccdcin_woffset = 1;
-		ispccdc_obj.ccdcin_hoffset = 0;
+		ispccdc_obj.ccdcin_wstart = 1;
+		ispccdc_obj.ccdcin_hstart = 0;
 		break;
 	case ISPCCDC_INPUT_FMT_BG_GR:
-		ispccdc_obj.ccdcin_woffset = 1;
-		ispccdc_obj.ccdcin_hoffset = 1;
+		ispccdc_obj.ccdcin_wstart = 1;
+		ispccdc_obj.ccdcin_hstart = 1;
 		break;
 	case ISPCCDC_INPUT_FMT_RG_GB:
-		ispccdc_obj.ccdcin_woffset = 0;
-		ispccdc_obj.ccdcin_hoffset = 0;
+		ispccdc_obj.ccdcin_wstart = 0;
+		ispccdc_obj.ccdcin_hstart = 0;
 		break;
 	case ISPCCDC_INPUT_FMT_GB_RG:
-		ispccdc_obj.ccdcin_woffset = 0;
-		ispccdc_obj.ccdcin_hoffset = 1;
+		ispccdc_obj.ccdcin_wstart = 0;
+		ispccdc_obj.ccdcin_hstart = 1;
 		break;
 	}
+	DPRINTK_ISPCCDC("ispccdc_crop_offset(%d)\n", raw_fmt);
+
+	ispccdc_obj.ccdcin_woffset = ispccdc_obj.ccdcin_wstart;
+	ispccdc_obj.ccdcin_hoffset = ispccdc_obj.ccdcin_hstart;
 }
 EXPORT_SYMBOL(ispccdc_set_crop_offset);
 
@@ -540,8 +588,10 @@ EXPORT_SYMBOL(ispccdc_set_crop_offset);
  **/
 void ispccdc_config_crop(u32 left, u32 top, u32 height, u32 width)
 {
-	ispccdc_obj.ccdcin_woffset = left + ((left + 1) % 2);
-	ispccdc_obj.ccdcin_hoffset = top + (top % 2);
+	ispccdc_obj.ccdcin_woffset = left +
+		((left + ispccdc_obj.ccdcin_wstart) % 2);
+	ispccdc_obj.ccdcin_hoffset = top +
+		((top + ispccdc_obj.ccdcin_hstart) % 2);
 
 	ispccdc_obj.crop_w = width - (width % 16);
 	ispccdc_obj.crop_h = height + (height % 2);
@@ -576,7 +626,7 @@ int ispccdc_config_datapath(enum ccdc_input input, enum ccdc_output output)
 	struct ispccdc_syncif syncif;
 	struct ispccdc_bclamp blkcfg;
 
-	u32 colptn = (ISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP0PLC0_SHIFT) |
+   u32 colptn = (ISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP0PLC0_SHIFT) |
 		(ISPCCDC_COLPTN_R_Ye << ISPCCDC_COLPTN_CP0PLC1_SHIFT) |
 		(ISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP0PLC2_SHIFT) |
 		(ISPCCDC_COLPTN_R_Ye << ISPCCDC_COLPTN_CP0PLC3_SHIFT) |
@@ -630,7 +680,7 @@ int ispccdc_config_datapath(enum ccdc_input input, enum ccdc_output output)
 		syn_mode |= ISPCCDC_SYN_MODE_WEN;
 		syn_mode &= ~ISPCCDC_SYN_MODE_EXWEN;
 		spin_lock(&ispccdc_obj.ispccdc_lock);
-		omap_writel((omap_readl(ISPCCDC_CFG)) & ~ISPCCDC_CFG_WENLOG,
+		omap_writel((omap_readl(ISPCCDC_CFG) & ~ISPCCDC_CFG_WENLOG),
 								ISPCCDC_CFG);
 		spin_unlock(&ispccdc_obj.ispccdc_lock);
 		vpcfg.bitshift_sel = BIT11_2;
@@ -658,8 +708,8 @@ int ispccdc_config_datapath(enum ccdc_input input, enum ccdc_output output)
 		syn_mode |= ISPCCDC_SYN_MODE_WEN;
 		/* Generally cam_wen is used with cam_hs, vs signals */
 		syn_mode |= ISPCCDC_SYN_MODE_EXWEN;
-		omap_writel((omap_readl(ISPCCDC_CFG))
-			| ISPCCDC_CFG_WENLOG, ISPCCDC_CFG);
+		omap_writel((omap_readl(ISPCCDC_CFG) |
+			ISPCCDC_CFG_WENLOG), ISPCCDC_CFG);
 		/* Video Port Configuration */
 		vpcfg.bitshift_sel = BIT9_0;
 		vpcfg.freq_sel = PIXCLKBY2;
@@ -775,8 +825,10 @@ int ispccdc_config_datapath(enum ccdc_input input, enum ccdc_output output)
 
 	ispccdc_obj.ccdc_inpfmt = input;
 	ispccdc_obj.ccdc_outfmt = output;
-		ispccdc_print_status();
-		isp_print_status();
+
+	ispccdc_print_status();
+	isp_print_status();
+
 	return 0;
 }
 EXPORT_SYMBOL(ispccdc_config_datapath);
@@ -1283,6 +1335,7 @@ int ispccdc_try_size(u32 input_w, u32 input_h, u32 *output_w, u32 *output_h)
 			*output_w -= (*output_w % 16);
 			*output_w += 16;
 		}
+      *output_h -= ispccdc_obj.ccdcin_hstart;
 	}
 
 	ispccdc_obj.ccdcout_w = *output_w;
@@ -1339,12 +1392,32 @@ int ispccdc_config_size(u32 input_w, u32 input_h, u32 output_w, u32 output_h)
 			((ispccdc_obj.ccdcin_h-ispccdc_obj.ccdcin_hoffset) <<
 					ISPCCDC_FMT_VERT_FMTLNV_SHIFT),
 					ISPCCDC_FMT_VERT);
+
+	#ifdef CONFIG_VIDEO_OMAP3_HP3A
+		omap_writel(ispccdc_obj.ccdcin_woffset
+						<< ISPCCDC_HORZ_INFO_SPH_SHIFT
+						| ((ispccdc_obj.ccdcout_w - 1)
+						<< ISPCCDC_HORZ_INFO_NPH_SHIFT),
+						ISPCCDC_HORZ_INFO);
+		omap_writel(ispccdc_obj.ccdcin_hoffset
+				<< ISPCCDC_VERT_START_SLV0_SHIFT,
+				ISPCCDC_VERT_START);
+		omap_writel((ispccdc_obj.ccdcout_h - 1) <<
+						ISPCCDC_VERT_LINES_NLV_SHIFT,
+						ISPCCDC_VERT_LINES);
+		ispccdc_config_outlineoffset(ispccdc_obj.ccdcout_w * 2, 0, 0);
+	#else
+		omap_writel(ISPCCDC_HORZ_INFO_RESET, ISPCCDC_HORZ_INFO);
+		omap_writel(0, ISPCCDC_VERT_START);
+		omap_writel(0, ISPCCDC_VERT_LINES);
+	#endif
+
 		omap_writel((ispccdc_obj.ccdcout_w <<
 					ISPCCDC_VP_OUT_HORZ_NUM_SHIFT) |
 					(ispccdc_obj.ccdcout_h <<
 					ISPCCDC_VP_OUT_VERT_NUM_SHIFT),
 					ISPCCDC_VP_OUT);
-		omap_writel((((ispccdc_obj.ccdcout_h - 25) &
+		omap_writel((((ispccdc_obj.ccdcout_h - 1) &
 					ISPCCDC_VDINT_0_MASK) <<
 					ISPCCDC_VDINT_0_SHIFT) |
 					((50 & ISPCCDC_VDINT_1_MASK) <<
@@ -1385,16 +1458,18 @@ int ispccdc_config_size(u32 input_w, u32 input_h, u32 output_w, u32 output_h)
 					((50 & ISPCCDC_VDINT_1_MASK) <<
 					ISPCCDC_VDINT_1_SHIFT), ISPCCDC_VDINT);
 	} else if (ispccdc_obj.ccdc_outfmt == CCDC_OTHERS_VP_MEM) {
-		omap_writel((1 << ISPCCDC_FMT_HORZ_FMTSPH_SHIFT) |
+		omap_writel((ispccdc_obj.ccdcin_woffset <<
+					ISPCCDC_FMT_HORZ_FMTSPH_SHIFT) |
 					(ispccdc_obj.ccdcin_w <<
 					ISPCCDC_FMT_HORZ_FMTLNH_SHIFT),
 					ISPCCDC_FMT_HORZ);
-		omap_writel((0 << ISPCCDC_FMT_VERT_FMTSLV_SHIFT) |
+		omap_writel((ispccdc_obj.ccdcin_hoffset <<
+					ISPCCDC_FMT_VERT_FMTSLV_SHIFT) |
 					((ispccdc_obj.ccdcin_h) <<
 					ISPCCDC_FMT_VERT_FMTLNV_SHIFT),
 					ISPCCDC_FMT_VERT);
-		omap_writel((ispccdc_obj.ccdcout_w
-					<< ISPCCDC_VP_OUT_HORZ_NUM_SHIFT) |
+		omap_writel((ispccdc_obj.ccdcout_w <<
+					ISPCCDC_VP_OUT_HORZ_NUM_SHIFT) |
 					(ispccdc_obj.ccdcout_h <<
 					ISPCCDC_VP_OUT_VERT_NUM_SHIFT),
 					ISPCCDC_VP_OUT);
@@ -1405,17 +1480,19 @@ int ispccdc_config_size(u32 input_w, u32 input_h, u32 output_w, u32 output_h)
 					ISPCCDC_HORZ_INFO_NPH_SHIFT),
 					ISPCCDC_HORZ_INFO);
 */
-		omap_writel(1 << ISPCCDC_HORZ_INFO_SPH_SHIFT |
+		omap_writel(ispccdc_obj.ccdcin_woffset <<
+					ISPCCDC_HORZ_INFO_SPH_SHIFT |
 					((ispccdc_obj.ccdcout_w - 1) <<
 					ISPCCDC_HORZ_INFO_NPH_SHIFT),
 					ISPCCDC_HORZ_INFO);
-		omap_writel(0 << ISPCCDC_VERT_START_SLV0_SHIFT,
+		omap_writel(ispccdc_obj.ccdcin_hoffset <<
+					ISPCCDC_VERT_START_SLV0_SHIFT,
 					ISPCCDC_VERT_START);
 		omap_writel((ispccdc_obj.ccdcout_h - 1) <<
 					ISPCCDC_VERT_LINES_NLV_SHIFT,
 					ISPCCDC_VERT_LINES);
 		ispccdc_config_outlineoffset(ispccdc_obj.ccdcout_w * 2, 0, 0);
-		omap_writel((((ispccdc_obj.ccdcout_h - 25) &
+		omap_writel((((ispccdc_obj.ccdcout_h - 1) &
 					ISPCCDC_VDINT_0_MASK) <<
 					ISPCCDC_VDINT_0_SHIFT) |
 					((50 & ISPCCDC_VDINT_1_MASK) <<
@@ -1423,12 +1500,14 @@ int ispccdc_config_size(u32 input_w, u32 input_h, u32 output_w, u32 output_h)
 	} else if (ispccdc_obj.ccdc_outfmt == CCDC_OTHERS_LSC_MEM) {
 		/* Added by MMS */
 		/* Start with 1 pixel apart */
-		omap_writel((1 << ISPCCDC_FMT_HORZ_FMTSPH_SHIFT)
+		omap_writel((ispccdc_obj.ccdcin_woffset <<
+				ISPCCDC_FMT_HORZ_FMTSPH_SHIFT)
 				| (ispccdc_obj.ccdcin_w
 				<< ISPCCDC_FMT_HORZ_FMTLNH_SHIFT),
 				ISPCCDC_FMT_HORZ);
 
-		omap_writel((0 << ISPCCDC_FMT_VERT_FMTSLV_SHIFT)
+		omap_writel((ispccdc_obj.ccdcin_hoffset <<
+				ISPCCDC_FMT_VERT_FMTSLV_SHIFT)
 				| ((ispccdc_obj.ccdcin_h)
 				<< ISPCCDC_FMT_VERT_FMTLNV_SHIFT),
 				ISPCCDC_FMT_VERT);
@@ -1450,7 +1529,7 @@ int ispccdc_config_size(u32 input_w, u32 input_h, u32 output_w, u32 output_h)
 		/*Configure the HSIZE_OFF with output buffer width*/
 
 		ispccdc_config_outlineoffset((ispccdc_obj.ccdcout_w * 2), 0, 0);
-		omap_writel((((ispccdc_obj.ccdcout_h - 25)
+		omap_writel((((ispccdc_obj.ccdcout_h - 1)
 				& ISPCCDC_VDINT_0_MASK)
 				<< ISPCCDC_VDINT_0_SHIFT)
 				| (((50) &  ISPCCDC_VDINT_1_MASK)
@@ -1564,15 +1643,18 @@ void ispccdc_enable(u8 enable)
 	if (enable) {
 		if (ccdc_use_lsc && !ispccdc_obj.lsc_en &&
 			((ispccdc_obj.ccdc_inpfmt == CCDC_RAW) ||
-			(ispccdc_obj.ccdc_inpfmt == CCDC_RAW_PATTERN)))
+			(ispccdc_obj.ccdc_inpfmt == CCDC_RAW_PATTERN))) {
 			ispccdc_enable_lsc(1);
-			omap_writel(omap_readl(ISPCCDC_PCR) | (ISPCCDC_PCR_EN),
+		}
+		omap_writel(CCDC_VD0|CCDC_VD1, ISP_IRQ0STATUS);
+		omap_writel(omap_readl(ISPCCDC_PCR) | (ISPCCDC_PCR_EN),
 								ISPCCDC_PCR);
 	} else {
 		omap_writel(omap_readl(ISPCCDC_PCR) & ~(ISPCCDC_PCR_EN),
 								ISPCCDC_PCR);
 	}
-
+	/* write sync */
+	omap_readl(ISPCCDC_PCR);
 }
 EXPORT_SYMBOL(ispccdc_enable);
 
diff --git a/drivers/media/video/oldisp/ispccdc.h b/drivers/media/video/oldisp/ispccdc.h
index a7d1aa5..b0a9068 100644
--- a/drivers/media/video/oldisp/ispccdc.h
+++ b/drivers/media/video/oldisp/ispccdc.h
@@ -215,6 +215,9 @@ void ispccdc_set_wenlog(u32 wenlog);
 
 void ispccdc_set_dcsub(u32 dcsub);
 
+void ispccdc_set_crop_offset_dynamic(struct ispccdc_color_offset offset);
+
 void ispccdc_set_crop_offset(enum ispccdc_raw_fmt);
 
+void isp_lsc_isr(unsigned long status, void *arg1, void *arg2);
 #endif		/* OMAP_ISP_CCDC_H */
diff --git a/drivers/media/video/oldisp/ispcsi2.c b/drivers/media/video/oldisp/ispcsi2.c
index 2e25858..b7218eb 100644
--- a/drivers/media/video/oldisp/ispcsi2.c
+++ b/drivers/media/video/oldisp/ispcsi2.c
@@ -47,6 +47,15 @@ static bool update_ctrl;
 static bool uses_videoport;
 
 /**
+ * isp_csia_isr - CSIA interrupt handling.
+ **/
+void isp_csia_isr(unsigned long status, void *arg1, void *arg2)
+{
+	if (status & CSIA)
+		isp_csi2_isr();
+}
+
+/**
  * isp_csi2_complexio_lanes_config - Configuration of CSI2 ComplexIO lanes.
  * @reqcfg: Pointer to structure containing desired lane configuration
  *
@@ -1808,8 +1817,15 @@ void isp_csi2_isr(void)
 	if (csi2_irqstatus & ISPCSI2_IRQSTATUS_ECC_CORRECTION_IRQ)
 		printk(KERN_DEBUG "CSI2: ECC correction done\n");
 
+#if defined(CONFIG_VIDEO_MIPI_DLI_TEST)
+	if (csi2_irqstatus & ISPCSI2_IRQSTATUS_ECC_NO_CORRECTION_IRQ) {
+		printk(KERN_ERR "CSI2: ECC correction failed\n");
+		ecc_counter++;
+	}
+#else
 	if (csi2_irqstatus & ISPCSI2_IRQSTATUS_ECC_NO_CORRECTION_IRQ)
 		printk(KERN_ERR "CSI2: ECC correction failed\n");
+#endif
 
 	if (csi2_irqstatus & ISPCSI2_IRQSTATUS_COMPLEXIO2_ERR_IRQ)
 		printk(KERN_ERR "CSI2: ComplexIO #2 failed\n");
diff --git a/drivers/media/video/oldisp/ispcsi2.h b/drivers/media/video/oldisp/ispcsi2.h
index 3cd366a..853a32e 100644
--- a/drivers/media/video/oldisp/ispcsi2.h
+++ b/drivers/media/video/oldisp/ispcsi2.h
@@ -177,6 +177,11 @@ struct isp_csi2_cfg_update {
 	struct isp_csi2_ctrl_cfg_update ctrl;
 };
 
+#if defined(CONFIG_VIDEO_MIPI_DLI_TEST)
+/*Counters for MIPI DLI.*/
+extern unsigned long ecc_counter;
+#endif
+
 int isp_csi2_complexio_lanes_config(struct isp_csi2_lanes_cfg *reqcfg);
 int isp_csi2_complexio_lanes_update(bool force_update);
 int isp_csi2_complexio_lanes_count(int cnt);
@@ -232,6 +237,7 @@ void isp_csi2_isr(void);
 int isp_csi2_reset(void);
 void isp_csi2_enable(int enable);
 void isp_csi2_regdump(void);
+void isp_csia_isr(unsigned long status, void *arg1, void *arg2);
 
 #endif	/* OMAP_ISP_CSI2_H */
 
diff --git a/drivers/media/video/oldisp/ispmmu.c b/drivers/media/video/oldisp/ispmmu.c
index c937bba..56ceef4 100644
--- a/drivers/media/video/oldisp/ispmmu.c
+++ b/drivers/media/video/oldisp/ispmmu.c
@@ -478,6 +478,7 @@ dma_addr_t ispmmu_map_pages(struct page **pages, int page_nr)
 	u32 pd, p_addr;
 	u32 *l2_table;
 	u32 page_index = 0;
+	dma_addr_t ret_addr;
 
 	DPRINTK_ISPMMU("map_pages: page_nr (number of pages) = %d\n", page_nr);
 
@@ -529,8 +530,11 @@ dma_addr_t ispmmu_map_pages(struct page **pages, int page_nr)
 	DPRINTK_ISPMMU("mapped to ISP virtual address 0x%x\n",
 		(u32)((idx << 20) + (p_addr & (PAGE_SIZE - 1))));
 
+	down(&ispmmu_mutex);
 	omap_writel(1, ISPMMU_GFLUSH);
-	return (dma_addr_t)((idx<<20) + (p_addr & (PAGE_SIZE - 1)));
+	up(&ispmmu_mutex);
+	ret_addr = (dma_addr_t)((idx<<20) + (p_addr & (PAGE_SIZE - 1)));
+	return ret_addr;
 
 release_mem:
 	for (; i >= 0; i--) {
@@ -576,6 +580,7 @@ int ispmmu_unmap(dma_addr_t v_addr)
 		return -EINVAL;
 	}
 
+	down(&ispmmu_mutex);
 	while (((*(ttb + idx)) & (ISPMMU_L1D_TYPE_MASK <<
 						ISPMMU_L1D_TYPE_SHIFT)) ==
 						(ISPMMU_L1D_TYPE_PAGE <<
@@ -583,13 +588,12 @@ int ispmmu_unmap(dma_addr_t v_addr)
 		*(ttb + idx) = (ISPMMU_L1D_TYPE_FAULT <<
 						ISPMMU_L1D_TYPE_SHIFT);
 		free_l2_page_table(l2p_table_addr[idx]);
-		l2p_table_addr[idx++] = 0;
-		if (!(idx % ISPMMU_REGION_ENTRIES_NR)) {
+		l2p_table_addr[idx] = 0;
+		if (!((++idx) % ISPMMU_REGION_ENTRIES_NR)) {
 			DPRINTK_ISPMMU("Do not exceed this 32M region\n");
 			break;
 		}
 	}
-	down(&ispmmu_mutex);
 	omap_writel(1, ISPMMU_GFLUSH);
 	up(&ispmmu_mutex);
 
diff --git a/drivers/media/video/oldisp/ispmmu.h b/drivers/media/video/oldisp/ispmmu.h
index 265ebb9..6560249 100644
--- a/drivers/media/video/oldisp/ispmmu.h
+++ b/drivers/media/video/oldisp/ispmmu.h
@@ -68,7 +68,7 @@
  * to keep track of these 16 L2 page table's status.
  */
 #define L2P_TABLE_SIZE			1024
-#define L2P_TABLE_NR 			62 /* Currently supports 4*5MP shots */
+#define L2P_TABLE_NR 			80
 #define L2P_TABLES_SIZE 		(L2P_TABLE_SIZE * L2P_TABLE_NR)
 
 /* Extra memory allocated to get ttb aligned on 16KB */
diff --git a/drivers/media/video/oldisp/isppreview.c b/drivers/media/video/oldisp/isppreview.c
index ac47153..716d294 100644
--- a/drivers/media/video/oldisp/isppreview.c
+++ b/drivers/media/video/oldisp/isppreview.c
@@ -460,30 +460,29 @@ int omap34xx_isp_tables_update(struct isptables_update *isptables_struct)
 {
 	int ctr;
 
+	mutex_lock(&ispprev_obj.ispprev_mutex);
 	if ((ISP_ABS_TBL_NF & isptables_struct->flag) == ISP_ABS_TBL_NF) {
 		NF_enable = 1;
 		params->features |= (PREV_NOISE_FILTER);
 		if ((ISP_ABS_TBL_NF & isptables_struct->update) ==
 							ISP_ABS_TBL_NF) {
-			mutex_lock(&ispprev_obj.ispprev_mutex);
+			spin_lock(&ispprev_obj.ispprev_lock);
+
 			if (copy_from_user(&prev_nf_t, (struct ispprev_nf *)
 						(isptables_struct->prev_nf),
 						sizeof(struct ispprev_nf))) {
-				mutex_unlock(&ispprev_obj.ispprev_mutex);
+				spin_unlock(&ispprev_obj.ispprev_lock);
 				goto err_copy_from_user;
 			}
 
-			mutex_unlock(&ispprev_obj.ispprev_mutex);
+			spin_unlock(&ispprev_obj.ispprev_lock);
 
-			spin_lock(&ispprev_obj.ispprev_lock);
 			if (ispprev_obj.stream_on == 0) {
 				NF_update = 0;
 				isppreview_config_noisefilter(prev_nf_t);
 				isppreview_enable_noisefilter(NF_enable);
 			} else
 				NF_update = 1;
-
-			spin_unlock(&ispprev_obj.ispprev_lock);
 		} else
 			NF_update = 0;
 	} else {
@@ -498,15 +497,16 @@ int omap34xx_isp_tables_update(struct isptables_update *isptables_struct)
 
 	if ((ISP_ABS_TBL_REDGAMMA & isptables_struct->update) ==
 							ISP_ABS_TBL_REDGAMMA) {
-		mutex_lock(&ispprev_obj.ispprev_mutex);
-		if (copy_from_user(redgamma_table, isptables_struct->red_gamma,
+		spin_lock(&ispprev_obj.ispprev_lock);
+
+		if (copy_from_user(redgamma_table,
+						isptables_struct->red_gamma,
 						sizeof(redgamma_table))) {
 			RG_update = 0;
-			mutex_unlock(&ispprev_obj.ispprev_mutex);
+			spin_unlock(&ispprev_obj.ispprev_lock);
 			goto err_copy_from_user;
 		}
-		mutex_unlock(&ispprev_obj.ispprev_mutex);
-		spin_lock(&ispprev_obj.ispprev_lock);
+
 		if (ispprev_obj.stream_on == 0) {
 			omap_writel(ISPPRV_TBL_ADDR_RED_G_START,
 							ISPPRV_SET_TBL_ADDR);
@@ -517,24 +517,20 @@ int omap34xx_isp_tables_update(struct isptables_update *isptables_struct)
 			RG_update = 1;
 
 		spin_unlock(&ispprev_obj.ispprev_lock);
-	} else {
-		spin_lock(&ispprev_obj.ispprev_lock);
-		RG_update = 0;
-		spin_unlock(&ispprev_obj.ispprev_lock);
 	}
 
 	if ((ISP_ABS_TBL_GREENGAMMA & isptables_struct->update) ==
 						ISP_ABS_TBL_GREENGAMMA) {
-		mutex_lock(&ispprev_obj.ispprev_mutex);
+		spin_lock(&ispprev_obj.ispprev_lock);
+
 		if (copy_from_user(greengamma_table,
 						isptables_struct->green_gamma,
 						sizeof(greengamma_table))) {
 			GG_update = 0;
-			mutex_unlock(&ispprev_obj.ispprev_mutex);
+			spin_unlock(&ispprev_obj.ispprev_lock);
 			goto err_copy_from_user;
 		}
-		mutex_unlock(&ispprev_obj.ispprev_mutex);
-		spin_lock(&ispprev_obj.ispprev_lock);
+
 		if (ispprev_obj.stream_on == 0) {
 			omap_writel(ISPPRV_TBL_ADDR_GREEN_G_START,
 							ISPPRV_SET_TBL_ADDR);
@@ -545,24 +541,20 @@ int omap34xx_isp_tables_update(struct isptables_update *isptables_struct)
 			GG_update = 1;
 
 		spin_unlock(&ispprev_obj.ispprev_lock);
-	} else {
-		spin_lock(&ispprev_obj.ispprev_lock);
-		GG_update = 0;
-		spin_unlock(&ispprev_obj.ispprev_lock);
 	}
 
 	if ((ISP_ABS_TBL_BLUEGAMMA & isptables_struct->update) ==
 					ISP_ABS_TBL_BLUEGAMMA) {
-		mutex_lock(&ispprev_obj.ispprev_mutex);
-		if (copy_from_user(bluegamma_table, (isptables_struct->
-						blue_gamma),
+		spin_lock(&ispprev_obj.ispprev_lock);
+
+		if (copy_from_user(bluegamma_table,
+						(isptables_struct->blue_gamma),
 						sizeof(bluegamma_table))) {
 			BG_update = 0;
-			mutex_unlock(&ispprev_obj.ispprev_mutex);
+			spin_unlock(&ispprev_obj.ispprev_lock);
 			goto err_copy_from_user;
 		}
-		mutex_unlock(&ispprev_obj.ispprev_mutex);
-		spin_lock(&ispprev_obj.ispprev_lock);
+
 		if (ispprev_obj.stream_on == 0) {
 			omap_writel(ISPPRV_TBL_ADDR_BLUE_G_START,
 							ISPPRV_SET_TBL_ADDR);
@@ -573,15 +565,14 @@ int omap34xx_isp_tables_update(struct isptables_update *isptables_struct)
 			BG_update = 1;
 
 		spin_unlock(&ispprev_obj.ispprev_lock);
-	} else {
-		spin_lock(&ispprev_obj.ispprev_lock);
-		BG_update = 0;
-		spin_unlock(&ispprev_obj.ispprev_lock);
 	}
 
+	mutex_unlock(&ispprev_obj.ispprev_mutex);
 	return 0;
 
 err_copy_from_user:
+	mutex_unlock(&ispprev_obj.ispprev_mutex);
+
 	printk(KERN_ERR "Preview Tables:Copy From User Error");
 	return -EINVAL;
 }
@@ -632,29 +623,29 @@ void isppreview_config_shadow_registers()
 	}
 
 	if (GG_update) {
+		GG_update = 0;
 		omap_writel(ISPPRV_TBL_ADDR_GREEN_G_START, ISPPRV_SET_TBL_ADDR);
 
 		for (ctr = 0; ctr < ISP_GAMMA_TABLE_SIZE; ctr++) {
 			omap_writel(greengamma_table[ctr],
 							ISPPRV_SET_TBL_DATA);
 		}
-		GG_update = 0;
 	}
 
 	if (RG_update) {
+		RG_update = 0;
 		omap_writel(ISPPRV_TBL_ADDR_RED_G_START, ISPPRV_SET_TBL_ADDR);
 
 		for (ctr = 0; ctr < ISP_GAMMA_TABLE_SIZE; ctr++)
 			omap_writel(redgamma_table[ctr], ISPPRV_SET_TBL_DATA);
-		RG_update = 0;
 	}
 
 	if (BG_update) {
+		BG_update = 0;
 		omap_writel(ISPPRV_TBL_ADDR_BLUE_G_START, ISPPRV_SET_TBL_ADDR);
 
 		for (ctr = 0; ctr < ISP_GAMMA_TABLE_SIZE; ctr++)
 			omap_writel(bluegamma_table[ctr], ISPPRV_SET_TBL_DATA);
-		BG_update = 0;
 	}
 
 	if (NF_update && NF_enable) {
@@ -756,6 +747,8 @@ int isppreview_config_datapath(enum preview_input input,
 		pcr &= ~(ISPPRV_PCR_SOURCE);
 		pcr &= ~(ISPPRV_PCR_ONESHOT);
 		ispprev_obj.prev_inpfmt = PRV_RAW_CCDC;
+		isppreview_set_inaddr(0);
+		isppreview_config_inlineoffset(0);
 		break;
 	case PRV_RAW_MEM:
 		pcr |= ISPPRV_PCR_SOURCE;
@@ -1001,14 +994,10 @@ void isppreview_config_hmed(struct ispprev_hmed prev_hmed)
 	u32 odddist = 0;
 	u32 evendist = 0;
 
-	if (prev_hmed.odddist == 1)
-		odddist = ~ISPPRV_HMED_ODDDIST;
-	else
+	if (prev_hmed.odddist == 2)
 		odddist = ISPPRV_HMED_ODDDIST;
 
-	if (prev_hmed.evendist == 1)
-		evendist = ~ISPPRV_HMED_EVENDIST;
-	else
+	if (prev_hmed.evendist == 2)
 		evendist = ISPPRV_HMED_EVENDIST;
 
 	spin_lock(&ispprev_obj.ispprev_lock);
diff --git a/drivers/media/video/oldisp/ispreg.h b/drivers/media/video/oldisp/ispreg.h
index f7622d8..1b973a6 100644
--- a/drivers/media/video/oldisp/ispreg.h
+++ b/drivers/media/video/oldisp/ispreg.h
@@ -125,7 +125,7 @@
 #define CM_ICLKEN_CAM_EN		0x1
 #define CM_FCLKEN_CAM_EN		0x1
 
-#define CM_CAM_MCLK_HZ			432000000
+#define CM_CAM_MCLK_HZ		(OMAP_MCAM_SRC_CLK/OMAP_MCAM_SRC_DIV)
 
 /* ISP Submodules offset */
 
@@ -304,6 +304,8 @@
 #define ISPCCDC_PRGODD1			0x480BC690
 #define ISPCCDC_VP_OUT			0x480BC694
 
+#define ISPCCDC_HORZ_INFO_RESET		0x00000100
+
 #define ISPCCDC_LSC_CONFIG		0x480BC698
 #define ISPCCDC_LSC_INITIAL		0x480BC69C
 #define ISPCCDC_LSC_TABLE_BASE		0x480BC6A0
@@ -933,8 +935,9 @@
 #define ISPRSZ_PID_CID_SHIFT			8
 #define ISPRSZ_PID_TID_SHIFT			16
 
-#define ISPRSZ_PCR_ENABLE			0x5
+#define ISPRSZ_PCR_ENABLE			1
 #define ISPRSZ_PCR_BUSY				(1 << 1)
+#define ISPRSZ_PCR_ONESHOT			(1 << 2)
 
 #define ISPRSZ_CNT_HRSZ_SHIFT			0
 #define ISPRSZ_CNT_HRSZ_MASK			0x3FF
diff --git a/drivers/media/video/oldisp/ispresizer.c b/drivers/media/video/oldisp/ispresizer.c
index 221a21c..a8b3428 100644
--- a/drivers/media/video/oldisp/ispresizer.c
+++ b/drivers/media/video/oldisp/ispresizer.c
@@ -29,9 +29,7 @@
 #include "ispreg.h"
 #include "ispresizer.h"
 
-#if ISP_WORKAROUND
 dma_addr_t buff_addr_lsc_wa;
-#endif
 
 static u8 need_to_write_filter_coefs = {0};
 
@@ -262,6 +260,9 @@ int ispresizer_config_datapath(enum ispresizer_input input)
 	u32 cnt = 0;
 	DPRINTK_ISPRESZ("ispresizer_config_datapath()+\n");
 	ispres_obj.resinput = input;
+
+	mutex_lock(&ispres_obj.ispres_mutex);
+	cnt = omap_readl(ISPRSZ_CNT);
 	switch (input) {
 	case RSZ_OTFLY_YUV:
 		cnt &= ~ISPRSZ_CNT_INPTYP;
@@ -282,13 +283,17 @@ int ispresizer_config_datapath(enum ispresizer_input input)
 		return -EINVAL;
 	}
 
-	mutex_lock(&ispres_obj.ispres_mutex);
-	omap_writel(omap_readl(ISPRSZ_CNT) | cnt, ISPRSZ_CNT);
+	omap_writel(cnt, ISPRSZ_CNT);
 	mutex_unlock(&ispres_obj.ispres_mutex);
 
+	/* Use bilinear interpolation for upsampling per TRM */
+	if (ispres_obj.outputwidth > ispres_obj.inputwidth)
+		ispresizer_enable_cbilin(1);
+	else
+		ispresizer_enable_cbilin(0);
+
 	ispresizer_config_ycpos(0);
 	ispresizer_config_filter_coef(&ispreszdefcoef);
-	ispresizer_enable_cbilin(0);
 	ispresizer_config_luma_enhance(&ispreszdefaultyenh);
 	DPRINTK_ISPRESZ("ispresizer_config_datapath()-\n");
 	return 0;
@@ -341,7 +346,7 @@ int ispresizer_try_size(u32 *input_width, u32 *input_height, u32 *output_w,
 	input_h = *input_height;
 
 	if (input_w < 32 || input_h < 32) {
-		DPRINTK_ISPCCDC("ISP_ERR: RESIZER cannot handle input width"
+		DPRINTK_ISPRESZ("ISP_ERR: RESIZER cannot handle input width"
 				" less than 32 pixels or height less than"
 				" 32\n");
 		return -EINVAL;
@@ -387,8 +392,6 @@ int ispresizer_try_size(u32 *input_width, u32 *input_height, u32 *output_w,
 		if (rsz < MINIMUM_RESIZE_VALUE) {
 			rsz = MINIMUM_RESIZE_VALUE;
 			*output_h = (((input_h - 4) * 256) / rsz) + 1;
-			printk(KERN_INFO "%s: using output_h %d instead\n",
-			       __func__, *output_h);
 		}
 	} else {
 		rsz = rsz_7;
@@ -397,8 +400,6 @@ int ispresizer_try_size(u32 *input_width, u32 *input_height, u32 *output_w,
 		if (rsz > MAXIMUM_RESIZE_VALUE) {
 			rsz = MAXIMUM_RESIZE_VALUE;
 			*output_h = (((input_h - 7) * 256) / rsz) + 1;
-			printk(KERN_INFO "%s: using output_h %d instead\n",
-			       __func__, *output_h);
 		}
 	}
 
@@ -428,8 +429,6 @@ int ispresizer_try_size(u32 *input_width, u32 *input_height, u32 *output_w,
 			rsz = MAXIMUM_RESIZE_VALUE;
 			*output_w = (((input_w - 7) * 256) / rsz) + 1;
 			*output_w = (*output_w + 0xf) & 0xfffffff0;
-			printk(KERN_INFO "%s: using output_w %d instead\n",
-			       __func__, *output_w);
 		}
 	} else {
 		rsz = rsz_4;
@@ -437,8 +436,6 @@ int ispresizer_try_size(u32 *input_width, u32 *input_height, u32 *output_w,
 			rsz = MINIMUM_RESIZE_VALUE;
 			*output_w = (((input_w - 4) * 256) / rsz) + 1;
 			*output_w = (*output_w + 0xf) & 0xfffffff0;
-			printk(KERN_INFO "%s: using output_w %d instead\n",
-			       __func__, *output_w);
 		}
 	}
 
@@ -504,14 +501,15 @@ int ispresizer_config_size(u32 input_w, u32 input_h, u32 output_w,
 		return -EINVAL;
 	}
 
-#if ISP_WORKAROUND
-	buff_addr_lsc_wa = isp_buf_get();
-	if (buff_addr_lsc_wa) {
-		/* Set Resizer input address and offset adderss */
-		ispresizer_set_inaddr(buff_addr_lsc_wa);
-		ispresizer_config_inlineoffset(omap_readl(ISPPRV_WADD_OFFSET));
+	if (isp_lsc_workaround_enabled()) {
+		buff_addr_lsc_wa = isp_buf_get();
+		if (buff_addr_lsc_wa) {
+			/* Set Resizer input address and offset adderss */
+			ispresizer_set_inaddr(buff_addr_lsc_wa);
+			ispresizer_config_inlineoffset
+				(omap_readl(ISPPRV_WADD_OFFSET));
+		}
 	}
-#endif
 
 	/* mutex_lock(&ispres_obj.ispres_mutex); */
 
@@ -522,19 +520,18 @@ int ispresizer_config_size(u32 input_w, u32 input_h, u32 output_w,
 						ISPRSZ_CNT_VSTPH_SHIFT),
 						ISPRSZ_CNT);
 
-#if ISP_WORKAROUND
-	omap_writel((0x00 <<	ISPRSZ_IN_START_HORZ_ST_SHIFT) |
-					(0x00 <<
-					ISPRSZ_IN_START_VERT_ST_SHIFT),
-					ISPRSZ_IN_START);
-
-#else
-	omap_writel(((ispres_obj.ipwd_crop * 2) <<
-					ISPRSZ_IN_START_HORZ_ST_SHIFT) |
-					(ispres_obj.ipht_crop <<
-					ISPRSZ_IN_START_VERT_ST_SHIFT),
-					ISPRSZ_IN_START);
-#endif
+	if (isp_lsc_workaround_enabled()) {
+		omap_writel((0x00 <<	ISPRSZ_IN_START_HORZ_ST_SHIFT) |
+						(0x00 <<
+						ISPRSZ_IN_START_VERT_ST_SHIFT),
+						ISPRSZ_IN_START);
+	} else {
+		omap_writel(((ispres_obj.ipwd_crop * 2) <<
+						ISPRSZ_IN_START_HORZ_ST_SHIFT) |
+						(ispres_obj.ipht_crop <<
+						ISPRSZ_IN_START_VERT_ST_SHIFT),
+						ISPRSZ_IN_START);
+	}
 
 	omap_writel((ispres_obj.inputwidth << ISPRSZ_IN_SIZE_HORZ_SHIFT) |
 						(ispres_obj.inputheight <<
@@ -560,8 +557,8 @@ int ispresizer_config_size(u32 input_w, u32 input_h, u32 output_w,
 						ISPRSZ_CNT);
 
 	/* mutex_unlock(&ispres_obj.ispres_mutex); */
-
-    ispresizer_write_filter_coef();
+	if (!ispresizer_busy())
+		ispresizer_write_filter_coef();
 
     ispresizer_config_outlineoffset(output_w*2);
     DPRINTK_ISPRESZ("ispresizer_config_size()-\n");
@@ -577,13 +574,22 @@ EXPORT_SYMBOL(ispresizer_config_size);
  **/
 void ispresizer_enable(u8 enable)
 {
-	int val;
+	u32 val;
 	DPRINTK_ISPRESZ("+ispresizer_enable()+\n");
-	if (enable)
-		val = (((omap_readl(ISPRSZ_PCR)) & 0x2) | ISPRSZ_PCR_ENABLE);
-	else
-		val = (omap_readl(ISPRSZ_PCR) & ~ISPRSZ_PCR_ENABLE);
-	omap_writel(val, ISPRSZ_PCR);
+	val = omap_readl(ISPRSZ_PCR);
+	if (enable) {
+		if (!(val & ISPRSZ_PCR_ENABLE)) {
+			omap_writel(RESZ_DONE, ISP_IRQ0STATUS);
+			omap_writel((val | ISPRSZ_PCR_ONESHOT |
+				ISPRSZ_PCR_ENABLE), ISPRSZ_PCR);
+			/* write sync */
+			omap_readl(ISPRSZ_PCR);
+		}
+	} else if (val & ISPRSZ_PCR_ENABLE) {
+		omap_writel((val & ~ISPRSZ_PCR_ENABLE), ISPRSZ_PCR);
+		/* write sync */
+		omap_readl(ISPRSZ_PCR);
+	}
 	DPRINTK_ISPRESZ("+ispresizer_enable()-\n");
 }
 EXPORT_SYMBOL(ispresizer_enable);
@@ -727,78 +733,74 @@ void ispresizer_write_filter_coef(void)
 	int i, j;
 	DPRINTK_ISPRESZ("ispresizer_write_filter_coef\n");
 
-	if (ispresizer_busy() == 0) {
-		if (ispres_obj.h_resz <= MID_RESIZE_VALUE) {
-			j = 0;
-			for (i = 0; i < 16; i++) {
+	if (ispres_obj.h_resz <= MID_RESIZE_VALUE) {
+		j = 0;
+		for (i = 0; i < 16; i++) {
+			omap_writel((ispres_obj.coeflist.
+					h_filter_coef_4tap[j] <<
+					ISPRSZ_HFILT10_COEF0_SHIFT) |
+					(ispres_obj.coeflist.
+					h_filter_coef_4tap[j + 1] <<
+					ISPRSZ_HFILT10_COEF1_SHIFT),
+					ISPRSZ_HFILT10 + (i * 0x04));
+			j += 2;
+		}
+	} else {
+		j = 0;
+		for (i = 0; i < 16; i++) {
+			if ((i + 1) % 4 == 0) {
 				omap_writel((ispres_obj.coeflist.
-						h_filter_coef_4tap[j] <<
-						ISPRSZ_HFILT10_COEF0_SHIFT) |
-						(ispres_obj.coeflist.
-						h_filter_coef_4tap[j + 1] <<
-						ISPRSZ_HFILT10_COEF1_SHIFT),
-						ISPRSZ_HFILT10 + (i * 0x04));
+					h_filter_coef_7tap[j] <<
+					ISPRSZ_HFILT10_COEF0_SHIFT),
+					ISPRSZ_HFILT10 + (i * 0x04));
+				j += 1;
+			} else {
+				omap_writel((ispres_obj.coeflist.
+					h_filter_coef_7tap[j] <<
+					ISPRSZ_HFILT10_COEF0_SHIFT) |
+					(ispres_obj.coeflist.
+					h_filter_coef_7tap[j+1] <<
+					ISPRSZ_HFILT10_COEF1_SHIFT),
+					ISPRSZ_HFILT10 + (i * 0x04));
 				j += 2;
 			}
-		} else {
-			j = 0;
-			for (i = 0; i < 16; i++) {
-				if ((i + 1) % 4 == 0) {
-					omap_writel((ispres_obj.coeflist.
-							h_filter_coef_7tap[j] <<
-							ISPRSZ_HFILT10_COEF0_SHIFT),
-							ISPRSZ_HFILT10 + (i * 0x04));
-					j += 1;
-				} else {
-					omap_writel((ispres_obj.coeflist.
-							h_filter_coef_7tap[j] <<
-							ISPRSZ_HFILT10_COEF0_SHIFT) |
-							(ispres_obj.coeflist.
-							h_filter_coef_7tap[j+1] <<
-							ISPRSZ_HFILT10_COEF1_SHIFT),
-							ISPRSZ_HFILT10 + (i * 0x04));
-					j += 2;
-				}
-			}
 		}
-		if (ispres_obj.v_resz <= MID_RESIZE_VALUE) {
-			j = 0;
-			for (i = 0; i < 16; i++) {
+	}
+	if (ispres_obj.v_resz <= MID_RESIZE_VALUE) {
+		j = 0;
+		for (i = 0; i < 16; i++) {
+			omap_writel((ispres_obj.coeflist.
+					v_filter_coef_4tap[j] <<
+					ISPRSZ_VFILT10_COEF0_SHIFT) |
+					(ispres_obj.coeflist.
+					v_filter_coef_4tap[j + 1] <<
+					ISPRSZ_VFILT10_COEF1_SHIFT),
+					ISPRSZ_VFILT10 + (i * 0x04));
+			j += 2;
+		}
+	} else {
+		j = 0;
+		for (i = 0; i < 16; i++) {
+			if ((i + 1) % 4 == 0) {
+				omap_writel((ispres_obj.coeflist.
+					v_filter_coef_7tap[j] <<
+					ISPRSZ_VFILT10_COEF0_SHIFT),
+					ISPRSZ_VFILT10 + (i * 0x04));
+				j += 1;
+			} else {
 				omap_writel((ispres_obj.coeflist.
-						v_filter_coef_4tap[j] <<
-						ISPRSZ_VFILT10_COEF0_SHIFT) |
-						(ispres_obj.coeflist.
-						v_filter_coef_4tap[j + 1] <<
-						ISPRSZ_VFILT10_COEF1_SHIFT),
-						ISPRSZ_VFILT10 + (i * 0x04));
+					v_filter_coef_7tap[j] <<
+					ISPRSZ_VFILT10_COEF0_SHIFT) |
+					(ispres_obj.coeflist.
+					v_filter_coef_7tap[j+1] <<
+					ISPRSZ_VFILT10_COEF1_SHIFT),
+					ISPRSZ_VFILT10 + (i * 0x04));
 				j += 2;
 			}
-		} else {
-			j = 0;
-			for (i = 0; i < 16; i++) {
-				if ((i + 1) % 4 == 0) {
-					omap_writel((ispres_obj.coeflist.
-							v_filter_coef_7tap[j] <<
-							ISPRSZ_VFILT10_COEF0_SHIFT),
-							ISPRSZ_VFILT10 + (i * 0x04));
-					j += 1;
-				} else {
-					omap_writel((ispres_obj.coeflist.
-							v_filter_coef_7tap[j] <<
-							ISPRSZ_VFILT10_COEF0_SHIFT) |
-							(ispres_obj.coeflist.
-							v_filter_coef_7tap[j+1] <<
-							ISPRSZ_VFILT10_COEF1_SHIFT),
-							ISPRSZ_VFILT10 + (i * 0x04));
-					j += 2;
-				}
-			}
 		}
-
-		need_to_write_filter_coefs = 0;
-	} else {
-		DPRINTK_ISPRESZ("Resizer busy when programming filter coefs\n");
 	}
+
+	need_to_write_filter_coefs = 0;
 }
 EXPORT_SYMBOL(ispresizer_write_filter_coef);
 
@@ -813,6 +815,7 @@ int ispresizer_config_inlineoffset(u32 offset)
 	DPRINTK_ISPRESZ("ispresizer_config_inlineoffset()+\n");
 	if (offset%32)
 		return -EINVAL;
+
 	omap_writel(offset << ISPRSZ_SDR_INOFF_OFFSET_SHIFT, ISPRSZ_SDR_INOFF);
 	DPRINTK_ISPRESZ("ispresizer_config_inlineoffset()-\n");
 	return 0;
@@ -830,6 +833,7 @@ int ispresizer_set_inaddr(u32 addr)
 	DPRINTK_ISPRESZ("ispresizer_set_inaddr()+\n");
 	if (addr%32)
 		return -EINVAL;
+
 	omap_writel(addr << ISPRSZ_SDR_INADD_ADDR_SHIFT, ISPRSZ_SDR_INADD);
 	DPRINTK_ISPRESZ("ispresizer_set_inaddr()-\n");
 	return 0;
diff --git a/drivers/media/video/oldomap34xxcam.c b/drivers/media/video/oldomap34xxcam.c
index 39d26db..3bb2e36 100644
--- a/drivers/media/video/oldomap34xxcam.c
+++ b/drivers/media/video/oldomap34xxcam.c
@@ -147,7 +147,10 @@ int omap34xxcam_update_vbq(struct videobuf_buffer *vb)
 	struct isp_af_xtrastats af_xtrastats;
 #endif
 
+#if !defined(CONFIG_VIDEO_OMAP3_HP3A)
 	do_gettimeofday(&vb->ts);
+#endif
+
 	vb->field_count = atomic_add_return(2, &fh->field_count);
 	vb->state = VIDEOBUF_DONE;
 #ifndef CONFIG_VIDEO_OMAP3_HP3A
@@ -376,9 +379,17 @@ static int vidioc_g_fmt_cap(struct file *file, void *fh, struct v4l2_format *f)
 {
 	struct omap34xxcam_fh *ofh = fh;
 	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	struct v4l2_format sensor_format;
 
+	/* Get size_out */
 	mutex_lock(&vdev->mutex);
 	f->fmt.pix = ofh->pix;
+
+	/* Get size_in (sensor pixel format) & save in user defined raw_data
+	   after f->fmt.pix */
+	vidioc_int_g_fmt_cap(vdev->vdev_sensor, &sensor_format);
+	memcpy(f->fmt.raw_data + sizeof(sensor_format.fmt.pix),
+		&sensor_format.fmt.pix, sizeof(sensor_format.fmt.pix));
 	mutex_unlock(&vdev->mutex);
 
 	return 0;
@@ -496,7 +507,8 @@ static int try_pix_parm(struct omap34xxcam_videodev *vdev,
 			 * Select bigger resolution if it's available
 			 * at same fps.
 			 */
-			if (frmi.width > best_pix_in->width
+			if ((frmi.width > best_pix_in->width ||
+				frmi.height > best_pix_in->height)
 			    && FPS_ABS_DIFF(fps, frmi.discrete)
 			    <= FPS_ABS_DIFF(fps, *best_ival))
 				goto do_it_now;
@@ -515,7 +527,7 @@ do_it_now:
 	if (best_pix_in->width == 0)
 		return -EINVAL;
 
-	dev_info(vdev->cam->dev, "w %d, h %d -> w %d, h %d\n",
+	dev_dbg(vdev->cam->dev, "w %d, h %d -> w %d, h %d\n",
 		 best_pix_in->width, best_pix_in->height,
 		 best_pix_out.width, best_pix_out.height);
 
@@ -1040,6 +1052,12 @@ static int vidioc_s_parm(struct file *file, void *fh, struct v4l2_streamparm *a)
 
 	mutex_lock(&vdev->mutex);
 
+	/* If streaming, just change fps, don't try to change resolution */
+	if (vdev->streaming) {
+		rval = vidioc_int_s_parm(vdev->vdev_sensor, a);
+		goto out;
+	}
+
 	vdev->want_timeperframe = a->parm.capture.timeperframe;
 
 	pix_tmp = vdev->want_pix;
@@ -1047,6 +1065,7 @@ static int vidioc_s_parm(struct file *file, void *fh, struct v4l2_streamparm *a)
 	rval = s_pix_parm(vdev, &pix_tmp_sensor, &pix_tmp,
 			  &a->parm.capture.timeperframe);
 
+out:
 	mutex_unlock(&vdev->mutex);
 
 	return rval;
@@ -1196,7 +1215,7 @@ static int vidioc_enum_frameintervals(struct file *file, void *fh,
  * feedback. The request is then passed on to the ISP private IOCTL handler,
  * isp_handle_private()
  */
-static int vidioc_default(struct file *file, void *fh, int cmd, void *arg)
+static long vidioc_default(struct file *file, void *fh, int cmd, void *arg)
 {
 	struct omap34xxcam_fh *ofh = file->private_data;
 	struct omap34xxcam_videodev *vdev = ofh->vdev;
@@ -1287,9 +1306,9 @@ out:
  * @dev: numeric device identifier.
  * @settings: ptr to a sensor settings structure.
  *
- * This request is passed to the sensor driver based on the bit masked flags field of the
- * settings structure. If the sensor does not support the requested operation, an error is
- * returned.
+ * This request is passed to the sensor driver based on the bit masked flags
+ * field of the settings structure. If the sensor does not support the
+ * requested operation, an error is returned.
  *
  * If the requested device id is not valid, -ENODEV is returned.
  */
@@ -1298,6 +1317,7 @@ int omap34xxcam_sensor_settings(int dev, struct cam_sensor_settings *settings)
 	int err = -1;
 	struct omap34xxcam_videodev *vdev = NULL;
 	struct omap34xxcam_device *cam = omap34xxcam;
+	struct v4l2_streamparm a;
 	struct v4l2_control vc;
 	int i;
 
@@ -1313,6 +1333,14 @@ int omap34xxcam_sensor_settings(int dev, struct cam_sensor_settings *settings)
 
 	mutex_lock(&vdev->mutex);
 
+	if ((settings->flags & OMAP34XXCAM_SET_FPS) &&
+		  settings->fps != 0) {
+		a.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		a.parm.capture.timeperframe.numerator = 1;
+		a.parm.capture.timeperframe.denominator = settings->fps;
+		err = vidioc_int_s_parm(vdev->vdev_sensor, &a);
+	}
+
 	if (settings->flags & OMAP34XXCAM_SET_EXPOSURE) {
 		vc.id = V4L2_CID_EXPOSURE;
 		vc.value = settings->exposure;
@@ -1328,7 +1356,13 @@ int omap34xxcam_sensor_settings(int dev, struct cam_sensor_settings *settings)
 	}
 
 update_sensor_exit:
-   vc.id = V4L2_CID_EXPOSURE;
+	a.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	if (vidioc_int_g_parm(vdev->vdev_sensor, &a) == 0) {
+		settings->fps = a.parm.capture.timeperframe.denominator /
+			a.parm.capture.timeperframe.numerator;
+	}
+
+	vc.id = V4L2_CID_EXPOSURE;
 	vc.value = 0;
 	if (vidioc_int_g_ctrl(vdev->vdev_sensor, &vc) == 0)
 		settings->exposure = (u32)vc.value;
diff --git a/drivers/media/video/oldomap34xxcam.h b/drivers/media/video/oldomap34xxcam.h
index 1c9c2fc..de6f16e 100644
--- a/drivers/media/video/oldomap34xxcam.h
+++ b/drivers/media/video/oldomap34xxcam.h
@@ -243,12 +243,14 @@ struct cam_sensor_settings{
 	u16 gain;
 	u16 regs;
 	void *reg_data;
+	u16 fps;
 };
 
 #define	OMAP34XXCAM_SET_EXPOSURE		0x1
 #define	OMAP34XXCAM_SET_GAIN			         0x2
 #define	OMAP34XXCAM_READ_REGS			   0x4
 #define	OMAP34XXCAM_WRITE_REGS			   0x8
+#define	OMAP34XXCAM_SET_FPS			   0x10
 
 #define	OMAP34XXCAM_REG_8BIT			         0x1
 #define	OMAP34XXCAM_REG_16BIT			      0x2
diff --git a/drivers/media/video/omap-vout/omapvout-dss.c b/drivers/media/video/omap-vout/omapvout-dss.c
index f8b420b..25ecc8a 100644
--- a/drivers/media/video/omap-vout/omapvout-dss.c
+++ b/drivers/media/video/omap-vout/omapvout-dss.c
@@ -468,19 +468,46 @@ static int omapvout_dss_perform_vrfb_dma(struct omapvout_device *vout,
 
 		w = vout->crop.width;
 		h = vout->crop.height;
+		if (vrfb->decimate_src) {
+			w = w / 2;
+			h = h / 2;
+		}
 
 		dss_fmt = omapvout_dss_color_mode(vout->pix.pixelformat);
+		bytespp = omapvout_dss_format_bytespp(vout->pix.pixelformat);
+
 		omap_vrfb_setup(&vrfb->ctx[0], vrfb->phy_addr[0],
 				w, h, dss_fmt, rot);
 		omap_vrfb_setup(&vrfb->ctx[1], vrfb->phy_addr[1],
 				w, h, dss_fmt, rot);
-
 		omapvout_dss_calc_offset(vout, vrfb->ctx[0].bytespp,
 				vrfb->ctx[0].xoffset, vrfb->ctx[0].yoffset);
 
-		bytespp = omapvout_dss_format_bytespp(vout->pix.pixelformat);
 		vrfb->en = (w * bytespp) / 4; /* 32 bit ES */
 		vrfb->fn = h;
+
+		if (!vrfb->decimate_src) {
+			/* Maintain the previous settings to reduce risk */
+			vrfb->src_mode = OMAP_DMA_AMODE_POST_INC;
+			vrfb->src_ei = 0;
+			vrfb->src_fi = 0;
+		} else {
+			/* Decimate source frame by 2 */
+
+			/* Need to use double indexed DMA */
+			vrfb->src_mode = OMAP_DMA_AMODE_DOUBLE_IDX;
+			/* Skip every other word */
+			vrfb->src_ei = 4 + 1;
+			/* Skip every other line.
+			 * - Mult width by 2 to get real input frame line
+			 *   width for the skip.
+			 * - Add 4 to account for the trailing word  of the
+			 *   previous line that needs still needs to be
+			 *   skipped.
+			 */
+			vrfb->src_fi = (w * bytespp * 2) + 4 + 1;
+		}
+
 		vrfb->dst_ei = 1;
 		if (fmt == V4L2_PIX_FMT_YUYV || fmt == V4L2_PIX_FMT_UYVY) {
 			vrfb->dst_fi = (OMAP_VRFB_LINE_LEN * bytespp * 2)
@@ -496,9 +523,9 @@ static int omapvout_dss_perform_vrfb_dma(struct omapvout_device *vout,
 
 	omap_set_dma_transfer_params(vrfb->dma_ch, OMAP_DMA_DATA_TYPE_S32,
 				vrfb->en, vrfb->fn, OMAP_DMA_SYNC_ELEMENT,
-				vrfb->dma_id, 0x0);
-	omap_set_dma_src_params(vrfb->dma_ch, 0, OMAP_DMA_AMODE_POST_INC,
-				src_paddr, 0, 0);
+				vrfb->dma_id, 0);
+	omap_set_dma_src_params(vrfb->dma_ch, 0, vrfb->src_mode,
+				src_paddr, vrfb->src_ei, vrfb->src_fi);
 	omap_set_dma_src_burst_mode(vrfb->dma_ch, OMAP_DMA_DATA_BURST_16);
 	omap_set_dma_dest_params(vrfb->dma_ch, 0, OMAP_DMA_AMODE_DOUBLE_IDX,
 				dst_paddr, vrfb->dst_ei, vrfb->dst_fi);
@@ -549,6 +576,11 @@ static int omapvout_dss_update_overlay(struct omapvout_device *vout,
 		o_info.height = vout->crop.height;
 	}
 
+	if (vrfb->decimate_src) { /* Decimate source frame by 2 */
+		o_info.width = o_info.width / 2;
+		o_info.height = o_info.height / 2;
+	}
+
 	o_info.pos_x = vout->win.w.left & ~1;
 	o_info.pos_y = vout->win.w.top & ~1;
 	o_info.out_width = vout->win.w.width;
@@ -570,10 +602,12 @@ static int omapvout_dss_update_overlay(struct omapvout_device *vout,
 		return rc;
 	}
 
+	if (ovly->manager->device->update) {
 	rc = ovly->manager->device->update(ovly->manager->device, 0, 0,
 					vout->disp_width, vout->disp_height);
 	if (rc)
 		DBG("Overlay update failed %d\n", rc);
+	}
 
 	return rc;
 }
@@ -656,7 +690,7 @@ static void omapvout_dss_perform_update(struct work_struct *work)
 		 * is unlocked since the sync may take some time.
 		 */
 		dev = dss->overlay->manager->device;
-		if (dev->sync)
+		if (dev && dev->sync)
 			dev->sync(dev);
 
 		/* Since the mutex was unlocked, it is possible that the DSS
@@ -782,6 +816,7 @@ int omapvout_dss_open(struct omapvout_device *vout, u16 *disp_w, u16 *disp_h)
 	INIT_WORK(&vout->dss->work, omapvout_dss_perform_update);
 
 	vout->dss->enabled = false;
+	vout->dss->vrfb.decimate_src = false;
 
 failed:
 	return rc;
@@ -877,10 +912,12 @@ void omapvout_dss_disable(struct omapvout_device *vout)
 	if (rc)
 		DBG("Overlay manager apply failed %d\n", rc);
 
+	if (ovly->manager->device->update) {
 	rc = ovly->manager->device->update(ovly->manager->device,
 				0, 0, vout->disp_width, vout->disp_height);
 	if (rc)
 		DBG("Display update failed %d\n", rc);
+	}
 }
 
 int omapvout_dss_update(struct omapvout_device *vout)
@@ -906,3 +943,13 @@ int omapvout_dss_update(struct omapvout_device *vout)
 	return 0;
 }
 
+bool omapvout_dss_get_decimate(struct omapvout_device *vout)
+{
+	return vout->dss->vrfb.decimate_src;
+}
+
+void omapvout_dss_set_decimate(struct omapvout_device *vout, bool enable)
+{
+	vout->dss->vrfb.decimate_src = enable;
+}
+
diff --git a/drivers/media/video/omap-vout/omapvout-dss.h b/drivers/media/video/omap-vout/omapvout-dss.h
index dde8eff..b9345d5 100644
--- a/drivers/media/video/omap-vout/omapvout-dss.h
+++ b/drivers/media/video/omap-vout/omapvout-dss.h
@@ -26,8 +26,12 @@ struct omapvout_dss_vrfb {
 	/* VRFB dma config data */
 	u32 en;
 	u32 fn;
+	u32 src_mode;
+	u32 src_ei;
+	u32 src_fi;
 	u32 dst_ei;
 	u32 dst_fi;
+	bool decimate_src;
 
 	/* VRFB dma channel data */
 	int dma_id;
@@ -75,6 +79,8 @@ extern bool omapvout_dss_is_rotation_supported(struct omapvout_device *vout);
 extern int  omapvout_dss_enable(struct omapvout_device *vout);
 extern void omapvout_dss_disable(struct omapvout_device *vout);
 extern int  omapvout_dss_update(struct omapvout_device *vout);
+extern bool omapvout_dss_get_decimate(struct omapvout_device *vout);
+extern void omapvout_dss_set_decimate(struct omapvout_device *vout, bool en);
 
 #endif /* __OMAPVOUT_DSS_H__ */
 
diff --git a/drivers/media/video/omap-vout/omapvout.c b/drivers/media/video/omap-vout/omapvout.c
index a56718f..1b74b7d 100644
--- a/drivers/media/video/omap-vout/omapvout.c
+++ b/drivers/media/video/omap-vout/omapvout.c
@@ -35,6 +35,7 @@
 #include "omapvout-vbq.h"
 #include "omapvout-bp.h"
 
+#define V4L2_CID_PRIVATE_DECIMATE_BY_2		(V4L2_CID_PRIVATE_BASE + 0x921)
 #define MODULE_NAME "omapvout"
 
 /* list of image formats supported by OMAP2 video pipelines */
@@ -70,8 +71,81 @@ const static struct v4l2_fmtdesc omap2_formats[] = {
 
 #define NUM_OUTPUT_FORMATS (sizeof(omap2_formats)/sizeof(omap2_formats[0]))
 
+/* This is a way to allow other components to force a desired rotation.
+ * This will take effect when streaming is next enabled.
+ */
+struct omapvout_override {
+	int dirty;
+	int force_rotation_dirty;
+	int force_rotation_enable;
+	int forced_rotation;
+	int client_rotation;
+};
+
+#define NUM_PLANES (3)
+static struct omapvout_override gOverride[NUM_PLANES];
+
+
+int omapvout_force_rotation(int plane, int enable, int rotation)
+{
+	struct omapvout_override *ovr;
+	int en;
+
+	if (plane < 0 || plane >= NUM_PLANES) {
+		DBG("Invalid plane (%d)\n", plane);
+		return -1;
+	}
+
+	ovr = &gOverride[plane];
+	if (ovr->force_rotation_enable == enable &&
+	    ovr->forced_rotation == rotation)
+		return 0;
+
+	en = (enable) ? 1 : 0;
+	if (en) {
+		if (rotation < 0 || rotation > 3) {
+			DBG("Invalid rotation (%d)\n", rotation);
+			return -1;
+		}
+
+		ovr->forced_rotation = rotation;
+	}
+
+	ovr->force_rotation_dirty = 1;
+	ovr->force_rotation_enable = en;
+	ovr->dirty = 1;
+
+	return 0;
+}
+EXPORT_SYMBOL(omapvout_force_rotation);
+
 /*=== Local Functions ==================================================*/
 
+static void omapvout_chk_overrides(struct omapvout_device *vout)
+{
+	struct omapvout_override *ovr;
+
+	ovr = &gOverride[vout->id];
+
+	if (!ovr->dirty)
+		return;
+
+	if (ovr->force_rotation_dirty) {
+		ovr->force_rotation_dirty = 0;
+		if (ovr->force_rotation_enable) {
+			ovr->client_rotation = vout->rotation;
+			vout->rotation = ovr->forced_rotation;
+		} else {
+			vout->rotation = ovr->client_rotation;
+		}
+		printk("omapvout_chk_overrides/%d/%d/%d\n", \
+			ovr->force_rotation_enable, \
+			ovr->forced_rotation, ovr->client_rotation);
+	}
+
+	ovr->dirty = 0;
+}
+
 static int omapvout_crop_to_size(struct v4l2_rect *rect, int w, int h)
 {
 	struct v4l2_rect try;
@@ -227,6 +301,17 @@ static void omapvout_free_resources(struct omapvout_device *vout)
 	kfree(vout);
 }
 
+#ifdef CONFIG_TVOUT_SHOLEST
+static int video_status;
+void set_video_status(int onoff)
+{
+  video_status = onoff;
+}
+int get_video_status(void)
+{
+  return video_status;
+}
+#endif
 /*=== V4L2 Interface Functions =========================================*/
 
 static int omapvout_open(struct file *file)
@@ -237,6 +322,9 @@ static int omapvout_open(struct file *file)
 
 	DBG("omapvout_open\n");
 
+#ifdef CONFIG_TVOUT_SHOLEST
+  set_video_status(1);
+#endif
 	vout = video_drvdata(file);
 
 	if (vout == NULL) {
@@ -298,6 +386,8 @@ static int omapvout_open(struct file *file)
 
 	vout->mmap_cnt = 0;
 
+	omapvout_chk_overrides(vout);
+
 	mutex_unlock(&vout->mtx);
 
 	file->private_data = vout;
@@ -314,7 +404,9 @@ static int omapvout_release(struct file *file)
 	struct omapvout_device *vout;
 
 	DBG("omapvout_release\n");
-
+#ifdef CONFIG_TVOUT_SHOLEST
+  set_video_status(0);
+#endif
 	vout = video_drvdata(file);
 
 	if (vout == NULL) {
@@ -564,6 +656,8 @@ static int omapvout_vidioc_s_fmt_vid_overlay(struct file *file, void *priv,
 		goto failed;
 	}
 
+	omapvout_chk_overrides(vout);
+
 	rc = omapvout_try_window(vout, win);
 	if (rc != 0)
 		goto failed;
@@ -602,6 +696,8 @@ static int omapvout_vidioc_s_fmt_vid_out(struct file *file, void *priv,
 		goto failed;
 	}
 
+	omapvout_chk_overrides(vout);
+
 	rc = omapvout_try_pixel_format(vout, pix);
 	if (rc != 0)
 		goto failed;
@@ -700,6 +796,8 @@ static int omapvout_vidioc_s_crop(struct file *file, void *priv,
 		goto failed;
 	}
 
+	omapvout_chk_overrides(vout);
+
 	rc = omapvout_try_crop(vout, &rect);
 	if (rc != 0)
 		goto failed;
@@ -785,7 +883,8 @@ static int omapvout_vidioc_qbuf(struct file *file, void *priv,
 	DBG("Q'ing Frame %d\n", b->index);
 
 	mutex_lock(&vout->mtx);
-        rc = videobuf_qbuf(&vout->queue, b);
+	omapvout_chk_overrides(vout);
+	rc = videobuf_qbuf(&vout->queue, b);
 	mutex_unlock(&vout->mtx);
 
 	return rc;
@@ -821,6 +920,8 @@ static int omapvout_vidioc_streamon(struct file *file, void *priv,
 
 	mutex_lock(&vout->mtx);
 
+	omapvout_chk_overrides(vout);
+
 	/* Not sure how else to do this.  We can't truly validate the
 	 * configuration until all of the pieces have been provided, like
 	 * input, output, crop sizes and rotation.  This is the only point
@@ -909,6 +1010,10 @@ static int omapvout_vidioc_g_ctrl(struct file *file, void *priv,
 	case V4L2_CID_BG_COLOR:
 		ctrl->value = vout->bg_color;
 		break;
+	case V4L2_CID_PRIVATE_DECIMATE_BY_2:
+		ctrl->value = (int) omapvout_dss_get_decimate(vout);
+		break;
+
 	default:
 		rc = -EINVAL;
 		break;
@@ -948,6 +1053,11 @@ static int omapvout_vidioc_s_ctrl(struct file *file, void *priv,
 			DBG("Invalid rotation %d\n", v);
 			rc = -ERANGE;
 		}
+		if (rc == 0 && gOverride[vout->id].force_rotation_enable) {
+			gOverride[vout->id].client_rotation = vout->rotation;
+			vout->rotation = gOverride[vout->id].forced_rotation;
+			gOverride[vout->id].force_rotation_dirty = 0;
+		}
 		break;
 	case V4L2_CID_BG_COLOR:
 		if (v < 0 || v > 0xFFFFFF) {
@@ -957,6 +1067,10 @@ static int omapvout_vidioc_s_ctrl(struct file *file, void *priv,
 			vout->bg_color = v;
 		}
 		break;
+	case V4L2_CID_PRIVATE_DECIMATE_BY_2:
+		omapvout_dss_set_decimate(vout, ((v) ? true : false));
+		break;
+
 	default:
 		rc = -EINVAL;
 		break;
@@ -1121,6 +1235,8 @@ static int __init omapvout_probe_device(struct omap_vout_config *cfg,
 
 	vout->id = plane;
 
+	memset(gOverride, 0, sizeof(gOverride));
+
 	return 0;
 
 cleanup:
diff --git a/drivers/media/video/ov8810.c b/drivers/media/video/ov8810.c
new file mode 100644
index 0000000..05822ca
--- /dev/null
+++ b/drivers/media/video/ov8810.c
@@ -0,0 +1,2606 @@
+/*
+ * drivers/media/video/ov8810.c
+ *
+ * ov8810 sensor driver
+ *
+ *
+ * Copyright (C) 2008 Texas Instruments.
+ *
+ * Leverage ov8810.c
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <media/v4l2-int-device.h>
+#include <mach/resource.h>
+#include "ov8810.h"
+#include "oldomap34xxcam.h"
+#include "oldisp/isp.h"
+#include "oldisp/ispcsi2.h"
+
+#define OV8810_DRIVER_NAME  "ov8810"
+#define MOD_NAME "OV8810: "
+
+#define I2C_M_WR 0
+#define CPU_CLK_LOCK	 1
+#define CPU_CLK_UNLOCK   0 
+
+/* OV8810 clock related parameters */
+struct ov8810_clk_freqs {
+	u32 xclk;
+	u32 sclk;
+	u32 pclk;
+	u32 mipiclk;
+};
+
+struct ov8810_sensor_id {
+	u16 revision;
+	u16 model;
+	u16 mfr;
+};
+
+/**
+ * struct ov8810_sensor_params
+ */
+struct ov8810_sensor_params {
+	u32 line_time;  /* usec, q8 */
+	u16 gain_frame_delay;
+	u16 exp_time_frame_delay;
+};
+
+struct ov8810_flash_params {
+	u16 flash_time;
+	u8 flash_type;
+	u8 shutter_type;
+};
+
+struct ov8810_shutter_params {
+	u32 exp_time;
+	u16 delay_time;
+	u16 type;
+};
+
+struct ov8810_exp_params {
+	u32 exp_time;
+	u32 line_time;
+	u16 coarse_int_tm;
+	u16 analog_gain;
+	u16 digital_gain;
+	u16 min_exp_time;
+	u32 fps_max_exp_time;
+	u32 abs_max_exp_time;
+	u16 min_linear_gain;
+	u16 max_linear_gain;
+};
+
+/**
+ * struct ov8810_sensor - main structure for storage of sensor information
+ * @pdata: access functions and data for platform level information
+ * @v4l2_int_device: V4L2 device structure structure
+ * @i2c_client: iic client device structure
+ * @pix: V4L2 pixel format information structure
+ * @timeperframe: time per frame expressed as V4L fraction
+ * @isize: base image size
+ * @ver: ov8810 chip version
+ * @width: configured width
+ * @height: configuredheight
+ * @vsize: vertical size for the image
+ * @hsize: horizontal size for the image
+ * @crop_rect: crop rectangle specifying the left,top and width and height
+ * @state:
+ * @frame: image frame parameters
+*/
+struct ov8810_sensor {
+	struct device *dev;
+	const struct ov8810_platform_data *pdata;
+	struct v4l2_int_device *v4l2_int_device;
+	struct i2c_client *i2c_client;
+	struct v4l2_pix_format pix;
+	struct v4l2_fract timeperframe;
+	int isize;
+	int fps;
+	unsigned long width;
+	unsigned long height;
+	unsigned long vsize;
+	unsigned long hsize;
+	struct v4l2_rect crop_rect;
+	int state;
+	bool resuming;
+	bool streaming;
+	struct ov8810_clk_freqs freq;
+	struct ov8810_sensor_id sensor_id;
+	struct ov8810_flash_params flash;
+	struct ov8810_shutter_params shutter;
+	struct ov8810_exp_params exposure;
+	enum ov8810_orientation orientation;
+};
+
+static struct ov8810_sensor ov8810 = {
+	.timeperframe = {
+		.numerator = 1,
+		.denominator = 15,
+	},
+	.sensor_id = {
+		.revision = 0,
+		.model = 0,
+		.mfr = 0
+	},
+	.state = SENSOR_NOT_DETECTED,
+	.freq = {
+		.xclk = OV8810_XCLK_MIN,
+	},
+	.shutter = {
+		.type = ROLLING_SHUTTER_TYPE,
+	},
+	.orientation = OV8810_HORZ_FLIP_ONLY,
+};
+
+static struct i2c_driver ov8810sensor_i2c_driver;
+static enum v4l2_power current_power_state = V4L2_POWER_OFF;
+
+/* List of image formats supported by OV8810 sensor */
+const static struct v4l2_fmtdesc ov8810_formats[] = {
+	{
+		.description	= "RAW10",
+		.pixelformat	= V4L2_PIX_FMT_SGRBG10,
+	},
+	{
+		.description	= "Walking 1's pattern",
+		.pixelformat	= V4L2_PIX_FMT_W1S_PATT,
+	}
+};
+
+#define NUM_CAPTURE_FORMATS (sizeof(ov8810_formats) / sizeof(ov8810_formats[0]))
+
+/* register initialization tables for ov8810 */
+#define OV8810_REG_TERM 0xFFFF	/* terminating list entry for reg */
+#define OV8810_VAL_TERM 0xFF	/* terminating list entry for val */
+
+const static struct ov8810_reg ov8810_strobe_ready_reg[] = {
+    {0x30e8 , 0x00},
+    {OV8810_REG_TERM, OV8810_VAL_TERM},
+};
+
+const static struct ov8810_reg ov8810_strobe_trigger_reg[] = {
+    {0x30e7 , 0x03},
+    {0x30e8 , 0x80},
+    {OV8810_REG_TERM, OV8810_VAL_TERM},
+};
+
+static struct ov8810_sensor_settings sensor_settings[] = {
+
+	/* SIZE_125K */
+		/* 2-lane, RAW 10, PCLK = 13.5MHz, MIPI_CLK = 67.5MHz,
+		MIPI_PCLK = 1.25x13.5 = 16.9MHz,
+		MCLK = 27Mhz, FPS = 30, Blanking = 10msec */
+	{
+		.clk = {
+			.pll_mult = 44,
+			.pll_pre_div = 2,
+			.vt_sys_div = 2,
+			.op_sys_div = 8,
+			.op_pix_div = 4,
+			.div8 = 5,
+			.rp_clk_div = 4,
+		},
+		.frame = {
+			.frame_len_lines_min = 433,
+			.line_len_pck_min = 4576,
+			.x_addr_start = 0,
+			.x_addr_end = 3359,
+			.y_addr_start = 0,
+			.y_addr_end = 2463,
+			.x_output_size = 408,
+			.y_output_size = 306,
+			.v_subsample = 8,
+			.h_subsample = 8,
+			.min_time_per_frame = {
+				.numerator = 1,
+				.denominator = 30,
+			},
+		},
+		.mipi = {
+			.num_data_lanes = 2,
+			.hs_settle_lower = 5,
+			.hs_settle_upper = 14,
+		},
+	},
+
+	/* SIZE_500K */
+		/* 2-lane, RAW 10, PCLK = 29.7MHz, MIPI_CLK = 148.5MHz,
+		   MIPI_PCLK = 1.25x29.7 = 37.1MHz,
+		   MCLK = 27Mhz, FPS = 30, Blanking = 10msec */
+	{
+		.clk = {
+			.pll_mult = 44,
+			.pll_pre_div = 2,
+			.vt_sys_div = 2,
+			.op_sys_div = 4,
+			.op_pix_div = 4,
+			.div8 = 5,
+			.rp_clk_div = 2,
+		},
+		.frame = {
+			.frame_len_lines_min = 845,
+			.line_len_pck_min = 2344,
+			.x_addr_start = 0,
+			.x_addr_end = 3311,
+			.y_addr_start = 0,
+			.y_addr_end = 2463,
+			.x_output_size = 816,
+			.y_output_size = 612,
+			.v_subsample = 4,
+			.h_subsample = 4,
+			.min_time_per_frame = {
+				.numerator = 1,
+				.denominator = 30,
+			},
+		},
+		.mipi = {
+			.num_data_lanes = 2,
+				.hs_settle_lower = 7,
+				.hs_settle_upper = 21,
+		},
+	},
+
+	/* SIZE_1_5M */
+		/* 2-lane, RAW 10, PCLK = 75.6MHz, MIPI_CLK = 312MHz,
+		   MIPI_PCLK = 1.25x75.6 = 94.5MHz,
+		   MCLK = 27Mhz, FPS = 26, Blanking = 10ms */
+	{
+		.clk = {
+			.pll_mult = 56,
+			.pll_pre_div = 2,
+			.vt_sys_div = 2,
+			.op_sys_div = 2,
+			.op_pix_div = 4,
+			.div8 = 5,
+			.rp_clk_div = 1,
+		},
+		.frame = {
+			.frame_len_lines_min = 1244,
+			.line_len_pck_min = 2336,
+			.x_addr_start = 4,
+			.x_addr_end = 3291,
+			.y_addr_start = 302,
+			.y_addr_end = 2161,
+			.x_output_size = 1632,
+			.y_output_size = 918,
+			.v_subsample = 2,
+			.h_subsample = 2,
+			.min_time_per_frame = {
+				.numerator = 1,
+				.denominator = 26,
+			},
+		},
+		.mipi = {
+			.num_data_lanes = 2,
+				.hs_settle_lower = 14,
+				.hs_settle_upper = 44,
+		},
+	},
+
+	/* SIZE_2M */
+		/* 2-lane, RAW 10, PCLK = 75.6MHz, MIPI_CLK = 312MHz,
+		   MIPI_PCLK = 1.25x75.6 = 94.5MHz,
+		   MCLK = 27Mhz, FPS = 21, Blanking = 10ms */
+	{
+		.clk = {
+			.pll_mult = 56,
+			.pll_pre_div = 2,
+			.vt_sys_div = 2,
+			.op_sys_div = 2,
+			.op_pix_div = 4,
+			.div8 = 5,
+			.rp_clk_div = 1,
+		},
+		.frame = {
+			.frame_len_lines_min = 1552,
+			.line_len_pck_min = 2320,
+			.x_addr_start = 0,
+			.x_addr_end = 3295,
+			.y_addr_start = 0,
+			.y_addr_end = 2463,
+			.x_output_size = 1632,
+			.y_output_size = 1224,
+			.v_subsample = 2,
+			.h_subsample = 2,
+			.min_time_per_frame = {
+				.numerator = 1,
+				.denominator = 21,
+			},
+		},
+		.mipi = {
+			.num_data_lanes = 2,
+				.hs_settle_lower = 14,
+				.hs_settle_upper = 44,
+		},
+	},
+
+	/* SIZE_8M */
+		/* 2-lane, RAW, 10, PCLK = 75.6MHz, MIPI_CLK = 312MHz,
+		   MIPI_PCLK = 1.25x75.6 = 94.5MHz,
+		   MCLK = 27Mhz, FPS = 7.685, Blanking = 2ms */
+	{
+		.clk = {
+			.pll_mult = 56,
+			.pll_pre_div = 2,
+			.vt_sys_div = 2,
+			.op_sys_div = 2,
+			.op_pix_div = 4,
+			.div8 = 5,
+			.rp_clk_div = 1,
+		},
+		.frame = {
+			.frame_len_lines_min = 2484,
+			.line_len_pck_min = 3960,
+			.x_addr_start = 0,
+			.x_addr_end = 3295,
+			.y_addr_start = 0,
+			.y_addr_end = 2463,
+			.x_output_size = 3264,
+			.y_output_size = 2448,
+			.v_subsample = 1,
+			.h_subsample = 1,
+			.min_time_per_frame = {
+				.numerator = 3,
+				.denominator = 24,
+			},
+		},
+		.mipi = {
+			.num_data_lanes = 2,
+				.hs_settle_lower = 14,
+				.hs_settle_upper = 44,
+		},
+	}
+};
+
+/*
+ * struct vcontrol - Video controls
+ * @v4l2_queryctrl: V4L2 VIDIOC_QUERYCTRL ioctl structure
+ * @current_value: current value of this control
+ */
+static struct vcontrol {
+	struct v4l2_queryctrl qc;
+	int current_value;
+} video_control[] = {
+	{
+		{
+			.id = V4L2_CID_EXPOSURE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Exposure",
+			.minimum = 0,
+			.maximum = -1,
+			.step = EXPOSURE_STEP,
+			.default_value = DEF_EXPOSURE,
+		},
+		.current_value = DEF_EXPOSURE,
+	},
+	{
+		{
+			.id = V4L2_CID_GAIN,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Analog Gain",
+			.minimum = OV8810_MIN_LINEAR_GAIN,
+			.maximum = OV8810_MAX_LINEAR_GAIN,
+			.step = LINEAR_GAIN_STEP,
+			.default_value = DEF_LINEAR_GAIN,
+		},
+		.current_value = DEF_LINEAR_GAIN,
+	},
+	{
+		{
+			.id = V4L2_CID_PRIVATE_COLOR_BAR,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Color Bar",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 0,
+			.default_value = 0,
+		},
+		.current_value = 0,
+	},
+	{
+		{
+			.id = V4L2_CID_PRIVATE_FLASH_NEXT_FRAME,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Flash On Next Frame",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 0,
+			.default_value = 0,
+		},
+		.current_value = 0,
+	},
+	{
+		{
+			.id = V4L2_CID_PRIVATE_ORIENTATION,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Orientation",
+			.minimum = OV8810_NO_HORZ_FLIP_OR_VERT_FLIP,
+			.maximum = OV8810_HORZ_FLIP_AND_VERT_FLIP,
+			.step = 0,
+			.default_value = OV8810_HORZ_FLIP_ONLY,
+		},
+		.current_value = OV8810_HORZ_FLIP_ONLY,
+	},
+	{
+		{
+			.id = V4L2_CID_PRIVATE_LENS_CORRECTION,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Lens Correction",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 0,
+			.default_value = 0,
+		},
+		.current_value = 0,
+	},
+	{
+		{
+			.id = V4L2_CID_PRIVATE_SENSOR_ID_REQ,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Sensor ID",
+			.minimum = 0,
+			.maximum = -1,
+			.step = 0,
+			.default_value = 0,
+		},
+		.current_value = 0,
+	},
+	{
+		{
+			.id = V4L2_CID_PRIVATE_SHUTTER_PARAMS,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Shutter Params",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.current_value = 0,
+	},
+	{
+		{
+			.id = V4L2_CID_PRIVATE_START_MECH_SHUTTER_CAPTURE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Start Mech Shutter Capture",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.current_value = 0,
+	},
+	{
+		{
+			.id = V4L2_CID_PRIVATE_SENSOR_REG_REQ,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Sensor Register",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.current_value = 0,
+	},
+	{
+		{
+			.id = V4L2_CID_PRIVATE_SENSOR_PARAMS_REQ,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Sensor Params",
+			.minimum = 0,
+			.maximum = -1,
+			.step = 0,
+			.default_value = 0,
+		},
+		.current_value = 0,
+	},
+};
+
+struct i2c_client *ov8810_i2c_client;
+
+/*
+ * find_vctrl - Finds the requested ID in the video control structure array
+ * @id: ID of control to search the video control array.
+ *
+ * Returns the index of the requested ID from the control structure array
+ */
+static int find_vctrl(int id)
+{
+	int i = 0;
+
+	if (id < V4L2_CID_BASE)
+		return -EDOM;
+
+	for (i = (ARRAY_SIZE(video_control) - 1); i >= 0; i--)
+		if (video_control[i].qc.id == id)
+			break;
+	if (i < 0)
+		i = -EINVAL;
+	return i;
+}
+
+/*
+ * Read a value from a register in ov8810 sensor device.
+ * The value is returned in 'val'.
+ * Returns zero if successful, or non-zero otherwise.
+ */
+static int ov8810_read_reg(struct i2c_client *client, u16 data_length, u16 reg,
+								u32 *val)
+{
+	int err = 0;
+	struct i2c_msg msg[1];
+	unsigned char data[4];
+
+	if (!client->adapter)
+		return -ENODEV;
+
+	msg->addr = client->addr;
+	msg->flags = I2C_M_WR;
+	msg->len = 2;
+	msg->buf = data;
+
+	/* High byte goes out first */
+	data[0] = (u8) (reg >> 8);
+	data[1] = (u8) (reg & 0xff);
+
+	err = i2c_transfer(client->adapter, msg, 1);
+	if (err < 0) {
+		msleep(5);
+		err = i2c_transfer(client->adapter, msg, 1);
+	}
+
+	if (err >= 0) {
+		mdelay(3);
+		msg->flags = I2C_M_RD;
+		msg->len = data_length;
+		err = i2c_transfer(client->adapter, msg, 1);
+	}
+	if (err >= 0) {
+		*val = 0;
+		/* High byte comes first */
+		if (data_length == 1)
+			*val = data[0];
+		else if (data_length == 2)
+			*val = data[1] + (data[0] << 8);
+		else
+			*val = data[3] + (data[2] << 8) +
+				(data[1] << 16) + (data[0] << 24);
+		return 0;
+	}
+	printk(KERN_ERR "OV8810: read from offset 0x%x error %d\n", reg, err);
+	return err;
+}
+
+/* Write a value to a register in ov8810 sensor device.
+ * @client: i2c driver client structure.
+ * @reg: Address of the register to read value from.
+ * @val: Value to be written to a specific register.
+ * Returns zero if successful, or non-zero otherwise.
+ */
+int ov8810_write_reg(struct i2c_client *client, u16 reg, u8 val)
+{
+	int err = 0;
+	struct i2c_msg msg[1];
+	unsigned char data[3];
+	int retries = 5;
+
+	if (!client->adapter)
+		return -ENODEV;
+
+	msg->addr = client->addr;
+	msg->flags = I2C_M_WR;
+	msg->len = 3;
+	msg->buf = data;
+
+	/* high byte goes out first */
+	data[0] = (u8) (reg >> 8);
+	data[1] = (u8) (reg & 0xff);
+	data[2] = val;
+
+	do {
+		err = i2c_transfer(client->adapter, msg, 1);
+		if (err >= 0) {
+			udelay(50);
+			return 0;
+		}
+		msleep(5);
+	} while ((--retries) > 0);
+
+	return err;
+}
+
+/*
+ * Initialize a list of ov8810 registers.
+ * The list of registers is terminated by the pair of values
+ * {OV8810_REG_TERM, OV8810_VAL_TERM}.
+ * @client: i2c driver client structure.
+ * @reglist[]: List of address of the registers to write data.
+ * Returns zero if successful, or non-zero otherwise.
+ */
+static int ov8810_write_regs(struct i2c_client *client,
+					const struct ov8810_reg reglist[])
+{
+	int err = 0;
+	const struct ov8810_reg *next = reglist;
+
+	while (!((next->reg == OV8810_REG_TERM)
+		&& (next->val == OV8810_VAL_TERM))) {
+		err = ov8810_write_reg(client, next->reg, next->val);
+		udelay(100);
+		if (err)
+			return err;
+		next++;
+	}
+	return 0;
+}
+
+/**
+ * ov8810_set_exposure_time - sets exposure time per input value
+ * @exp_time: exposure time to be set on device
+ * @s: pointer to standard V4L2 device structure
+ * @lvc: pointer to V4L2 exposure entry in video_controls array
+ *
+ * If the requested exposure time is not within the allowed limits, the
+ * exposure time is forced to the limit value. The HW
+ * is configured to use the new exposure time, and the
+ * video_control[] array is updated with the new current value.
+ * The function returns 0 upon success.  Otherwise an error code is
+ * returned.
+ */
+int ov8810_set_exposure_time(u32 exp_time, struct v4l2_int_device *s,
+				struct vcontrol *lvc, enum image_size_ov isize)
+{
+	/* Inputs exp_time in usec */
+	u16 coarse_int_tm;
+	int err = 0;
+	struct ov8810_sensor *sensor = s->priv;
+	struct i2c_client *client = sensor->i2c_client;
+	u32 line_time_q8 = sensor->exposure.line_time;
+
+	if ((current_power_state == V4L2_POWER_ON) || sensor->resuming) {
+
+		/* Check for FREX (frame mode) setup case */
+		if (sensor->shutter.type == MECH_SHUTTER_TYPE) {
+			/* max out AECL to insure longer than 1 frame */
+			coarse_int_tm = 0xFFFF;
+			goto write_aecl;
+		}
+
+		if (exp_time < sensor->exposure.min_exp_time) {
+			printk(KERN_ERR "OV8810: Exposure time %dms is less " \
+				"than regal limit %dms\n",
+				exp_time, sensor->exposure.min_exp_time);
+
+			exp_time = sensor->exposure.min_exp_time;
+		}
+
+		/* OV8810 cannot accept exposure time longer than frame time */
+		if (exp_time > sensor->exposure.fps_max_exp_time) {
+			printk(KERN_ERR "OV8810: Exposure time %dms is " \
+				"greater than legal limit %dms\n",
+				exp_time, sensor->exposure.fps_max_exp_time);
+
+			exp_time = sensor->exposure.fps_max_exp_time;
+		}
+
+		/* calc num lines with rounding */
+		coarse_int_tm = ((exp_time << 8) + (line_time_q8 >> 1)) /
+			line_time_q8;
+
+write_aecl:
+
+		if (coarse_int_tm != sensor->exposure.coarse_int_tm) {
+			/* write number of line times to AECL/H registers */
+			err = ov8810_write_reg(client, OV8810_AECL_H,
+				coarse_int_tm >> 8);
+			err |= ov8810_write_reg(client, OV8810_AECL_L,
+				coarse_int_tm & 0xFF);
+
+			DPRINTK_OV8810("set_exposure_time = " \
+				"%d usec, CoarseIntTime = %d, sclk=%d, " \
+				"line_len_pck=%d clks, line_tm = %d/256 us\n",
+				exp_time, coarse_int_tm, sensor->freq.sclk,
+				sensor_settings[isize].frame.line_len_pck,
+				line_time_q8);
+
+			/* save results */
+			sensor->exposure.exp_time = exp_time;
+			sensor->exposure.coarse_int_tm = coarse_int_tm;
+		}
+	}
+
+	if (err)
+		printk(KERN_ERR "OV8810: Error setting exposure time...%d\n",
+			err);
+	else {
+		if (lvc)
+			lvc->current_value = exp_time;
+	}
+
+	return err;
+}
+
+/**
+ * ov8810_set_gain - sets sensor analog & digital gain per input value
+ * @lineargain: q8 analog gain value to be set on device
+ * @s: pointer to standard V4L2 device structure
+ * @lvc: pointer to V4L2 analog gain entry in ov8810_video_control array
+ *
+ * If the requested analog gain is within the allowed limits, the HW
+ * is configured to use the new gain value, and the ov8810_video_control
+ * array is updated with the new current value.
+ * Up to 2x digital gain will be used in addition to analog gain to achieve
+ * the desired gain if necessary.
+ * The function returns 0 upon success.  Otherwise an error code is
+ * returned.
+ */
+int ov8810_set_gain(u16 linear_gain_Q8, struct v4l2_int_device *s,
+							struct vcontrol *lvc)
+{
+	/* Inputs linear Q8 gain */
+	u16 anlg_gain_stage_2x = 0, dgtl_gain_stage_2x = 0;
+	u16 shift_bits = 0;
+	u16 anlg_gain_fraction = 0;
+	u16 anlg_gain_register = 0, dgtl_gain_register = 0;
+	int err = 0;
+	struct ov8810_sensor *sensor = s->priv;
+	struct i2c_client *client = sensor->i2c_client;
+
+	if (linear_gain_Q8 < sensor->exposure.min_linear_gain) {
+		printk(KERN_ERR "OV8810: Gain %d less than regal limit %d\n",
+			linear_gain_Q8, sensor->exposure.min_linear_gain);
+
+		linear_gain_Q8 = sensor->exposure.min_linear_gain;
+	}
+
+	if (linear_gain_Q8 > sensor->exposure.max_linear_gain) {
+		printk(KERN_ERR "OV8810: Gain %d greater than regal limit %d\n",
+			linear_gain_Q8, sensor->exposure.max_linear_gain);
+
+		linear_gain_Q8 = sensor->exposure.max_linear_gain;
+	}
+
+	if ((current_power_state == V4L2_POWER_ON) || sensor->resuming) {
+		if (linear_gain_Q8 >= 16*256) {
+			dgtl_gain_stage_2x = 0x80;
+			anlg_gain_stage_2x = 0x70;
+			shift_bits = 4;
+		} else if (linear_gain_Q8 >= 8*256) {
+			anlg_gain_stage_2x = 0x70;
+			shift_bits = 3;
+		} else if (linear_gain_Q8 >= 4*256) {
+			anlg_gain_stage_2x = 0x30;
+			shift_bits = 2;
+		} else if (linear_gain_Q8 >= 2*256) {
+			anlg_gain_stage_2x = 0x10;
+			shift_bits = 1;
+		}
+
+		anlg_gain_fraction = linear_gain_Q8 >> shift_bits;
+		 /* subt 1 (Q8) and take upper 4 bits */
+		anlg_gain_fraction = (anlg_gain_fraction - (1*256)) >> 4;
+		if (anlg_gain_fraction > 0x0f)
+			anlg_gain_fraction = 0x0f;
+
+		anlg_gain_register = anlg_gain_stage_2x | anlg_gain_fraction;
+		dgtl_gain_register = dgtl_gain_stage_2x;
+
+		if (sensor->exposure.analog_gain != anlg_gain_register) {
+			err = ov8810_write_reg(client, OV8810_AGCL,
+				anlg_gain_register);
+
+			DPRINTK_OV8810("gain =%d/256, " \
+				"angl_gain reg = 0x%x\n",
+				linear_gain_Q8, anlg_gain_register);
+		}
+
+		if (sensor->exposure.digital_gain != dgtl_gain_register) {
+			err = ov8810_write_reg(client, OV8810_DIG_GAIN,
+				dgtl_gain_register);
+
+			DPRINTK_OV8810("gain =%d/256, "
+				"dgtl_gain_reg = 0x%x\n",
+				linear_gain_Q8, dgtl_gain_register);
+		}
+	}
+
+	if (err) {
+		printk(KERN_ERR "OV8810: Error setting analog gain: %d\n", err);
+		return err;
+	} else {
+		if (lvc)
+			lvc->current_value = linear_gain_Q8;
+	}
+
+	return err;
+}
+
+static int ov8810_init_exposure_params(struct v4l2_int_device *s)
+{
+	struct ov8810_sensor *sensor = s->priv;
+
+	/* flag current exp_time & gain values as invalid */
+	sensor->exposure.analog_gain = 0;
+	sensor->exposure.digital_gain = 0;
+	sensor->exposure.coarse_int_tm = 0;
+
+	return 0;
+}
+
+/**
+ * ov8810_set_framerate - Sets framerate by adjusting frame_len_lines reg.
+ * @s: pointer to standard V4L2 device structure
+ * @fper: frame period numerator and denominator in seconds
+ *
+ * The maximum exposure time is also updated since it is affected by the
+ * frame rate.
+ **/
+static int ov8810_set_framerate(struct v4l2_int_device *s,
+			struct v4l2_fract *fper, enum image_size_ov isize)
+{
+	u8 lut[9] = {1, 1, 1, 1, 2, 2, 2, 2, 4}, skip_factor;
+	u32 frame_length_lines, line_time_q8;
+	int err = 0, i = 0;
+	struct ov8810_sensor *sensor = s->priv;
+	struct i2c_client *client = sensor->i2c_client;
+	struct vcontrol *lvc = NULL;
+	struct ov8810_sensor_settings *ss = &sensor_settings[isize];
+
+	/* limit desired frame period to min frame period for this readout */
+	if (((fper->numerator << 8) / fper->denominator) <
+		((ss->frame.min_time_per_frame.numerator << 8) /
+		  ss->frame.min_time_per_frame.denominator)) {
+		fper->numerator = ss->frame.min_time_per_frame.numerator;
+		fper->denominator = ss->frame.min_time_per_frame.denominator;
+	}
+
+	skip_factor = lut[ss->frame.h_subsample];
+	line_time_q8 = /* usec's (q8) */
+		((((u32)ss->frame.line_len_pck * 1000) << 8) /
+		(sensor->freq.pclk / 1000) / skip_factor);
+
+	frame_length_lines = (((u32)fper->numerator * 1000000 * 256 /
+			       fper->denominator)) / line_time_q8;
+
+	/* Range check frame_length_lines */
+	if (frame_length_lines > OV8810_MAX_FRAME_LENGTH_LINES)
+		frame_length_lines = OV8810_MAX_FRAME_LENGTH_LINES;
+	else if (frame_length_lines < ss->frame.frame_len_lines_min)
+		frame_length_lines = ss->frame.frame_len_lines_min;
+
+	/* Write new frame length to sensor */
+	ov8810_write_reg(client, OV8810_FRM_LEN_LINES_H,
+		frame_length_lines >> 8);
+	ov8810_write_reg(client, OV8810_FRM_LEN_LINES_L,
+		frame_length_lines  & 0xFF);
+
+	/* Save results */
+	ss->frame.frame_len_lines = frame_length_lines;
+	sensor->exposure.line_time = line_time_q8;
+	/* min_exposure_time = (ss->exposure.fine_int_tm * 1000000 /
+		(sensor->freq.vt_pix_clk)) + 1; */
+	/* use line time for min until LAEC turned on */
+	sensor->exposure.min_exp_time = line_time_q8 >> 8;
+	sensor->exposure.fps_max_exp_time = (line_time_q8 *
+		(ss->frame.frame_len_lines - 8)) >> 8;
+	sensor->exposure.abs_max_exp_time = (line_time_q8 *
+		(OV8810_MAX_FRAME_LENGTH_LINES - 8)) >> 8;
+
+	/* Update Exposure Time */
+	i = find_vctrl(V4L2_CID_EXPOSURE);
+	if (i >= 0) {
+		lvc = &video_control[i];
+		/* Update min/max for query control */
+		lvc->qc.minimum = sensor->exposure.min_exp_time;
+		lvc->qc.maximum = sensor->exposure.fps_max_exp_time;
+
+		ov8810_set_exposure_time(lvc->current_value, s, lvc, isize);
+	}
+
+	DPRINTK_OV8810("Set Framerate: fper=%d/%d, " \
+		"frame_len_lines=%d, fps_max_expT=%dus, " \
+		"abs_max_expT=%dus, line_tm=%d/256, " \
+		"skip_factor=%d\n",
+		fper->numerator, fper->denominator, frame_length_lines,
+		sensor->exposure.fps_max_exp_time,
+		sensor->exposure.abs_max_exp_time,
+		line_time_q8, skip_factor);
+
+	return err;
+}
+
+/**
+ * ov8810_set_color_bar_mode - puts sensor in color bar test mode
+ * @enable: 0 = off, 1 = on
+ * @s: pointer to standard V4L2 device structure
+ * @lvc: pointer to V4L2 exposure entry in video_controls array
+ * This function should be called after the resolution is setup. The sensor
+ * will stay in color bar mode until the next resolution is selected.
+ * The function returns 0 upon success.  Otherwise an error code is
+ * returned.
+ */
+int ov8810_set_color_bar_mode(u16 enable, struct v4l2_int_device *s,
+							struct vcontrol *lvc)
+{
+	int err = 0;
+	struct ov8810_sensor *sensor = s->priv;
+	struct i2c_client *client = sensor->i2c_client;
+
+	if ((current_power_state == V4L2_POWER_ON) || sensor->resuming) {
+		if (enable) {
+			err = ov8810_write_reg(client, OV8810_CBAR, 0x1);
+			err = ov8810_write_reg(client, OV8810_SIZE_H0, 0x2);
+		} else {
+			err = ov8810_write_reg(client, OV8810_CBAR, 0x0);
+			err = ov8810_write_reg(client, OV8810_SIZE_H0, 0x3);
+		}
+	}
+
+	if (err)
+		printk(KERN_ERR "OV8810: Error setting color bar mode\n");
+	else {
+		if (lvc)
+			lvc->current_value = enable;
+	}
+
+	return err;
+}
+
+int ov8810_strobe_manual_trigger(void)
+{
+    return ov8810_write_regs(ov8810_i2c_client, ov8810_strobe_trigger_reg);
+}
+
+/**
+ * ov8810_set_flash_next_frame - configures flash on for the next frame
+ * @flash_params: flash type and time
+ * @s: pointer to standard V4L2 device structure
+ * @lvc: pointer to V4L2 exposure entry in video_controls array
+ * The function returns 0 upon success.  Otherwise an error code is
+ * returned.
+ */
+int ov8810_set_flash_next_frame(
+			struct ov8810_flash_params *flash_params,
+			struct v4l2_int_device *s, struct vcontrol *lvc)
+{
+	int err = 0, data;
+	struct ov8810_sensor *sensor = s->priv;
+	struct i2c_client *client = sensor->i2c_client;
+	u32 strb_pulse_width;
+	u32	line_time_q8 = sensor->exposure.line_time;
+
+	DPRINTK_OV8810("set_flash_next_frame: time=%dusec, " \
+		"flash_type=%d, shutter_type=%d, power=%d\n",
+		flash_params->flash_time, flash_params->flash_type,
+		flash_params->shutter_type,
+		(current_power_state == V4L2_POWER_ON) || sensor->resuming);
+
+	if (((current_power_state == V4L2_POWER_ON) || sensor->resuming) &&
+		(flash_params->flash_time != 0)) {
+
+		/* Set strobe source frame type */
+		ov8810_read_reg(client, 1, OV8810_FRS4, &data);
+		if (flash_params->shutter_type ==
+			ROLLING_SHUTTER_TYPE) {
+			data |= 1 << OV8810_FRS4_STRB_SOURCE_SEL_SHIFT;
+		} else {
+			data &= ~(1 << OV8810_FRS4_STRB_SOURCE_SEL_SHIFT);
+		}
+		err = ov8810_write_reg(client, OV8810_FRS4, data);
+
+		DPRINTK_OV8810("set_flash_next_frame:  " \
+			"OV8810_FRS_4=0x%x\n", data);
+
+		/* Set Strobe Ctrl Reg */
+		data = 0;
+		if (flash_params->shutter_type ==
+						ROLLING_SHUTTER_TYPE) {
+			data |= 1 <<
+				OV8810_FRS5_ROLLING_SHUT_STRB_EN_SHIFT;
+		}
+		if (flash_params->flash_type == LED_FLASH_TYPE) {
+			data |= 1 <<
+				OV8810_FRS5_STROBE_MODE_SHIFT;
+		}
+
+		strb_pulse_width = (flash_params->flash_time << 8) /
+			line_time_q8;
+
+		if (strb_pulse_width < 1)
+			strb_pulse_width = 1;
+		else if (strb_pulse_width > 4)
+			strb_pulse_width = 4;
+
+		data |= (strb_pulse_width - 1) <<
+			OV8810_FRS5_STRB_PLS_WIDTH_SHIFT;
+
+		err |= ov8810_write_reg(client, OV8810_FRS5, data);
+
+		DPRINTK_OV8810("set_flash_next_frame:  " \
+			"OV8810_FRS_5=0x%x\n", data);
+
+		/* Set Frame Mode Strobe Pulse Width */
+		if (flash_params->shutter_type == MECH_SHUTTER_TYPE) {
+			strb_pulse_width = (flash_params->flash_time << 8) /
+				line_time_q8;
+
+			if (strb_pulse_width > 15)
+				strb_pulse_width = 15;
+
+			err |= ov8810_write_reg(client, OV8810_FRS6,
+				strb_pulse_width);
+
+			DPRINTK_OV8810("set_flash_next_frame:  " \
+				"OV8810_FRS_6=0x%x\n",
+				strb_pulse_width);
+		}
+
+		/* Auto reset */
+		flash_params->flash_time = 0;
+	}
+
+	if (err)
+		printk(KERN_ERR  "OV8810: Error setting flash register\n");
+	else {
+		sensor->flash.flash_time = flash_params->flash_time;
+		sensor->flash.flash_type = flash_params->flash_type;
+		sensor->flash.shutter_type = flash_params->shutter_type;
+	}
+	return err;
+}
+
+/**
+ * Sets the sensor orientation.
+ */
+static int ov8810_set_orientation(enum ov8810_orientation val,
+			struct v4l2_int_device *s, struct vcontrol *lvc)
+{
+	int err = 0;
+	u32 data;
+	struct ov8810_sensor *sensor = s->priv;
+	struct i2c_client *client = to_i2c_client(sensor->dev);
+
+	if ((current_power_state == V4L2_POWER_ON) || sensor->resuming) {
+
+		err = ov8810_read_reg(client, 1,
+			OV8810_IMAGE_TRANSFORM, &data);
+			/* clear both orientation bits */
+			data &= ~OV8810_IMAGE_TRANSFORM_HMIRROR_MASK;
+			data &= ~OV8810_IMAGE_TRANSFORM_VFLIP_MASK;
+		switch (val) {
+		case OV8810_NO_HORZ_FLIP_OR_VERT_FLIP:
+			/* set no bits */
+			break;
+		case OV8810_HORZ_FLIP_ONLY:
+			data |= OV8810_IMAGE_TRANSFORM_HMIRROR_MASK;
+			break;
+		case OV8810_VERT_FLIP_ONLY:
+			data |= OV8810_IMAGE_TRANSFORM_VFLIP_MASK;
+			break;
+		case OV8810_HORZ_FLIP_AND_VERT_FLIP:
+			data |= OV8810_IMAGE_TRANSFORM_HMIRROR_MASK;
+			data |= OV8810_IMAGE_TRANSFORM_VFLIP_MASK;
+			break;
+		default:
+			break;
+		}
+
+		err |= ov8810_write_reg(client,
+			OV8810_IMAGE_TRANSFORM, data);
+
+		DPRINTK_OV8810("set_orientation:  " \
+			"sensor->orientation=%d, IMAGE_TRANSFORM=0x%x\n",
+			val, data);
+	}
+
+	if (err) {
+		printk(KERN_ERR "OV8810: Error setting orientation.%d", err);
+		return err;
+	} else {
+		lvc->current_value = (u32)val;
+		sensor->orientation = val;
+	}
+
+	return err;
+}
+
+/**
+ * ov8810_start_mech_shutter_capture - initiates capture using mechanical shutter
+ * @shutter_params: expoosure and shutter delay time
+ * @s: pointer to standard V4L2 device structure
+ * The function returns 0 upon success.  Otherwise an error code is
+ * returned.
+ * This function is expected to be called after streaming has been started and
+ * after shutter parameters have been set.
+ */
+int ov8810_start_mech_shutter_capture(
+			struct ov8810_shutter_params *shutter_params,
+			struct v4l2_int_device *s, struct vcontrol *lvc)
+{
+	u16 Tr_lines = 1, Tfrex_lines, shutter_dly_lines, frame_len_lines_adj;
+	u16 data = 0;
+	int err = -EINVAL;
+	int adjusted_exp_time;
+	struct ov8810_sensor *sensor = s->priv;
+	struct i2c_client *client = sensor->i2c_client;
+	struct ov8810_sensor_settings *ss = &sensor_settings[sensor->isize];
+	u32 line_time_q8 = sensor->exposure.line_time;
+
+	DPRINTK_OV8810("expTime=%dus, shutter delay=%dus, " \
+		"power=%d\n",
+		shutter_params->exp_time, shutter_params->delay_time,
+		(current_power_state == V4L2_POWER_ON) || sensor->resuming);
+
+	if (sensor->streaming == false) {
+		printk(KERN_ERR "OV8810: Error: Sensor must be streaming to " \
+			"start mech shutter capture.\n");
+		return err;
+	}
+
+	if ((shutter_params->type != MECH_SHUTTER_TYPE) ||
+			(shutter_params->exp_time == 0)) {
+		printk(KERN_ERR "OV8810: Error: Invalid shutter params.\n");
+		return err;
+	}
+
+	/* Set FREX Precharge Time */
+	err = ov8810_write_reg(client, OV8810_FRS1, Tr_lines);
+
+	/* Calc Tfrex time */
+	adjusted_exp_time = shutter_params->exp_time -
+		shutter_params->delay_time;
+	if (adjusted_exp_time < 0)
+		adjusted_exp_time = 0;
+
+	/* Convert Tfrex time to lines (with rounding) */
+	Tfrex_lines = (((adjusted_exp_time << 8) +
+		(line_time_q8 >> 1)) / line_time_q8) + Tr_lines;
+
+	err |= ov8810_write_reg(client, OV8810_FRS2,
+		((Tfrex_lines >> 8) & 0xFF));
+	err |= ov8810_write_reg(client, OV8810_FRS3,
+		((Tfrex_lines) & 0xFF));
+
+	/* Calc TFE2V  lines (with rounding)  */
+	shutter_dly_lines = (((shutter_params->delay_time << 8) +
+		(line_time_q8 >> 1)) / line_time_q8);
+
+	/*
+	 * start FREX capture & MIPI output simultaneously
+	 */
+	/* enable group latch */
+	err |= ov8810_write_reg(client, OV8810_FRS0, 0x88);
+
+	/* turn on MIPI output */
+	if (ss->mipi.num_data_lanes == 2)
+		data = 0;
+	else if (ss->mipi.num_data_lanes == 1)
+		data = OV8810_MIPI_CTRL0B_DSBL_DATA_LANE_2_MASK;
+	else
+		data = OV8810_MIPI_CTRL0B_DSBL_DATA_LANE_1_MASK |
+			OV8810_MIPI_CTRL0B_DSBL_DATA_LANE_2_MASK;
+
+	err |= ov8810_write_reg(client, OV8810_MIPI_CTRL0B, 0x0C | data);
+
+	/* adjust frame length to delay readout */
+	frame_len_lines_adj = ss->frame.frame_len_lines + shutter_dly_lines;
+	err |= ov8810_write_reg(client, OV8810_FRM_LEN_LINES_H,
+		 (frame_len_lines_adj >> 8) & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_FRM_LEN_LINES_L,
+		 frame_len_lines_adj & 0xFF);
+
+	/* do frame trigger */
+	err |= ov8810_write_reg(client, OV8810_FRS7, 0x01);
+
+	/* disable group latch */
+	err |= ov8810_write_reg(client, OV8810_FRS0, 0x80);
+
+	/* trigger group latch in the coming V-blank */
+	err |= ov8810_write_reg(client, OV8810_GROUP_WR, 0xFF);
+
+	DPRINTK_OV8810("start_mech_shutter_capture:  " \
+		"expT=%dus, line_time_q8=%dus/256, " \
+		"shutter_dly=%dus Tfrex_lines=%d, " \
+		"shutter_dly_lines=%d, frame_len_lines = %d\n",
+		shutter_params->exp_time, line_time_q8,
+		shutter_params->delay_time, Tfrex_lines,
+		shutter_dly_lines, frame_len_lines_adj);
+
+	if (err)
+		printk(KERN_ERR "OV8810: Error setting mech shutter registers\n");
+
+	return err;
+}
+
+/*
+ * Calculates the PClk.
+ * 1) Read pclk related params
+ * 2) Calc pclk
+ *      Pclk = xclk * PLL_multiplier  / pll_pre_div / div8 /
+ * 		vt_sys_div / rp_clk_div
+ * NOTE:
+ *  - The lookup table 'lut1' has been multiplied by 2 so all its values
+ *    are integers. The numerator is multiplied by 2 in the Pclk
+ *    calculation to compensate.
+ */
+static int ov8810_calc_pclk(struct v4l2_int_device *s,
+	enum image_size_ov isize)
+{
+	struct ov8810_sensor *sensor = s->priv;
+	struct ov8810_sensor_settings *ss = &sensor_settings[isize];
+
+	sensor->freq.sclk = sensor->freq.xclk * ss->clk.pll_mult /
+				ss->clk.pll_pre_div / ss->clk.div8 /
+				ss->clk.vt_sys_div;
+
+	sensor->freq.pclk = sensor->freq.sclk / ss->clk.rp_clk_div;
+
+	DPRINTK_OV8810("ov8810_calc_pclk: vt_sys_div=%d, div8=%d, " \
+		"op_sys_div=%d, op_pix_div=%d, pll_mult=%d, pll_pre_div=%d, " \
+		"rp_clk_div=%d, sclk=%d, pclk=%d, # lanes=%d\n",
+		ss->clk.vt_sys_div, ss->clk.div8,
+		ss->clk.op_sys_div, ss->clk.op_pix_div,
+		ss->clk.pll_mult, ss->clk.pll_pre_div,
+		ss->clk.rp_clk_div, sensor->freq.sclk, sensor->freq.pclk,
+		ss->mipi.num_data_lanes);
+	return 0;
+}
+
+/*
+ * Set Lens Correction
+ */
+static int ov8810_set_lens_correction(u16 enable_lens_correction,
+	struct v4l2_int_device *s, struct vcontrol *lvc,
+	enum image_size_ov isize)
+{
+	u8 lenc_downsampling;
+	int data, err = 0;
+	struct ov8810_sensor *sensor = s->priv;
+	struct i2c_client *client = sensor->i2c_client;
+	struct ov8810_sensor_settings *ss = &sensor_settings[isize];
+
+	if ((current_power_state == V4L2_POWER_ON) || sensor->resuming) {
+		if (enable_lens_correction) {
+			/* Lock VDD1 to OPP5 - Temporary workaround for 720p
+			   mode only !!!*/
+			sensor->pdata->lock_cpufreq(CPU_CLK_LOCK);
+
+			err = ov8810_write_regs(client, len_correction_tbl);
+			/* enable 0x3300[4] */
+			err |= ov8810_read_reg(client, 1,
+				OV8810_ISP_ENBL_0, &data);
+			data |= 0x10;
+			err |= ov8810_write_reg(client,
+				OV8810_ISP_ENBL_0, data);
+
+			/* set downsampling */
+			if (ss->frame.h_subsample == 8)
+				lenc_downsampling = LENC_8_1_DOWNSAMPLING;
+			else if (ss->frame.h_subsample == 4)
+				lenc_downsampling = LENC_4_1_DOWNSAMPLING;
+			else if (ss->frame.h_subsample == 2)
+				lenc_downsampling = LENC_2_1_DOWNSAMPLING;
+			else
+				lenc_downsampling = LENC_1_1_DOWNSAMPLING;
+
+			err |= ov8810_write_reg(client,
+				OV8810_LENC, lenc_downsampling);
+
+			DPRINTK_OV8810("enabling lens correction: " \
+				"downsample=0x%x\n", lenc_downsampling);
+
+		} else {  /* disable lens correction */
+			err = ov8810_read_reg(client, 1,
+				OV8810_ISP_ENBL_0, &data);
+			data &= 0xef;
+			err |= ov8810_write_reg(client,
+				OV8810_ISP_ENBL_0, data);
+		}
+	}
+
+	if (err)
+		printk(KERN_ERR "OV8810: Error setting lens correction=%d.\n",
+			enable_lens_correction);
+	else {
+		if (lvc)
+			lvc->current_value = enable_lens_correction;
+	}
+
+	return err;
+}
+
+/* Find the best match for a requested image capture size.  The best match
+ * is chosen as the nearest match that has the same number or fewer pixels
+ * as the requested size, or the smallest image size if the requested size
+ * has fewer pixels than the smallest image.
+ */
+static enum image_size_ov
+ov8810_find_size(struct v4l2_int_device *s, unsigned int width,
+	unsigned int height)
+{
+	enum image_size_ov size;
+
+	if ((width > ov8810_sizes[SIZE_2M].width) ||
+		(height > ov8810_sizes[SIZE_2M].height))
+		size = SIZE_8M;
+	else if ((width > ov8810_sizes[SIZE_1_5M].width) ||
+		(height > ov8810_sizes[SIZE_1_5M].height))
+		size = SIZE_2M;
+	else if ((width > ov8810_sizes[SIZE_500K].width) ||
+		(height > ov8810_sizes[SIZE_500K].height))
+		size = SIZE_1_5M;
+	else if ((width > ov8810_sizes[SIZE_125K].width) ||
+		(height > ov8810_sizes[SIZE_125K].height))
+		size = SIZE_500K;
+	else
+		size = SIZE_125K;
+
+	DPRINTK_OV8810("find_size: Req Width=%d, "
+			"Find Size=%dx%d\n",
+			width, (int)ov8810_sizes[size].width,
+			(int)ov8810_sizes[size].height);
+
+	return size;
+}
+
+/*
+ * Set CSI2 Virtual ID.
+ */
+static int ov8810_set_virtual_id(struct i2c_client *client, u32 id)
+{
+	return ov8810_write_reg(client, OV8810_MIPI_CTRL02, (0x3 & id) << 6 |
+									0x12);
+}
+
+/*
+ * Calculates the MIPIClk.
+ */
+static u32 ov8810_calc_mipiclk(struct v4l2_int_device *s,
+	enum image_size_ov isize)
+{
+	struct ov8810_sensor *sensor = s->priv;
+	struct ov8810_sensor_settings *ss = &sensor_settings[isize];
+
+	sensor->freq.mipiclk = (sensor->freq.xclk * ss->clk.pll_mult) /
+		(ss->clk.pll_pre_div * ss->clk.op_sys_div);
+
+	DPRINTK_OV8810("mipiclk=%u  pre_divider=%u  " \
+		"multiplier=%u  op_sys_div=%u\n",
+		sensor->freq.mipiclk, ss->clk.pll_pre_div,
+		ss->clk.pll_mult, ss->clk.op_sys_div);
+
+	return sensor->freq.mipiclk;
+}
+
+/**
+ * ov8810_configure_frame - Setup the frame, clock and exposure parmas in the
+ * sensor_settings array.
+ *
+ * @s: pointer to standard V4L2 device structure
+ * @isize: current image size
+ *
+ * The sensor_settings is a common list used by all image sizes & frame
+ * rates that is filled in by this routine.
+ */
+int ov8810_configure_frame(struct v4l2_int_device *s,
+			    enum image_size_ov isize)
+{
+	u8 lut[9] = { 0, 0, 1, 1, 2, 2, 2, 2, 3 };
+	u32 data;
+	int err = 0;
+	struct ov8810_sensor *sensor = s->priv;
+	struct i2c_client *client = to_i2c_client(sensor->dev);
+	struct ov8810_sensor_settings *ss = &sensor_settings[isize];
+
+	err |= ov8810_write_reg(client, OV8810_DSIO0,
+		(lut[ss->clk.rp_clk_div] & OV8810_DSIO0_RPCLK_DIV_MASK) | 0x8);
+
+	err |= ov8810_write_reg(client, OV8810_R_PLL1,
+		 (ss->clk.div8 & OV8810_R_PLL1_DIV8_MASK) |
+		((ss->clk.vt_sys_div << OV8810_R_PLL1_VT_SYS_DIV_SHIFT) &
+		  OV8810_R_PLL1_VT_SYS_DIV_MASK));
+
+	err |= ov8810_write_reg(client, OV8810_R_PLL4,
+		 (ss->clk.pll_pre_div & OV8810_R_PLL4_PRE_DIV_MASK) | 0x20);
+
+	err |= ov8810_write_reg(client, OV8810_R_PLL3,
+		 ss->clk.pll_mult & OV8810_R_PLL3_PLL_MULT_MASK);
+
+	err |= ov8810_write_reg(client, OV8810_R_PLL2,
+		 (ss->clk.op_pix_div & OV8810_R_PLL2_OP_PIX_DIV_MASK) |
+		((ss->clk.op_sys_div << OV8810_R_PLL2_OP_SYS_DIV_SHIFT) &
+		  OV8810_R_PLL2_OP_SYS_DIV_MASK));
+
+	err |= ov8810_write_reg(client, OV8810_X_OUTPUT_SIZE_H,
+		 (ss->frame.x_output_size >> 8) & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_X_OUTPUT_SIZE_L,
+		 ss->frame.x_output_size & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_Y_OUTPUT_SIZE_H,
+		 (ss->frame.y_output_size >> 8) & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_Y_OUTPUT_SIZE_L,
+		 ss->frame.y_output_size & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_X_ADDR_START_H,
+		 (ss->frame.x_addr_start >> 8) & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_X_ADDR_START_L,
+		 ss->frame.x_addr_start & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_Y_ADDR_START_H,
+		 (ss->frame.y_addr_start >> 8) & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_Y_ADDR_START_L,
+		 ss->frame.y_addr_start & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_X_ADDR_END_H,
+		 (ss->frame.x_addr_end >> 8) & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_X_ADDR_END_L,
+		 ss->frame.x_addr_end & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_Y_ADDR_END_H,
+		 (ss->frame.y_addr_end >> 8) & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_Y_ADDR_END_L,
+		 ss->frame.y_addr_end & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_FRM_LEN_LINES_H,
+		 (ss->frame.frame_len_lines_min >> 8) & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_FRM_LEN_LINES_L,
+		 ss->frame.frame_len_lines_min & 0xFF);
+	ss->frame.frame_len_lines = ss->frame.frame_len_lines_min;
+
+	err |= ov8810_write_reg(client, OV8810_LINE_LEN_PCK_H,
+		 (ss->frame.line_len_pck_min >> 8) & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_LINE_LEN_PCK_L,
+		 ss->frame.line_len_pck_min & 0xFF);
+	ss->frame.line_len_pck = ss->frame.line_len_pck_min;
+
+	data = ((lut[ss->frame.v_subsample] <<
+		 OV8810_IMAGE_TRANSFORM_VSUB_SHIFT) &
+		 OV8810_IMAGE_TRANSFORM_VSUB_MASK) |
+		 (lut[ss->frame.h_subsample] &
+		 OV8810_IMAGE_TRANSFORM_HSUB_MASK);
+
+/*
+printk("ov8810_configure_frame: sensor->orientation = %d\n",
+	sensor->orientation);
+*/
+
+/*
+	switch (sensor->orientation) {
+	case OV8810_NO_HORZ_FLIP_OR_VERT_FLIP:
+		break;
+	case OV8810_HORZ_FLIP_ONLY:
+		data |= OV8810_IMAGE_TRANSFORM_HMIRROR_MASK;
+		break;
+	case OV8810_VERT_FLIP_ONLY:
+		data |= OV8810_IMAGE_TRANSFORM_VFLIP_MASK;
+		break;
+	case OV8810_HORZ_FLIP_AND_VERT_FLIP:
+		data |= OV8810_IMAGE_TRANSFORM_HMIRROR_MASK;
+		data |= OV8810_IMAGE_TRANSFORM_VFLIP_MASK;
+		break;
+	default:
+		break;
+	}
+*/
+	data |= 0x40;  /* TEMP force orientation */
+	err |= ov8810_write_reg(client, OV8810_IMAGE_TRANSFORM, data);
+
+	sensor->isize = isize;
+	if (err)
+		return -EIO;
+	else
+		return 0;
+}
+
+/*
+ * Configure the ov8810 for a specified image size, pixel format, and frame
+ * period.  xclk is the frequency (in Hz) of the xclk input to the OV8810.
+ * fper is the frame period (in seconds) expressed as a fraction.
+ * Returns zero if successful, or non-zero otherwise.
+ * The actual frame period is returned in fper.
+ */
+static int ov8810_configure(struct v4l2_int_device *s)
+{
+	enum image_size_ov isize;
+	u16 data = 0;
+	int err = 0, i = 0;
+	u32 mipiclk;
+	enum pixel_format_ov pfmt = RAW10;
+	struct ov8810_sensor *sensor = s->priv;
+	struct v4l2_pix_format *pix = &sensor->pix;
+	struct i2c_client *client = sensor->i2c_client;
+	struct vcontrol *lvc = NULL;
+
+	switch (pix->pixelformat) {
+
+	case V4L2_PIX_FMT_SGRBG10:
+		pfmt = RAW10;
+		break;
+	}
+
+	/* Set receivers virtual channel before sensor setup starts.
+	 * Only set the sensors virtual channel after all other setup
+	 * for the sensor is complete.
+	 */
+	isp_csi2_ctx_config_virtual_id(0, OV8810_CSI2_VIRTUAL_ID);
+	isp_csi2_ctx_update(0, false);
+
+	isize = ov8810_find_size(s, pix->width, pix->height);
+
+	printk(KERN_INFO "ov8810_configure: isize=%d, Req Size=%dx%d, " \
+		"Find Size = %dx%d, fps=%d/%d\n", \
+		isize, pix->width, pix->height,
+		(int)ov8810_sizes[isize].width,
+		(int)ov8810_sizes[isize].height,
+		sensor->timeperframe.denominator,
+		sensor->timeperframe.numerator);
+
+	/* Reset */
+	isp_csi2_ctrl_config_if_enable(false);
+	isp_csi2_ctrl_update(false);
+
+	ov8810_write_reg(client, OV8810_SYS, 0x80);
+	mdelay(5);
+
+	/* Set CSI2 common register settings */
+	err = ov8810_write_regs(client, ov8810_common_csi2);
+	if (err)
+		return err;
+
+	/* configure image size, pll, and pixel format */
+	if (pix->pixelformat == V4L2_PIX_FMT_SGRBG10) {
+		err = ov8810_write_regs(client, ov8810_common[isize]);
+
+	} else if (pix->pixelformat == V4L2_PIX_FMT_W1S_PATT) {
+		isize = SIZE_8M;
+		err = ov8810_write_regs(client, ov8810_common[isize]);
+
+		err |= ov8810_write_reg(client, OV8810_DVP_CTRL08, 0x80);
+	}
+	if (err)
+		return err;
+
+	/* Turn on 50-60 Hz Detection */
+	if (isize != SIZE_8M) {
+		err = ov8810_write_regs(client, ov8810_50_60_hz_detect_tbl);
+		if (err)
+			return err;
+	}
+
+	/* Set Shutter related register settings */
+	if (sensor->shutter.type == MECH_SHUTTER_TYPE) {
+		/* Leave MIPI output disabled until
+		   start_mech_shutter_capture */
+		err = ov8810_write_regs(client, ov8810_mech_shutter);
+		if (err)
+			return err;
+	} else {
+		/* Enable MIPI output */
+		if (sensor_settings[isize].mipi.num_data_lanes == 2)
+			data = 0;
+		else if (sensor_settings[isize].mipi.num_data_lanes == 1)
+			data = OV8810_MIPI_CTRL0B_DSBL_DATA_LANE_2_MASK;
+		else
+			data = OV8810_MIPI_CTRL0B_DSBL_DATA_LANE_1_MASK |
+				OV8810_MIPI_CTRL0B_DSBL_DATA_LANE_2_MASK;
+
+		err = ov8810_write_reg(client, OV8810_MIPI_CTRL0B, 0x0c | data);
+		if (err)
+			return err;
+	}
+
+	sensor->isize = isize;
+
+	/* if the image size correspond to one of the base image sizes
+		then we don't need to scale the image */
+	sensor->hsize = pix->width;
+	sensor->vsize = pix->height;
+
+	/* Setup the ISP VP based on image format */
+	if (pix->pixelformat == V4L2_PIX_FMT_SGRBG10) {
+		isp_configure_interface_bridge(0x00);
+		isp_csi2_ctrl_config_vp_out_ctrl(2);
+		isp_csi2_ctrl_update(false);
+	} else {
+		isp_configure_interface_bridge(0x03);
+		isp_csi2_ctrl_config_vp_out_ctrl(1);
+		isp_csi2_ctrl_update(false);
+	}
+
+	/* Store image size */
+	sensor->width = pix->width;
+	sensor->height = pix->height;
+
+	/* Update sensor clk, frame, & exposure params */
+	ov8810_calc_pclk(s, isize);
+	ov8810_init_exposure_params(s);
+	err = ov8810_configure_frame(s, isize);
+	if (err)
+		return err;
+
+	/* Setting of frame rate */
+	err = ov8810_set_framerate(s, &sensor->timeperframe, isize);
+	if (err)
+		return err;
+
+	mipiclk = ov8810_calc_mipiclk(s, isize);
+
+	DPRINTK_OV8810("mipiclk = %d, lbound_hs_settle = %d, " \
+		"ubound_hs_settle = %d \n", mipiclk,
+		sensor_settings[isize].mipi.hs_settle_lower,
+		sensor_settings[isize].mipi.hs_settle_upper);
+
+	/* Send settings to ISP-CSI2 Receiver PHY */
+	isp_csi2_calc_phy_cfg0(mipiclk,
+		sensor_settings[isize].mipi.hs_settle_lower,
+		sensor_settings[isize].mipi.hs_settle_upper);
+
+	/* Set sensors virtual channel*/
+	ov8810_set_virtual_id(client, OV8810_CSI2_VIRTUAL_ID);
+
+	isp_csi2_ctrl_config_if_enable(true);
+	isp_csi2_ctrl_update(false);
+
+	/* Set initial exposure time */
+	i = find_vctrl(V4L2_CID_EXPOSURE);
+	if (i >= 0) {
+		lvc = &video_control[i];
+		ov8810_set_exposure_time(lvc->current_value,
+			sensor->v4l2_int_device, lvc, isize);
+	}
+
+	/* Set initial gain */
+	i = find_vctrl(V4L2_CID_GAIN);
+	if (i >= 0) {
+		lvc = &video_control[i];
+		ov8810_set_gain(lvc->current_value,
+			sensor->v4l2_int_device, lvc);
+	}
+
+	if (pix->pixelformat != V4L2_PIX_FMT_W1S_PATT) {
+		/* Set initial color bars */
+		i = find_vctrl(V4L2_CID_PRIVATE_COLOR_BAR);
+		if (i >= 0) {
+			lvc = &video_control[i];
+			ov8810_set_color_bar_mode(lvc->current_value,
+				sensor->v4l2_int_device, lvc);
+		}
+	}
+
+	/* Set initial flash mode */
+	i = find_vctrl(V4L2_CID_PRIVATE_FLASH_NEXT_FRAME);
+	if (i >= 0) {
+		lvc = &video_control[i];
+		ov8810_set_flash_next_frame(&(sensor->flash),
+			sensor->v4l2_int_device, lvc);
+	}
+
+	i = find_vctrl(V4L2_CID_PRIVATE_LENS_CORRECTION);
+	if (i >= 0) {
+		lvc = &video_control[i];
+		ov8810_set_lens_correction(lvc->current_value,
+			sensor->v4l2_int_device, lvc, isize);
+	}
+
+	/* start streaming */
+	ov8810_write_reg(client, OV8810_IMAGE_SYSTEM, 0x01);
+	sensor->streaming = true;
+
+	return err;
+}
+
+
+/* Detect if an ov8810 is present, returns a negative error number if no
+ * device is detected, or pidl as version number if a device is detected.
+ */
+static int ov8810_detect(struct v4l2_int_device *s)
+{
+	u16 pid, rev;
+	u32 val;
+	struct ov8810_sensor *sensor = s->priv;
+	struct i2c_client *client = sensor->i2c_client;
+	struct ov8810_sensor_id *sensor_id = &(sensor->sensor_id);
+
+	if (!client)
+		return -ENODEV;
+
+	if (ov8810_read_reg(client, 1, OV8810_PIDH, &val))
+		return -ENODEV;
+	pid = (val & 0xff) << 8;
+
+	if (ov8810_read_reg(client, 1, OV8810_PIDL, &val))
+		return -ENODEV;
+	pid |= val & 0xf0;
+	rev = val & 0xf;
+
+	/* Check ID & max supported rev */
+	if (pid == OV8810_PID) {
+		DPRINTK_OV8810("Detect success " \
+			"(pid=0x%x rev=0x%x\n", pid, rev);
+
+		sensor_id->model = pid;
+		sensor_id->revision = rev;
+
+		return 0;
+	} else {
+		/* We didn't read the values we expected, so
+		 * this must not be an OV8810.
+		 */
+		printk(KERN_ERR "OV8810: pid mismatch 0x%x rev 0x%x\n",
+			pid, rev);
+
+		return -ENODEV;
+	}
+}
+
+/*
+ * ioctl_queryctrl - V4L2 sensor interface handler for VIDIOC_QUERYCTRL ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @qc: standard V4L2 VIDIOC_QUERYCTRL ioctl structure
+ *
+ * If the requested control is supported, returns the control information
+ * from the video_control[] array.  Otherwise, returns -EINVAL if the
+ * control is not supported.
+ */
+static int ioctl_queryctrl(struct v4l2_int_device *s,
+						struct v4l2_queryctrl *qc)
+{
+	int i;
+
+	i = find_vctrl(qc->id);
+	if (i == -EINVAL)
+		qc->flags = V4L2_CTRL_FLAG_DISABLED;
+
+	if (i < 0)
+		return -EINVAL;
+
+	*qc = video_control[i].qc;
+	return 0;
+}
+
+/*
+ * ioctl_g_ctrl - V4L2 sensor interface handler for VIDIOC_G_CTRL ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @vc: standard V4L2 VIDIOC_G_CTRL ioctl structure
+ *
+ * If the requested control is supported, returns the control's current
+ * value from the video_control[] array.  Otherwise, returns -EINVAL
+ * if the control is not supported.
+ */
+
+static int ioctl_g_ctrl(struct v4l2_int_device *s,
+			     struct v4l2_control *vc)
+{
+	int i, retval = 0;
+	struct ov8810_sensor *sensor = s->priv;
+	struct i2c_client *client = sensor->i2c_client;
+	struct vcontrol *lvc;
+	struct  ov8810_sensor_params sensor_params;
+	struct ov8810_sensor_regif sensor_reg;
+
+	i = find_vctrl(vc->id);
+	if (i < 0)
+		return -EINVAL;
+	lvc = &video_control[i];
+
+	switch (vc->id) {
+	case  V4L2_CID_EXPOSURE:
+		vc->value = lvc->current_value;
+		break;
+	case V4L2_CID_GAIN:
+		vc->value = lvc->current_value;
+		break;
+	case V4L2_CID_PRIVATE_COLOR_BAR:
+		vc->value = lvc->current_value;
+		break;
+	case V4L2_CID_PRIVATE_FLASH_NEXT_FRAME:
+		if (copy_to_user((void *)vc->value, &(sensor->flash),
+				sizeof(sensor->flash))) {
+			retval = -EINVAL;
+			printk(KERN_ERR "OV8810: Failed copy_to_user\n");
+		}
+		break;
+	case V4L2_CID_PRIVATE_ORIENTATION:
+		vc->value = lvc->current_value;
+		break;
+	case V4L2_CID_PRIVATE_LENS_CORRECTION:
+		vc->value = lvc->current_value;
+		break;
+	case V4L2_CID_PRIVATE_SHUTTER_PARAMS:
+		if (copy_to_user((void *)vc->value, &(sensor->shutter),
+				sizeof(sensor->shutter))) {
+			retval = -EINVAL;
+			printk(KERN_ERR "OV8810: Failed copy_to_user\n");
+		}
+		break;
+	case V4L2_CID_PRIVATE_SENSOR_ID_REQ:
+		if (copy_to_user((void *)vc->value, &(sensor->sensor_id),
+				sizeof(sensor->sensor_id))) {
+			retval = -EINVAL;
+			printk(KERN_ERR "OV8810: Failed copy_to_user\n");
+		}
+		break;
+	case V4L2_CID_PRIVATE_SENSOR_REG_REQ:
+		if ((current_power_state != V4L2_POWER_ON) &&
+			!sensor->resuming) {
+			printk(KERN_ERR "OV8810: I2C Read Err: Power Off\n");
+			return -EINVAL;
+		}
+		if (copy_from_user(&sensor_reg,
+			(struct ov8810_sensor_regif *)vc->value,
+			sizeof(struct ov8810_sensor_regif)) == 0) {
+			retval =  ov8810_read_reg(client, sensor_reg.len,
+				sensor_reg.addr, &sensor_reg.val);
+			DPRINTK_OV8810("SENSOR_REG_REQ IOCTL read-" \
+				"%d: 0x%x=0x%x\n", sensor_reg.len,
+				sensor_reg.addr, sensor_reg.val);
+		}
+		if (copy_to_user((void *)vc->value, &(sensor_reg),
+				sizeof(sensor_reg))) {
+			printk(KERN_ERR "OV8810: Failed copy_to_user\n");
+			return -EINVAL;
+		}
+		break;
+	case V4L2_CID_PRIVATE_SENSOR_PARAMS_REQ:
+		sensor_params.line_time = sensor->exposure.line_time;
+		sensor_params.gain_frame_delay = OV8810_GAIN_FRAME_DELAY;
+		sensor_params.exp_time_frame_delay =
+			OV8810_EXP_TIME_FRAME_DELAY;
+		if (copy_to_user((void *)vc->value, &(sensor_params),
+				sizeof(sensor_params))) {
+			printk(KERN_ERR "OV8810: Failed copy_to_user\n");
+			return -EINVAL;
+		}
+		break;
+	}
+	return retval;
+}
+
+/*
+ * ioctl_s_ctrl - V4L2 sensor interface handler for VIDIOC_S_CTRL ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @vc: standard V4L2 VIDIOC_S_CTRL ioctl structure
+ *
+ * If the requested control is supported, sets the control's current
+ * value in HW (and updates the video_control[] array).  Otherwise,
+ * returns -EINVAL if the control is not supported.
+ */
+static int ioctl_s_ctrl(struct v4l2_int_device *s,
+			     struct v4l2_control *vc)
+{
+	int retval = -EINVAL;
+	int i;
+	struct ov8810_sensor *sensor = s->priv;
+	struct i2c_client *client = sensor->i2c_client;
+	struct vcontrol *lvc;
+	struct ov8810_flash_params flash_params;
+	struct ov8810_sensor_regif sensor_reg;
+
+	i = find_vctrl(vc->id);
+	if (i < 0)
+		return -EINVAL;
+
+	lvc = &video_control[i];
+
+	switch (vc->id) {
+	case V4L2_CID_EXPOSURE:
+		retval = ov8810_set_exposure_time(vc->value, s, lvc,
+			sensor->isize);
+		break;
+	case V4L2_CID_GAIN:
+		retval = ov8810_set_gain(vc->value, s, lvc);
+		break;
+	case V4L2_CID_PRIVATE_COLOR_BAR:
+		retval = ov8810_set_color_bar_mode(vc->value, s, lvc);
+		break;
+	case V4L2_CID_PRIVATE_FLASH_NEXT_FRAME:
+		if (copy_from_user(&flash_params,
+				(struct ov8810_flash_params *)vc->value,
+				sizeof(struct ov8810_flash_params)) == 0) {
+			retval = ov8810_set_flash_next_frame(&flash_params,
+				s, lvc);
+		}
+		break;
+	case V4L2_CID_PRIVATE_ORIENTATION:
+		retval = ov8810_set_orientation(vc->value, s, lvc);
+		break;
+	case V4L2_CID_PRIVATE_LENS_CORRECTION:
+		retval = ov8810_set_lens_correction(vc->value, s, lvc,
+			sensor->isize);
+		break;
+	case V4L2_CID_PRIVATE_SHUTTER_PARAMS:
+		retval = copy_from_user(&(sensor->shutter),
+				(struct ov8810_shutter_params *)vc->value,
+				sizeof(struct ov8810_shutter_params));
+		DPRINTK_OV8810("SHUTTER_PARAMS IOCTL write-" \
+			"exp_time=%d, delay_time=%d, type=%d\n",
+			sensor->shutter.exp_time, sensor->shutter.delay_time,
+			sensor->shutter.type);
+		break;
+	case V4L2_CID_PRIVATE_START_MECH_SHUTTER_CAPTURE:
+		retval = ov8810_start_mech_shutter_capture(
+			&(sensor->shutter), s, lvc);
+		break;
+	case V4L2_CID_PRIVATE_SENSOR_REG_REQ:
+		if ((current_power_state != V4L2_POWER_ON) &&
+			!sensor->resuming) {
+			printk(KERN_ERR "OV8810: Reg Write Err: Power Off\n");
+			return -EINVAL;
+		}
+		if (copy_from_user(&sensor_reg,
+			(struct ov8810_sensor_regif *)vc->value,
+			sizeof(struct ov8810_sensor_regif)) == 0) {
+
+			/* ov8810_write_reg only supports 1-byte writes */
+			DPRINTK_OV8810("SENSOR_REG_REQ IOCTL write-" \
+				"%d: 0x%x=0x%x\n", sensor_reg.len,
+				sensor_reg.addr, sensor_reg.val);
+			if (sensor_reg.len == 1) {
+				retval = ov8810_write_reg(client,
+					sensor_reg.addr, sensor_reg.val);
+			} else if (sensor_reg.len == 2) {
+				retval = ov8810_write_reg(client,
+					sensor_reg.addr,
+					(sensor_reg.val & 0xff00) >> 8);
+				retval |= ov8810_write_reg(client,
+					sensor_reg.addr + 1,
+					sensor_reg.val & 0xff);
+			} else if (sensor_reg.len == 4) {
+				retval = ov8810_write_reg(client,
+					sensor_reg.addr,
+					(sensor_reg.val & 0xff000000) >> 24);
+				retval |= ov8810_write_reg(client,
+					sensor_reg.addr + 1,
+					(sensor_reg.val & 0xff0000) >> 16);
+				retval |= ov8810_write_reg(client,
+					sensor_reg.addr + 2,
+					(sensor_reg.val & 0xff00) >> 8);
+				retval |= ov8810_write_reg(client,
+					sensor_reg.addr + 3,
+					sensor_reg.val & 0xff);
+			} else {
+				printk(KERN_ERR "OV8810: Error: " \
+					"SENSOR_REG_REQ IOCTL " \
+					"length must = 1, 2, or 4\n");
+			}
+		}
+		break;
+	}
+	if (!retval)
+		lvc->current_value = vc->value;
+	return retval;
+}
+
+/*
+ * ioctl_enum_fmt_cap - Implement the CAPTURE buffer VIDIOC_ENUM_FMT ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @fmt: standard V4L2 VIDIOC_ENUM_FMT ioctl structure
+ *
+ * Implement the VIDIOC_ENUM_FMT ioctl for the CAPTURE buffer type.
+ */
+ static int ioctl_enum_fmt_cap(struct v4l2_int_device *s,
+				   struct v4l2_fmtdesc *fmt)
+{
+	int index = fmt->index;
+	enum v4l2_buf_type type = fmt->type;
+
+	memset(fmt, 0, sizeof(*fmt));
+	fmt->index = index;
+	fmt->type = type;
+
+	switch (fmt->type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		if (index >= NUM_CAPTURE_FORMATS)
+			return -EINVAL;
+	break;
+	default:
+		return -EINVAL;
+	}
+
+	fmt->flags = ov8810_formats[index].flags;
+	strlcpy(fmt->description, ov8810_formats[index].description,
+					sizeof(fmt->description));
+	fmt->pixelformat = ov8810_formats[index].pixelformat;
+
+	return 0;
+}
+
+
+/*
+ * ioctl_try_fmt_cap - Implement the CAPTURE buffer VIDIOC_TRY_FMT ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @f: pointer to standard V4L2 VIDIOC_TRY_FMT ioctl structure
+ *
+ * Implement the VIDIOC_TRY_FMT ioctl for the CAPTURE buffer type.  This
+ * ioctl is used to negotiate the image capture size and pixel format
+ * without actually making it take effect.
+ */
+
+static int ioctl_try_fmt_cap(struct v4l2_int_device *s,
+			     struct v4l2_format *f)
+{
+	int ifmt;
+	enum image_size_ov isize;
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+
+	if (pix->width > ov8810_sizes[SIZE_8M].width)
+		pix->width = ov8810_sizes[SIZE_8M].width;
+	if (pix->height > ov8810_sizes[SIZE_8M].height)
+		pix->height = ov8810_sizes[SIZE_8M].height;
+
+	isize = ov8810_find_size(s, pix->width, pix->height);
+	pix->width = ov8810_sizes[isize].width;
+	pix->height = ov8810_sizes[isize].height;
+
+	for (ifmt = 0; ifmt < NUM_CAPTURE_FORMATS; ifmt++) {
+		if (pix->pixelformat == ov8810_formats[ifmt].pixelformat)
+			break;
+	}
+	if (ifmt == NUM_CAPTURE_FORMATS)
+		ifmt = 0;
+	pix->pixelformat = ov8810_formats[ifmt].pixelformat;
+	pix->field = V4L2_FIELD_NONE;
+	pix->bytesperline = pix->width*2;
+	pix->sizeimage = pix->bytesperline*pix->height;
+	pix->priv = 0;
+	switch (pix->pixelformat) {
+	case V4L2_PIX_FMT_SGRBG10:
+		pix->colorspace = V4L2_COLORSPACE_SRGB;
+		break;
+	}
+	return 0;
+}
+
+
+/*
+ * ioctl_s_fmt_cap - V4L2 sensor interface handler for VIDIOC_S_FMT ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @f: pointer to standard V4L2 VIDIOC_S_FMT ioctl structure
+ *
+ * If the requested format is supported, configures the HW to use that
+ * format, returns error code if format not supported or HW can't be
+ * correctly configured.
+ */
+ static int ioctl_s_fmt_cap(struct v4l2_int_device *s,
+				struct v4l2_format *f)
+{
+	struct ov8810_sensor *sensor = s->priv;
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+	int rval;
+
+	rval = ioctl_try_fmt_cap(s, f);
+	if (rval)
+		return rval;
+
+	sensor->pix = *pix;
+
+	return 0;
+}
+
+/*
+ * ioctl_g_fmt_cap - V4L2 sensor interface handler for ioctl_g_fmt_cap
+ * @s: pointer to standard V4L2 device structure
+ * @f: pointer to standard V4L2 v4l2_format structure
+ *
+ * Returns the sensor's current pixel format in the v4l2_format
+ * parameter.
+ */
+static int ioctl_g_fmt_cap(struct v4l2_int_device *s,
+				struct v4l2_format *f)
+{
+	struct ov8810_sensor *sensor = s->priv;
+	f->fmt.pix = sensor->pix;
+
+	return 0;
+}
+
+/*
+ * ioctl_g_parm - V4L2 sensor interface handler for VIDIOC_G_PARM ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @a: pointer to standard V4L2 VIDIOC_G_PARM ioctl structure
+ *
+ * Returns the sensor's video CAPTURE parameters.
+ */
+static int ioctl_g_parm(struct v4l2_int_device *s,
+			     struct v4l2_streamparm *a)
+{
+	struct ov8810_sensor *sensor = s->priv;
+	struct v4l2_captureparm *cparm = &a->parm.capture;
+
+	if (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	memset(a, 0, sizeof(*a));
+	a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	cparm->capability = V4L2_CAP_TIMEPERFRAME;
+	cparm->timeperframe = sensor->timeperframe;
+
+	return 0;
+}
+
+/*
+ * ioctl_s_parm - V4L2 sensor interface handler for VIDIOC_S_PARM ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @a: pointer to standard V4L2 VIDIOC_S_PARM ioctl structure
+ *
+ * Configures the sensor to use the input parameters, if possible.  If
+ * not possible, reverts to the old parameters and returns the
+ * appropriate error code.
+ */
+static int ioctl_s_parm(struct v4l2_int_device *s,
+			     struct v4l2_streamparm *a)
+{
+	int rval = 0;
+	struct ov8810_sensor *sensor = s->priv;
+	struct v4l2_fract *timeperframe = &a->parm.capture.timeperframe;
+	struct v4l2_fract timeperframe_old;
+	int desired_fps;
+	timeperframe_old = sensor->timeperframe;
+	sensor->timeperframe = *timeperframe;
+
+	desired_fps = timeperframe->denominator / timeperframe->numerator;
+	if ((desired_fps < OV8810_MIN_FPS) || (desired_fps > OV8810_MAX_FPS)) {
+		sensor->timeperframe = timeperframe_old;
+		printk(KERN_ERR "OV8810: Error setting FPS=%d/%d, " \
+			"FPS must be between %d & %d,",
+			timeperframe->denominator, timeperframe->numerator,
+			OV8810_MIN_FPS, OV8810_MAX_FPS);
+		rval = -EINVAL;
+	} else {
+		DPRINTK_OV8810("Setting FPS=%d\n", desired_fps);
+		if ((current_power_state == V4L2_POWER_ON) ||
+				sensor->resuming) {
+			rval = ov8810_set_framerate(s, &sensor->timeperframe,
+				sensor->isize);
+		}
+	}
+
+	return rval;
+}
+
+/*
+ * ioctl_g_priv - V4L2 sensor interface handler for vidioc_int_g_priv_num
+ * @s: pointer to standard V4L2 device structure
+ * @p: void pointer to hold sensor's private data address
+ *
+ * Returns device's (sensor's) private data area address in p parameter
+ */
+static int ioctl_g_priv(struct v4l2_int_device *s, void *p)
+{
+	struct ov8810_sensor *sensor = s->priv;
+
+	return sensor->pdata->priv_data_set(p);
+}
+
+/*
+ * ioctl_s_power - V4L2 sensor interface handler for vidioc_int_s_power_num
+ * @s: pointer to standard V4L2 device structure
+ * @on: power state to which device is to be set
+ *
+ * Sets devices power state to requrested state, if possible.
+ */
+ static int ioctl_s_power(struct v4l2_int_device *s, enum v4l2_power on)
+{
+	struct ov8810_sensor *sensor = s->priv;
+	struct i2c_client *c = sensor->i2c_client;
+	struct omap34xxcam_hw_config hw_config;
+	int rval;
+
+	rval = ioctl_g_priv(s, &hw_config);
+	if (rval) {
+		printk(KERN_ERR "OV8810: Unable to get hw params\n");
+		return rval;
+	}
+
+	if (on == V4L2_POWER_ON) {
+		isp_set_xclk(sensor->freq.xclk, OV8810_USE_XCLKA);
+	} else if (on == V4L2_POWER_OFF) {
+		isp_set_xclk(0, OV8810_USE_XCLKA);
+		sensor->streaming = false;
+		/* release resource lock */
+		sensor->pdata->lock_cpufreq(CPU_CLK_UNLOCK);
+	} else {
+		sensor->streaming = false;
+	}
+
+	rval = sensor->pdata->power_set(sensor->dev, c, on);
+	if (rval < 0) {
+		printk(KERN_ERR "OV8810: Unable to set the power state: "
+			OV8810_DRIVER_NAME " sensor\n");
+		isp_set_xclk(0, OV8810_USE_XCLKA);
+		return rval;
+	}
+
+	if ((current_power_state == V4L2_POWER_STANDBY) &&
+			(on == V4L2_POWER_ON) &&
+			(sensor->state == SENSOR_DETECTED)) {
+		sensor->resuming = true;
+		ov8810_configure(s);
+	}
+
+	if ((on == V4L2_POWER_ON) && (sensor->state == SENSOR_NOT_DETECTED)) {
+
+		rval = ov8810_detect(s);
+		if (rval < 0) {
+			printk(KERN_ERR "OV8810: Unable to detect "
+					OV8810_DRIVER_NAME " sensor\n");
+			sensor->state = SENSOR_NOT_DETECTED;
+			return rval;
+		}
+		sensor->state = SENSOR_DETECTED;
+		pr_info(OV8810_DRIVER_NAME " Chip version 0x%02x detected\n",
+			sensor->sensor_id.revision);
+	}
+
+	sensor->resuming = false;
+	current_power_state = on;
+	return 0;
+}
+
+/*
+ * ioctl_init - V4L2 sensor interface handler for VIDIOC_INT_INIT
+ * @s: pointer to standard V4L2 device structure
+ *
+ * Initialize the sensor device (call ov8810_configure())
+ */
+static int ioctl_init(struct v4l2_int_device *s)
+{
+	return 0;
+}
+
+/**
+ * ioctl_dev_exit - V4L2 sensor interface handler for vidioc_int_dev_exit_num
+ * @s: pointer to standard V4L2 device structure
+ *
+ * Delinitialise the dev. at slave detach.  The complement of ioctl_dev_init.
+ */
+static int ioctl_dev_exit(struct v4l2_int_device *s)
+{
+	return 0;
+}
+
+/**
+ * ioctl_dev_init - V4L2 sensor interface handler for vidioc_int_dev_init_num
+ * @s: pointer to standard V4L2 device structure
+ *
+ * Initialise the device when slave attaches to the master.  Returns 0 if
+ * ov8810 device could be found, otherwise returns appropriate error.
+ */
+static int ioctl_dev_init(struct v4l2_int_device *s)
+{
+	struct ov8810_sensor *sensor = s->priv;
+	int err;
+
+	err = ov8810_detect(s);
+	if (err < 0) {
+		printk(KERN_ERR "OV8810: Unable to detect " OV8810_DRIVER_NAME
+			" sensor\n");
+		return err;
+	}
+
+	pr_info(OV8810_DRIVER_NAME " chip version 0x%02x detected\n",
+		sensor->sensor_id.revision);
+
+	return 0;
+}
+
+/**
+ * ioctl_enum_framesizes - V4L2 sensor if handler for vidioc_int_enum_framesizes
+ * @s: pointer to standard V4L2 device structure
+ * @frms: pointer to standard V4L2 framesizes enumeration structure
+ *
+ * Returns possible framesizes depending on choosen pixel format
+ **/
+static int ioctl_enum_framesizes(struct v4l2_int_device *s,
+					struct v4l2_frmsizeenum *frms)
+{
+	int ifmt;
+
+	for (ifmt = 0; ifmt < NUM_CAPTURE_FORMATS; ifmt++) {
+		if (frms->pixel_format == ov8810_formats[ifmt].pixelformat)
+			break;
+	}
+	/* Is requested pixelformat not found on sensor? */
+	if (ifmt == NUM_CAPTURE_FORMATS)
+		return -EINVAL;
+
+	/* Do we already reached all discrete framesizes? */
+	/* Filtering out resolution 2 in the table if the isp
+		LSC workaround is disable */
+	if (isp_lsc_workaround_enabled() == 0) {
+		if (frms->index >= OV_NUM_IMAGE_SIZES)
+			return -EINVAL;
+	} else {
+		if (frms->index >= (OV_NUM_IMAGE_SIZES - 1))
+			return -EINVAL;
+	}
+
+	frms->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+
+	if (isp_lsc_workaround_enabled() == 0) {
+		frms->discrete.width = ov8810_sizes[frms->index].width;
+		frms->discrete.height = ov8810_sizes[frms->index].height;
+   } else {
+		if (frms->index < 2) {
+			frms->discrete.width =
+				ov8810_sizes[frms->index].width;
+			frms->discrete.height =
+				ov8810_sizes[frms->index].height;
+		} else {
+			frms->discrete.width =
+				ov8810_sizes[frms->index + 1].width;
+			frms->discrete.height =
+				ov8810_sizes[frms->index + 1].height;
+		}
+	}
+
+	return 0;
+}
+
+const struct v4l2_fract ov8810_frameintervals[] = {
+	{ .numerator = 3, .denominator = 3 },   /* 0 */
+	{ .numerator = 3, .denominator = 6 },   /* 1 */
+	{ .numerator = 3, .denominator = 9 },   /* 2 */
+	{ .numerator = 3, .denominator = 12 },  /* 3 */
+	{ .numerator = 3, .denominator = 15 },  /* 4 */
+	{ .numerator = 3, .denominator = 18 },  /* 5 */
+	{ .numerator = 3, .denominator = 21 },  /* 6 */
+	{ .numerator = 3, .denominator = 24 },  /* 7- SIZE_8M max fps */
+	{ .numerator = 1, .denominator = 10 },  /* 8 */
+	{ .numerator = 1, .denominator = 15 },  /* 9 */
+	{ .numerator = 1, .denominator = 20 },  /* 10 */
+	{ .numerator = 1, .denominator = 21 },  /* 11 - SIZE_2M max fps */
+	{ .numerator = 1, .denominator = 25 },  /* 12 */
+	{ .numerator = 1, .denominator = 26 },  /* 13 - SIZE_1_5M max fps */
+	{ .numerator = 1, .denominator = 30 },  /* 14 - SIZE_500K &
+							SIZE_125K max fps */
+};
+
+static int ioctl_enum_frameintervals(struct v4l2_int_device *s,
+					struct v4l2_frmivalenum *frmi)
+{
+	int ifmt;
+
+	for (ifmt = 0; ifmt < NUM_CAPTURE_FORMATS; ifmt++) {
+		if (frmi->pixel_format == ov8810_formats[ifmt].pixelformat)
+			break;
+	}
+	/* Is requested pixelformat not found on sensor? */
+	if (ifmt == NUM_CAPTURE_FORMATS)
+		return -EINVAL;
+
+	/* Do we already reached all discrete framesizes? */
+
+	if ((frmi->width == ov8810_sizes[SIZE_8M].width) &&
+			(frmi->height == ov8810_sizes[SIZE_8M].height)) {
+		/* The max framerate supported by SIZE_8M capture is 7 fps
+		 */
+		if (frmi->index > 7)
+			return -EINVAL;
+
+	} else if ((frmi->width == ov8810_sizes[SIZE_2M].width) &&
+			(frmi->height == ov8810_sizes[SIZE_2M].height)) {
+		/* The max framerate supported by SIZE_2M capture 21 fps
+		 */
+		if (frmi->index > 11)
+			return -EINVAL;
+	} else if ((frmi->width == ov8810_sizes[SIZE_1_5M].width) &&
+			(frmi->height == ov8810_sizes[SIZE_1_5M].height)) {
+		/* The max framerate supported by SIZE_1_5M capture 26 fps
+		 */
+		if (frmi->index > 13)
+			return -EINVAL;
+	} else {
+		if (frmi->index > 14)
+			return -EINVAL;
+	}
+
+	frmi->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	frmi->discrete.numerator =
+				ov8810_frameintervals[frmi->index].numerator;
+	frmi->discrete.denominator =
+				ov8810_frameintervals[frmi->index].denominator;
+
+	return 0;
+}
+
+static struct v4l2_int_ioctl_desc ov8810_ioctl_desc[] = {
+	{vidioc_int_enum_framesizes_num,
+	  (v4l2_int_ioctl_func *)ioctl_enum_framesizes},
+	{vidioc_int_enum_frameintervals_num,
+	  (v4l2_int_ioctl_func *)ioctl_enum_frameintervals},
+	{vidioc_int_dev_init_num,
+	  (v4l2_int_ioctl_func *)ioctl_dev_init},
+	{vidioc_int_dev_exit_num,
+	  (v4l2_int_ioctl_func *)ioctl_dev_exit},
+	{vidioc_int_s_power_num,
+	  (v4l2_int_ioctl_func *)ioctl_s_power},
+	{vidioc_int_g_priv_num,
+	  (v4l2_int_ioctl_func *)ioctl_g_priv},
+	{vidioc_int_init_num,
+	  (v4l2_int_ioctl_func *)ioctl_init},
+	{vidioc_int_enum_fmt_cap_num,
+	  (v4l2_int_ioctl_func *)ioctl_enum_fmt_cap},
+	{vidioc_int_try_fmt_cap_num,
+	  (v4l2_int_ioctl_func *)ioctl_try_fmt_cap},
+	{vidioc_int_g_fmt_cap_num,
+	  (v4l2_int_ioctl_func *)ioctl_g_fmt_cap},
+	{vidioc_int_s_fmt_cap_num,
+	  (v4l2_int_ioctl_func *)ioctl_s_fmt_cap},
+	{vidioc_int_g_parm_num,
+	  (v4l2_int_ioctl_func *)ioctl_g_parm},
+	{vidioc_int_s_parm_num,
+	  (v4l2_int_ioctl_func *)ioctl_s_parm},
+	{vidioc_int_queryctrl_num,
+	  (v4l2_int_ioctl_func *)ioctl_queryctrl},
+	{vidioc_int_g_ctrl_num,
+	  (v4l2_int_ioctl_func *)ioctl_g_ctrl},
+	{vidioc_int_s_ctrl_num,
+	  (v4l2_int_ioctl_func *)ioctl_s_ctrl},
+/*
+	{ vidioc_int_g_crop_num,
+	  (v4l2_int_ioctl_func *)ioctl_g_crop},
+	{vidioc_int_s_crop_num,
+	  (v4l2_int_ioctl_func *)ioctl_s_crop},
+	{ vidioc_int_cropcap_num,
+	  (v4l2_int_ioctl_func *)ioctl_cropcap},
+*/
+};
+
+static struct v4l2_int_slave ov8810_slave = {
+	.ioctls		= ov8810_ioctl_desc,
+	.num_ioctls	= ARRAY_SIZE(ov8810_ioctl_desc),
+};
+
+static struct v4l2_int_device ov8810_int_device = {
+	.module	= THIS_MODULE,
+	.name	= OV8810_DRIVER_NAME,
+	.priv	= &ov8810,
+	.type	= v4l2_int_type_slave,
+	.u	= {
+		.slave = &ov8810_slave,
+	},
+};
+
+int ov8810_strobe_manual_ready(void)
+{
+    return ov8810_write_regs(ov8810_i2c_client, ov8810_strobe_ready_reg);
+}
+
+
+/*
+ * ov8810_probe - sensor driver i2c probe handler
+ * @client: i2c driver client device structure
+ *
+ * Register sensor as an i2c client device and V4L2
+ * device.
+ */
+static int __init
+ov8810_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct ov8810_sensor *sensor = &ov8810;
+	int err;
+
+	if (i2c_get_clientdata(client))
+		return -EBUSY;
+
+	sensor->pdata = client->dev.platform_data;
+
+	if (!sensor->pdata) {
+		printk(KERN_ERR "OV8810: No platform data?\n");
+		return -ENODEV;
+	}
+
+	sensor->v4l2_int_device = &ov8810_int_device;
+	sensor->i2c_client = client;
+	sensor->dev = &client->dev;
+
+	i2c_set_clientdata(client, sensor);
+
+	/* Set sensor default values */
+	sensor->pix.width = ov8810_sizes[SIZE_500K].width;
+	sensor->pix.height = ov8810_sizes[SIZE_500K].height;
+	sensor->pix.pixelformat = V4L2_PIX_FMT_SGRBG10;
+
+	/* Set min/max limits */
+	sensor->exposure.min_exp_time = OV8810_MIN_EXPOSURE;
+	sensor->exposure.fps_max_exp_time = 33333;
+	sensor->exposure.abs_max_exp_time = OV8810_MAX_EXPOSURE;
+	sensor->exposure.min_linear_gain = OV8810_MIN_LINEAR_GAIN;
+	sensor->exposure.max_linear_gain = OV8810_MAX_LINEAR_GAIN;
+
+	err = v4l2_int_device_register(sensor->v4l2_int_device);
+	if (err)
+		i2c_set_clientdata(client, NULL);
+
+       ov8810_i2c_client = client;
+	return 0;
+}
+
+/*
+ * ov8810_remove - sensor driver i2c remove handler
+ * @client: i2c driver client device structure
+ *
+ * Unregister sensor as an i2c client device and V4L2
+ * device. Complement of ov8810_probe().
+ */
+static int __exit
+ov8810_remove(struct i2c_client *client)
+{
+	struct ov8810_sensor *sensor = i2c_get_clientdata(client);
+
+	if (!client->adapter)
+		return -ENODEV;	/* our client isn't attached */
+
+	v4l2_int_device_unregister(sensor->v4l2_int_device);
+	i2c_set_clientdata(client, NULL);
+
+	return 0;
+}
+
+static const struct i2c_device_id ov8810_id[] = {
+	{ OV8810_DRIVER_NAME, 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, ov8810_id);
+
+static struct i2c_driver ov8810sensor_i2c_driver = {
+	.driver = {
+		.name	= OV8810_DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+	.probe	= ov8810_probe,
+	.remove	= __exit_p(ov8810_remove),
+	.id_table = ov8810_id,
+};
+
+/*
+ * ov8810sensor_init - sensor driver module_init handler
+ *
+ * Registers driver as an i2c client driver.  Returns 0 on success,
+ * error code otherwise.
+ */
+static int __init ov8810sensor_init(void)
+{
+	int err;
+
+	err = i2c_add_driver(&ov8810sensor_i2c_driver);
+	if (err) {
+		printk(KERN_ERR "OV8810: Failed to register" \
+			OV8810_DRIVER_NAME ".\n");
+		return err;
+	}
+	return 0;
+}
+late_initcall(ov8810sensor_init);
+
+/*
+ * ov8810sensor_cleanup - sensor driver module_exit handler
+ *
+ * Unregisters/deletes driver as an i2c client driver.
+ * Complement of ov8810sensor_init.
+ */
+static void __exit ov8810sensor_cleanup(void)
+{
+	i2c_del_driver(&ov8810sensor_i2c_driver);
+}
+module_exit(ov8810sensor_cleanup);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("OV8810 camera sensor driver");
diff --git a/drivers/media/video/ov8810.h b/drivers/media/video/ov8810.h
new file mode 100644
index 0000000..40cc01b
--- /dev/null
+++ b/drivers/media/video/ov8810.h
@@ -0,0 +1,985 @@
+/*
+ * drivers/media/video/ov8810.h
+ *
+ * Register definitions for the OV8810 CameraChip.
+ *
+ * Author: Pallavi Kulkarni (ti.com)
+ *
+ * Copyright (C) 2008 Texas Instruments.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+/* #if 0
+#define SENSOR_OV8810_DEBUG
+#endif */
+
+#ifdef SENSOR_OV8810_DEBUG
+#define DPRINTK_OV8810(format, ...)\
+	printk(KERN_INFO "OV8810: " format, ## __VA_ARGS__)
+#else
+#define DPRINTK_OV8810(format, ...)
+#endif
+
+#ifndef OV8810_H
+#define OV8810_H
+#define OV8810_I2C_ADDR		(0x6c >> 1)
+
+/* ISP uses a 10-bit value, OV8810 uses a 12-bit value */
+#define OV8810_BLACK_LEVEL_10BIT	8
+
+/* ISP Private IOCTLs */
+#define V4L2_CID_PRIVATE_SENSOR_REG_REQ		(V4L2_CID_PRIVATE_BASE + 20)
+#define V4L2_CID_PRIVATE_SENSOR_ID_REQ		(V4L2_CID_PRIVATE_BASE + 22)
+#define V4L2_CID_PRIVATE_COLOR_BAR     		(V4L2_CID_PRIVATE_BASE + 23)
+#define V4L2_CID_PRIVATE_FLASH_NEXT_FRAME	(V4L2_CID_PRIVATE_BASE + 24)
+#define V4L2_CID_PRIVATE_ORIENTATION     	(V4L2_CID_PRIVATE_BASE + 25)
+#define V4L2_CID_PRIVATE_LENS_CORRECTION     	(V4L2_CID_PRIVATE_BASE + 26)
+#define V4L2_CID_PRIVATE_SENSOR_PARAMS_REQ	(V4L2_CID_PRIVATE_BASE + 27)
+#define V4L2_CID_PRIVATE_START_MECH_SHUTTER_CAPTURE (V4L2_CID_PRIVATE_BASE + 28)
+#define V4L2_CID_PRIVATE_SHUTTER_PARAMS     	(V4L2_CID_PRIVATE_BASE + 29)
+
+/* Register initialization tables for ov8810 */
+/* Terminating list entry for reg */
+#define OV8810_REG_TERM		0xFFFF
+/* Terminating list entry for val */
+#define OV8810_VAL_TERM		0xFF
+
+#define OV8810_USE_XCLKA	0
+#define OV8810_USE_XCLKB	1
+
+#define OV8810_CSI2_VIRTUAL_ID	0x1
+
+#define DEBUG_BASE		0x08000000
+
+#define VAUX_2_8_V		0x09
+#define VAUX_1_8_V		0x05
+#define VAUX_DEV_GRP_P1	0x20
+#define VAUX_DEV_GRP_NONE	0x00
+
+/* Sensor specific GPIO signals */
+#define OV8810_RESET_GPIO	98
+#define OV8810_STANDBY_GPIO	64
+
+/* FPS Capabilities */
+#define OV8810_MIN_FPS			3
+#define OV8810_DEF_FPS			15
+#define OV8810_MAX_FPS			30
+
+/* Frame Delays */
+#define OV8810_GAIN_FRAME_DELAY 1
+#define OV8810_EXP_TIME_FRAME_DELAY 2
+
+#define SENSOR_DETECTED		1
+#define SENSOR_NOT_DETECTED	0
+
+/* XCLK Frequency in Hz*/
+#define OV8810_XCLK_MIN		27000000
+#define OV8810_XCLK_MAX		27000000
+
+#define OV8810_MAX_FRAME_LENGTH_LINES 0xFFF8
+#define OV8810_MAX_LINE_LENGTH_PCK 0xFFF0
+
+/* Gain Values (linear, Q8) */
+#define OV8810_MIN_LINEAR_GAIN	((u16)(1.0 * 256))
+#define OV8810_MAX_LINEAR_GAIN	((u16)(31.0 * 256))
+
+/* Exposure time values (usecs)*/
+#define OV8810_MIN_EXPOSURE	100
+#define OV8810_MAX_EXPOSURE	1000000
+
+
+/* Product ID */
+#define OV8810_PID			0x8810
+/* Max supported Rev */
+#define OV8810_REV			3
+
+/* ------------------ Register defines ------------------ */
+/*
+ * System Control Registers
+ */
+#define OV8810_AGCL				0x3000
+#define OV8810_AECL_H			0x3002
+#define OV8810_AECL_L			0x3003
+#define OV8810_PIDH				0x300A
+#define OV8810_PIDL				0x300B
+#define OV8810_R_PLL1			0x300E
+#define OV8810_R_PLL1_VT_SYS_DIV_SHIFT 4
+#define OV8810_R_PLL1_VT_SYS_DIV_MASK (0xF << \
+	OV8810_R_PLL1_VT_SYS_DIV_SHIFT)
+#define OV8810_R_PLL1_DIV8_MASK 	0x7
+#define OV8810_R_PLL2			0x300F
+#define OV8810_R_PLL2_OP_SYS_DIV_SHIFT 4
+#define OV8810_R_PLL2_OP_SYS_DIV_MASK (0xF << \
+	OV8810_R_PLL2_OP_SYS_DIV_SHIFT)
+#define OV8810_R_PLL2_OP_PIX_DIV_MASK 	0xF
+#define OV8810_R_PLL3			0x3010
+#define OV8810_R_PLL3_PLL_MULT_MASK 	0x7F
+#define OV8810_R_PLL4			0x3011
+#define OV8810_R_PLL4_PRE_DIV_MASK 		0xF
+
+#define OV8810_SYS				0x3012
+#define OV8810_ADDVS_H				0x301E
+#define OV8810_ADDVS_L				0x301F
+#define OV8810_FRM_LEN_LINES_H			0x3020
+#define OV8810_FRM_LEN_LINES_L			0x3021
+#define OV8810_LINE_LEN_PCK_H			0x3022
+#define OV8810_LINE_LEN_PCK_L			0x3023
+#define OV8810_X_ADDR_START_H			0x3024
+#define OV8810_X_ADDR_START_L			0x3025
+#define OV8810_Y_ADDR_START_H			0x3026
+#define OV8810_Y_ADDR_START_L			0x3027
+#define OV8810_X_ADDR_END_H			0x3028
+#define OV8810_X_ADDR_END_L			0x3029
+#define OV8810_Y_ADDR_END_H			0x302A
+#define OV8810_Y_ADDR_END_L			0x302B
+#define OV8810_X_OUTPUT_SIZE_H			0x302C
+#define OV8810_X_OUTPUT_SIZE_L			0x302D
+#define OV8810_Y_OUTPUT_SIZE_H			0x302E
+#define OV8810_Y_OUTPUT_SIZE_L			0x302F
+#define OV8810_RESERVED_3058			0x3058
+#define OV8810_IO_CTRL2				0x30B2
+#define OV8810_DSIO0				0x30B3
+#define OV8810_DSIO0_RPCLK_DIV_MASK 	0x3
+#define OV8810_FRS0				0x30B7
+#define OV8810_RESERVED_30E1			0x30E1
+#define OV8810_FRS1				0x30E4
+#define OV8810_FRS2				0x30E5
+#define OV8810_FRS3				0x30E6
+#define OV8810_FRS4				0x30E7
+#define OV8810_FRS4_STRB_SOURCE_SEL_SHIFT 1
+#define OV8810_FRS5				0x30E8
+#define OV8810_FRS5_ROLLING_SHUT_STRB_EN_SHIFT 7
+#define OV8810_FRS5_STRB_PLS_WIDTH_SHIFT 2
+#define OV8810_FRS5_STROBE_MODE_SHIFT 0
+#define OV8810_FRS6				0x30EA
+#define OV8810_FRS7				0x30EB
+#define OV8810_IMAGE_SYSTEM			0x30FA
+#define OV8810_IMAGE_TRANSFORM			0x30F8
+#define OV8810_IMAGE_TRANSFORM_HSUB_MASK (0x3)
+#define OV8810_IMAGE_TRANSFORM_VSUB_SHIFT 2
+#define OV8810_IMAGE_TRANSFORM_VSUB_MASK (0x3 << \
+	OV8810_IMAGE_TRANSFORM_VSUB_SHIFT)
+#define OV8810_IMAGE_TRANSFORM_HMIRROR_SHIFT 6
+#define OV8810_IMAGE_TRANSFORM_HMIRROR_MASK (0x1 << \
+	OV8810_IMAGE_TRANSFORM_HMIRROR_SHIFT)
+#define OV8810_IMAGE_TRANSFORM_VFLIP_SHIFT 7
+#define OV8810_IMAGE_TRANSFORM_VFLIP_MASK (0x1 << \
+	OV8810_IMAGE_TRANSFORM_VFLIP_SHIFT)
+#define OV8810_GROUP_WR			0x30FF
+#define OV8810_ISP_ENBL_0			0x3300
+#define OV8810_CBAR	 			0x3303
+#define OV8810_DIG_GAIN 			0x3309
+#define OV8810_SIZE_H0 				0x3316
+#define OV8810_LENC				0x33E4
+#define OV8810_DVP_CTRL08			0x3508
+#define OV8810_DVP_CTRL0E			0x350E
+
+/* len correction */
+#define LENC_1_1_DOWNSAMPLING 0x02
+#define LENC_2_1_DOWNSAMPLING 0x07
+#define LENC_4_1_DOWNSAMPLING 0x0b
+#define LENC_8_1_DOWNSAMPLING 0x0f
+
+/*
+ * END - System Control Registers
+ */
+
+
+/*
+ * OUT_TOP Registers
+ */
+
+#define OV8810_MIPI_CTRL01	0x3601
+
+#define OV8810_MIPI_CTRL02	0x3602
+#define OV8810_MIPI_CTRL02_VIRTUALCH_ID_MASK	(0x3 << 6)
+
+
+#define OV8810_MIPI_CTRL0A	0x360A
+#define OV8810_MIPI_CTRL0B	0x360B
+#define OV8810_MIPI_CTRL0B_DSBL_DATA_LANE_2_MASK  0x1
+#define OV8810_MIPI_CTRL0B_DSBL_DATA_LANE_1_MASK  0x2
+
+#define OV8810_MIPI_CTRL14	0x3614
+#define OV8810_MIPI_CTRL14_MIN_HS_ZERO_NUI_SHIFT	2
+#define OV8810_MIPI_CTRL14_MIN_HS_ZERO_NUI_MASK		(0x3F << \
+				OV8810_MIPI_CTRL14_MIN_HS_ZERO_NUI_SHIFT)
+#define OV8810_MIPI_CTRL14_MIN_HS_ZERO_H_MASK	0x3
+
+#define OV8810_MIPI_CTRL15	0x3615
+#define OV8810_MIPI_CTRL15_MIN_HS_ZERO_L_MASK	0xFF
+
+#define OV8810_MIPI_CTRL16	0x3616
+#define OV8810_MIPI_CTRL16_MIN_HS_TRAIL_NUI_SHIFT	2
+#define OV8810_MIPI_CTRL16_MIN_HS_TRAIL_NUI_MASK	(0x3F << \
+				OV8810_MIPI_CTRL16_MIN_HS_TRAIL_NUI_SHIFT)
+#define OV8810_MIPI_CTRL16_MIN_HS_TRAIL_H_MASK	0x3
+
+#define OV8810_MIPI_CTRL17	0x3617
+#define OV8810_MIPI_CTRL17_MIN_HS_TRAIL_L_MASK	0xFF
+
+#define OV8810_MIPI_CTRL18	0x3618
+#define OV8810_MIPI_CTRL18_MIN_CLK_ZERO_NUI_SHIFT	2
+#define OV8810_MIPI_CTRL18_MIN_CLK_ZERO_NUI_MASK	(0x3F << \
+				OV8810_MIPI_CTRL18_MIN_CLK_ZERO_NUI_SHIFT)
+#define OV8810_MIPI_CTRL18_MIN_CLK_ZERO_H_MASK	0x3
+
+#define OV8810_MIPI_CTRL19	0x3619
+#define OV8810_MIPI_CTRL19_MIN_CLK_ZERO_L_MASK	0xFF
+
+#define OV8810_MIPI_CTRL1A	0x361A
+#define OV8810_MIPI_CTRL1A_MIN_CLK_PREPARE_NUI_SHIFT	2
+#define OV8810_MIPI_CTRL1A_MIN_CLK_PREPARE_NUI_MASK		(0x3F << \
+				OV8810_MIPI_CTRL1A_MIN_CLK_PREPARE_NUI_SHIFT)
+#define OV8810_MIPI_CTRL1A_MIN_CLK_PREPARE_H_MASK	0x3
+
+#define OV8810_MIPI_CTRL1B	0x361B
+#define OV8810_MIPI_CTRL1B_MIN_CLK_PREPARE_L_MASK	0xFF
+
+#define OV8810_MIPI_CTRL1C	0x361C
+#define OV8810_MIPI_CTRL1C_MAX_CLK_PREPARE_NUI_SHIFT	2
+#define OV8810_MIPI_CTRL1C_MAX_CLK_PREPARE_NUI_MASK		(0x3F << \
+				OV8810_MIPI_CTRL1C_MAX_CLK_PREPARE_NUI_SHIFT)
+#define OV8810_MIPI_CTRL1C_MAX_CLK_PREPARE_H_MASK	0x3
+
+#define OV8810_MIPI_CTRL1D	0x361D
+#define OV8810_MIPI_CTRL1D_MAX_CLK_PREPARE_L_MASK	0xFF
+
+#define OV8810_MIPI_CTRL1E	0x361E
+#define OV8810_MIPI_CTRL1E_MIN_CLK_POST_NUI_SHIFT	2
+#define OV8810_MIPI_CTRL1E_MIN_CLK_POST_NUI_MASK	(0x3F << \
+				OV8810_MIPI_CTRL1E_MIN_CLK_POST_NUI_SHIFT)
+#define OV8810_MIPI_CTRL1E_MIN_CLK_POST_H_MASK	0x3
+
+#define OV8810_MIPI_CTRL1F	0x361F
+#define OV8810_MIPI_CTRL1F_MIN_CLK_POST_L_MASK	0xFF
+
+#define OV8810_MIPI_CTRL20	0x3620
+#define OV8810_MIPI_CTRL20_MIN_CLK_TRAIL_NUI_SHIFT	2
+#define OV8810_MIPI_CTRL20_MIN_CLK_TRAIL_NUI_MASK	(0x3F << \
+				OV8810_MIPI_CTRL20_MIN_CLK_TRAIL_NUI_SHIFT)
+#define OV8810_MIPI_CTRL20_MIN_CLK_TRAIL_H_MASK	0x3
+
+#define OV8810_MIPI_CTRL21	0x3621
+#define OV8810_MIPI_CTRL21_MIN_CLK_TRAIL_L_MASK	0xFF
+
+#define OV8810_MIPI_CTRL22	0x3622
+#define OV8810_MIPI_CTRL22_MIN_LPX_P_NUI_SHIFT	2
+#define OV8810_MIPI_CTRL22_MIN_LPX_P_NUI_MASK	(0x3F << \
+					OV8810_MIPI_CTRL22_MIN_LPX_P_NUI_SHIFT)
+#define OV8810_MIPI_CTRL22_MIN_LPX_P_H_MASK	0x3
+
+#define OV8810_MIPI_CTRL23	0x3623
+#define OV8810_MIPI_CTRL23_MIN_LPX_P_L_MASK	0xFF
+
+#define OV8810_MIPI_CTRL24	0x3624
+#define OV8810_MIPI_CTRL24_MIN_HS_PREPARE_NUI_SHIFT	2
+#define OV8810_MIPI_CTRL24_MIN_HS_PREPARE_NUI_MASK	(0x3F << \
+				OV8810_MIPI_CTRL24_MIN_HS_PREPARE_NUI_SHIFT)
+#define OV8810_MIPI_CTRL24_MIN_HS_PREPARE_H_MASK	0x3
+
+#define OV8810_MIPI_CTRL25	0x3625
+#define OV8810_MIPI_CTRL25_MIN_HS_PREPARE_L_MASK	0xFF
+
+#define OV8810_MIPI_CTRL26	0x3626
+#define OV8810_MIPI_CTRL26_MAX_HS_PREPARE_NUI_SHIFT	2
+#define OV8810_MIPI_CTRL26_MAX_HS_PREPARE_NUI_MASK	(0x3F << \
+				OV8810_MIPI_CTRL26_MAX_HS_PREPARE_NUI_SHIFT)
+#define OV8810_MIPI_CTRL26_MAX_HS_PREPARE_H_MASK	0x3
+
+#define OV8810_MIPI_CTRL27	0x3627
+#define OV8810_MIPI_CTRL27_MAX_HS_PREPARE_L_MASK	0xFF
+
+#define OV8810_MIPI_CTRL28	0x3628
+#define OV8810_MIPI_CTRL28_MIN_HS_EXIT_NUI_SHIFT	2
+#define OV8810_MIPI_CTRL28_MIN_HS_EXIT_NUI_MASK	(0x3F << \
+				OV8810_MIPI_CTRL28_MIN_HS_EXIT_NUI_SHIFT)
+#define OV8810_MIPI_CTRL28_MIN_HS_EXIT_H_MASK	0x3
+
+#define OV8810_MIPI_CTRL29	0x3629
+#define OV8810_MIPI_CTRL29_MIN_HS_EXIT_L_MASK	0xFF
+
+/*
+ * END - OUT_TOP Registers
+ */
+/* ------------------------------------------------------ */
+
+int ov8810_write_reg(struct i2c_client *client, u16 reg, u8 val);
+
+/* Exposure time values */
+#define DEF_MIN_EXPOSURE	250
+#define DEF_MAX_EXPOSURE	128000
+#define DEF_EXPOSURE	    33000
+#define EXPOSURE_STEP	    50
+
+#define DEF_LINEAR_GAIN	(2*256)
+#define LINEAR_GAIN_STEP	0x1
+
+struct ov8810_sensor_regif {
+	u16 len;
+	u32 addr;
+	u32 val;
+} ;
+
+enum ov8810_orientation {
+	OV8810_NO_HORZ_FLIP_OR_VERT_FLIP = 0,
+	OV8810_HORZ_FLIP_ONLY,
+	OV8810_VERT_FLIP_ONLY,
+	OV8810_HORZ_FLIP_AND_VERT_FLIP
+};
+
+enum ov8810_shutter_type {
+	ROLLING_SHUTTER_TYPE = 0,
+	MECH_SHUTTER_TYPE
+};
+
+enum ov8810_flash_type {
+	LED_FLASH_TYPE = 0,
+	XENON_FLASH_TYPE
+};
+
+/* define a structure for ov8810 register initialization values */
+struct ov8810_reg {
+	unsigned int reg;
+	unsigned char val;
+};
+
+struct capture_size_ov {
+	unsigned long width;
+	unsigned long height;
+};
+
+/*
+ * struct ov8810_clk_settings - struct for storage of sensor
+ * clock settings
+ * @pll_mult: pll multiplier
+ * @pll_pre_div: pre pll divider
+ * @vt_sys_div: video system clock divider
+ * @op_pix_div: output pixel clock divider
+ * @op_sys_div: output system clock divider
+ * @div8: pixel bit divider
+ * @rp_clk_div: video pixel clock divider
+ */
+struct ov8810_clk_settings {
+	u16 pll_mult;
+	u16 pll_pre_div;
+	u16 vt_sys_div;
+	u16 op_sys_div;
+	u16 op_pix_div;
+	u16 div8;
+	u16 rp_clk_div;
+};
+
+/*
+ * struct ov8810_frame_settings - struct for storage of sensor
+ * frame settings
+ * @frame_len_lines: number of lines in frame
+ * @line_len_pck: number of pixels in line
+ */
+struct ov8810_frame_settings {
+	u16	frame_len_lines_min;
+	u16	frame_len_lines;
+	u16	line_len_pck_min;
+	u16	line_len_pck;
+	u16	x_addr_start;
+	u16	x_addr_end;
+	u16	y_addr_start;
+	u16	y_addr_end;
+	u16	x_output_size;
+	u16	y_output_size;
+	u8 v_subsample;
+	u8 h_subsample;
+	struct v4l2_fract min_time_per_frame;
+};
+
+/*
+ * struct ov8810_mipi_settings - struct for storage of sensor
+ * initial exposure settings
+ * @coarse_int_tm: coarse resolution interval time (line times)
+ * @fine_int_tm: fine resolution interval time (pixel times)
+ */
+struct ov8810_mipi_settings {
+	u16	num_data_lanes;
+	u16	hs_settle_lower;
+	u16	hs_settle_upper;
+};
+
+/*
+ * struct ov8810_sensor_settings - struct for storage of
+ * sensor settings.
+ */
+struct ov8810_sensor_settings {
+	struct ov8810_clk_settings clk;
+	struct ov8810_frame_settings frame;
+	struct ov8810_mipi_settings mipi;
+};
+
+/* Array of image sizes supported by OV8810.  These must be ordered from
+ * smallest image size to largest.
+ */
+const static struct capture_size_ov ov8810_sizes[] = {
+	/* SIZE_125K */
+	{ 408, 306 },
+	/* SIZE_500K */
+	{ 816, 612 },
+	/* SIZE_1_5M */
+	{ 1632, 918 },
+	/* SIZE_2M */
+	{ 1632, 1224 },
+	/* SIZE_8M */
+	{ 3264, 2448 },
+};
+
+enum image_size_ov {
+	SIZE_125K,
+	SIZE_500K,
+	SIZE_1_5M,
+	SIZE_2M,
+	SIZE_8M
+};
+enum pixel_format_ov {
+	RAW10
+};
+
+#define OV_NUM_IMAGE_SIZES		5
+#define OV_NUM_PIXEL_FORMATS		1
+#define OV_NUM_FPS			3
+
+const static struct ov8810_reg ov8810_common[OV_NUM_IMAGE_SIZES][150] = {
+	/* SIZE_408x306_Default settings */
+	{
+		{0x3100, 0x06},
+		{0x30fa, 0x00},
+		{0x3302, 0x20},
+		{0x3099, 0x81},
+		{0x309d, 0x64},
+		{0x309e, 0x2d},
+		{0x3321, 0x02},
+		{0x3322, 0x04},
+		{0x3328, 0x40},
+		{0x3329, 0x00},
+		{0x3306, 0x00},
+		{0x3316, 0x03},
+		{0x33e5, 0x02},
+		{0x3058, 0x01},
+		{0x3071, 0x50},
+		{0x3300, 0xef},
+		{0x3334, 0x02},
+		{0x3331, 0x20},
+		{0x3332, 0x20},
+		{0x3301, 0x07},	/* enable dig_gain & vario_pixel */
+		{0x3308, 0x3b},	/* set dig_gain manual mode */
+		{0x3309, 0x00},	/* set dig_gain = 1x */
+		{0x3082, 0x80},
+		{0x331e, 0x94},
+		{0x331f, 0x6e},
+		{0x3092, 0x00},
+		{0x30ab, 0x44},
+		{0x3095, 0x0a},
+		{0x308d, 0x00},
+		{0x3082, 0x00},
+		{0x3080, 0x40},
+		{0x309f, 0x23},
+		{0x3084, 0x44},
+		{0x3016, 0x03},
+		{0x308a, 0x02},
+		{0x30e9, 0x09},
+		{0x3087, 0x41},
+		{0x3072, 0x0d},
+		{0x3319, 0x02},
+		{0x3300, 0xe3},
+		{0x309e, 0x1b},
+		{0x30e3, 0x0e},
+		{0x30f0, 0x00},
+		{0x30f2, 0x00},
+		{0x30f4, 0x90},
+		{0x309e, 0x09},
+		{0x3347, 0x00},
+		{0x3100, 0x88},
+		{0x3101, 0x77},
+		{0x3092, 0x00},
+		{0x30f0, 0x10},
+		{0x30f1, 0x56},
+		{0x30fb, 0x50},
+		{0x308d, 0x02},
+		{0x3090, 0x2e},
+		{0x3095, 0x0a},
+		{0x3071, 0x40},
+		{0x3013, 0x00},	/* AEC/AGC off */
+		{0x3300, 0x81},	/* all ISP except BLC off */
+		{0x3320, 0xc2},	/* AWB use manual 1x gain */
+		{0x30e7, 0x41},	/* active lo FREX */
+		{OV8810_REG_TERM, OV8810_VAL_TERM},
+	},
+	/* SIZE_816x612_Default settings */
+	{
+		{0x3100, 0x06},
+		{0x30fa, 0x00},
+		{0x3302, 0x20},
+		{0x3099, 0x81},
+		{0x309d, 0x64},
+		{0x309e, 0x2d},
+		{0x3321, 0x02},
+		{0x3322, 0x04},
+		{0x3328, 0x40},
+		{0x3329, 0x00},
+		{0x3306, 0x00},
+		{0x3316, 0x03},
+		{0x33e5, 0x01},
+		{0x3058, 0x01},
+		{0x3071, 0x50},
+		{0x3300, 0xef},
+		{0x3334, 0x02},
+		{0x3331, 0x20},
+		{0x3332, 0x20},
+		{0x3301, 0x07},	/* enable dig_gain & vario_pixel */
+		{0x3308, 0x3b},	/* set dig_gain manual mode */
+		{0x3309, 0x00},	/* set dig_gain = 1x */
+		{0x3082, 0x80},
+		{0x331e, 0x94},
+		{0x331f, 0x6e},
+		{0x3092, 0x00},
+		{0x30ab, 0x44},
+		{0x3095, 0x0a},
+		{0x308d, 0x00},
+		{0x3082, 0x00},
+		{0x3080, 0x40},
+		{0x309f, 0x23},
+		{0x3084, 0x44},
+		{0x3016, 0x03},
+		{0x308a, 0x01},
+		{0x30e9, 0x09},
+		{0x3087, 0x41},
+		{0x3072, 0x0d},
+		{0x3319, 0x02},
+		{0x3300, 0xe3},
+		{0x309e, 0x1b},
+		{0x30e3, 0x0e},
+		{0x30f0, 0x00},
+		{0x30f2, 0x00},
+		{0x30f4, 0x90},
+		{0x309e, 0x09},
+		{0x3347, 0x00},
+		{0x3100, 0x88},
+		{0x3101, 0x77},
+		{0x3092, 0x00},
+		{0x30f0, 0x10},
+		{0x30f1, 0x56},
+		{0x30fb, 0x50},
+		{0x308d, 0x02},
+		{0x3090, 0x2e},
+		{0x3095, 0x0a},
+		{0x3071, 0x40},
+		{0x3013, 0x00},	/* AEC/AGC off */
+		{0x3300, 0x81},	/* all ISP except BLC off */
+		{0x3320, 0xc2},	/* AWB use manual 1x gain */
+		{0x30e7, 0x41},	/* active lo FREX */
+		{OV8810_REG_TERM, OV8810_VAL_TERM},
+	},
+	/* SIZE_1632x918 Default settings */
+	{
+		{0x3100, 0x06},
+		{0x30fa, 0x00},
+		{0x3302, 0x20},
+		{0x3099, 0x81},
+		{0x309d, 0x64},
+		{0x309e, 0x2d},
+		{0x3321, 0x02},
+		{0x3322, 0x04},
+		{0x3328, 0x40},
+		{0x3329, 0x00},
+		{0x3306, 0x00},
+		{0x3316, 0x03},
+		{0x33e5, 0x00},
+		{0x3058, 0x01},
+		{0x3071, 0x50},
+		{0x3300, 0xef},
+		{0x3334, 0x02},
+		{0x3331, 0x20},
+		{0x3332, 0x20},
+		{0x3301, 0x03}, /* enable dig_gain */
+		{0x3308, 0x3b}, /* set dig_gain manual mode */
+		{0x3309, 0x00}, /* set dig_gain = 1x */
+		{0x3082, 0x80},
+		{0x331e, 0x94},
+		{0x331f, 0x6e},
+		{0x3092, 0x00},
+		{0x30ab, 0x44},
+		{0x3095, 0x0a},
+		{0x308d, 0x00},
+		{0x3082, 0x00},
+		{0x3080, 0x40},
+		{0x309f, 0x23},
+		{0x3084, 0x44},
+		{0x3016, 0x03},
+		{0x308a, 0x02},
+		{0x30e9, 0x09},
+		{0x3087, 0x41},
+		{0x3072, 0x0d},
+		{0x3319, 0x04},
+		{0x3300, 0xe3},
+		{0x309e, 0x1b},
+		{0x30e3, 0x0e},
+		{0x30f0, 0x00},
+		{0x30f2, 0x00},
+		{0x30f4, 0x90},
+		{0x309e, 0x09},
+		{0x3347, 0x00},
+		{0x3100, 0x88},
+		{0x3101, 0x77},
+		{0x3092, 0x00},
+		{0x30f0, 0x10},
+		{0x30f1, 0x56},
+		{0x30fb, 0x50},
+		{0x308d, 0x02},
+		{0x3090, 0x2e},
+		{0x3095, 0x0a},
+		{0x3071, 0x40},
+		{0x3013, 0x00},	/* AEC/AGC off */
+		{0x3300, 0x81},	/* all ISP except BLC off */
+		{0x3320, 0xc2},	/* AWB use manual 1x gain */
+		{0x30e7, 0x41},	/* active lo FREX */
+		{OV8810_REG_TERM, OV8810_VAL_TERM},
+	},
+	/* SIZE_1632x1224 Default settings */
+	{
+		{0x3100, 0x06},
+		{0x30fa, 0x00},
+		{0x3302, 0x20},
+		{0x3099, 0x81},
+		{0x309d, 0x64},
+		{0x309e, 0x2d},
+		{0x3321, 0x02},
+		{0x3322, 0x04},
+		{0x3328, 0x40},
+		{0x3329, 0x00},
+		{0x3306, 0x00},
+		{0x3316, 0x03},
+		{0x33e5, 0x00},
+		{0x3058, 0x01},
+		{0x3071, 0x50},
+		{0x3300, 0xef},
+		{0x3334, 0x02},
+		{0x3331, 0x20},
+		{0x3332, 0x20},
+		{0x3301, 0x03},	/* enable dig_gain */
+		{0x3308, 0x3b},	/* set dig_gain manual mode */
+		{0x3309, 0x00},	/* set dig_gain = 1x */
+		{0x3082, 0x80},
+		{0x331e, 0x94},
+		{0x331f, 0x6e},
+		{0x3092, 0x00},
+		{0x30ab, 0x44},
+		{0x3095, 0x0a},
+		{0x308d, 0x00},
+		{0x3082, 0x00},
+		{0x3080, 0x40},
+		{0x309f, 0x23},
+		{0x3084, 0x44},
+		{0x3016, 0x03},
+		{0x308a, 0x02},
+		{0x30e9, 0x09},
+		{0x3087, 0x41},
+		{0x3072, 0x0d},
+		{0x3319, 0x04},
+		{0x3300, 0xe3},
+		{0x309e, 0x1b},
+		{0x30e3, 0x0e},
+		{0x30f0, 0x00},
+		{0x30f2, 0x00},
+		{0x30f4, 0x90},
+		{0x309e, 0x09},
+		{0x3347, 0x00},
+		{0x3100, 0x88},
+		{0x3101, 0x77},
+		{0x3092, 0x00},
+		{0x30f0, 0x10},
+		{0x30f1, 0x56},
+		{0x30fb, 0x50},
+		{0x308d, 0x02},
+		{0x3090, 0x2e},
+		{0x3095, 0x0a},
+		{0x3071, 0x40},
+		{0x3013, 0x00},	/* AEC/AGC off */
+		{0x3300, 0x81},	/* all ISP except BLC off */
+		{0x3320, 0xc2},	/* AWB use manual 1x gain */
+		{0x30e7, 0x41},	/* active lo FREX */
+		{OV8810_REG_TERM, OV8810_VAL_TERM},
+	},
+	/* SIZE_3264x2448 Default settings */
+	{
+		{0x3100, 0x06},
+		{0x30fa, 0x00},
+		{0x3302, 0x20},
+		{0x3099, 0x81},
+		{0x309d, 0x64},
+		{0x309e, 0x2d},
+		{0x3321, 0x02},
+		{0x3322, 0x04},
+		{0x3328, 0x40},
+		{0x3329, 0x00},
+		{0x3306, 0x00},
+		{0x3316, 0x03},
+		{0x33e5, 0x00},
+		{0x3058, 0x01},
+		{0x3071, 0x40},
+		{0x3300, 0xef},
+		{0x3334, 0x02},
+		{0x3331, 0x20},
+		{0x3332, 0x20},
+		{0x3301, 0x03},	/* enable dig_gain */
+		{0x3308, 0x3b},	/* set dig_gain manual mode */
+		{0x3309, 0x00},	/* set dig_gain = 1x */
+		{0x3082, 0x80},
+		{0x331e, 0x94},
+		{0x331f, 0x6e},
+		{0x331c, 0x28},
+		{0x331d, 0x21},
+		{0x3092, 0x00},
+		{0x30ab, 0x44},
+		{0x3095, 0x0a},
+		{0x308d, 0x00},
+		{0x3082, 0x00},
+		{0x3080, 0x40},
+		{0x309f, 0x23},	/* reset DSP */
+		{0x3084, 0x44},
+		{0x3016, 0x03},
+		{0x308a, 0x01},
+		{0x30e9, 0x09},
+		{0x3087, 0x41},
+		{0x3305, 0xa0},
+		{0x3072, 0x01},
+		{0x3319, 0x08},
+		{0x3300, 0xe3},
+		{0x309e, 0x1b},
+		{0x30e3, 0x0e},
+		{0x30f0, 0x00},
+		{0x30f2, 0x00},
+		{0x30f4, 0x90},
+		{0x3347, 0x00},
+		{0x3100, 0x88},
+		{0x3101, 0x77},
+		{0x3092, 0x00},
+		{0x30f0, 0x10},
+		{0x30f1, 0x56},
+		{0x30fb, 0x50},
+		{0x308d, 0x02},
+		{0x3090, 0x2e},
+		{0x3095, 0x0a},
+		{0x3071, 0x40},
+		{0x3013, 0x00},	/* AEC/AGC, off */
+		{0x3300, 0x83},	/* all, ISP, except BLC, off */
+		{0x3320, 0xc2},	/* AWB, use, manual, 1x, gain */
+		{0x30e7, 0x41},	/* active lo FREX */
+		{OV8810_REG_TERM, OV8810_VAL_TERM},
+	},
+};
+
+/* 50-60 Hz Detection settings */
+const static struct ov8810_reg ov8810_50_60_hz_detect_tbl[] = {
+	{0x3014, 0x40},
+	{0x304c, 0x0c},
+	{0x30a4, 0x00},
+	{0x30ad, 0x04},
+	{0x3040, 0x00},
+	{0x3041, 0x34},
+	{0x3044, 0x28},
+	{0x3045, 0x98},
+	{0x3046, 0x00},
+	{0x3047, 0x00},
+	{0x3048, 0x01},
+	{0x3049, 0xc2},
+	{0x304e, 0x02},
+	{0x304a, 0xaf},	/* 27Mhz */
+	{0x304b, 0xc8},	/* 27Mhz */
+	/* read 303d[0], 1=50hz, 0=60hz */
+	{OV8810_REG_TERM, OV8810_VAL_TERM},
+};
+
+/* Lens correction settings */
+const static struct ov8810_reg len_correction_tbl[] = {
+	/* G */
+	{0x3358, 0x28},
+	{0x3359, 0x0d},
+	{0x335a, 0x0c},
+	{0x335b, 0x0a},
+	{0x335c, 0x0a},
+	{0x335d, 0x0b},
+	{0x335e, 0x0d},
+	{0x335f, 0x13},
+	{0x3360, 0x0d},
+	{0x3361, 0x0a},
+	{0x3362, 0x07},
+	{0x3363, 0x05},
+	{0x3364, 0x05},
+	{0x3365, 0x06},
+	{0x3366, 0x08},
+	{0x3367, 0x09},
+	{0x3368, 0x0b},
+	{0x3369, 0x06},
+	{0x336a, 0x03},
+	{0x336b, 0x02},
+	{0x336c, 0x01},
+	{0x336d, 0x02},
+	{0x336e, 0x04},
+	{0x336f, 0x06},
+	{0x3370, 0x08},
+	{0x3371, 0x04},
+	{0x3372, 0x01},
+	{0x3373, 0x00},
+	{0x3374, 0x00},
+	{0x3375, 0x00},
+	{0x3376, 0x02},
+	{0x3377, 0x04},
+	{0x3378, 0x08},
+	{0x3379, 0x04},
+	{0x337a, 0x01},
+	{0x337b, 0x00},
+	{0x337c, 0x00},
+	{0x337d, 0x00},
+	{0x337e, 0x03},
+	{0x337f, 0x04},
+	{0x3380, 0x0b},
+	{0x3381, 0x06},
+	{0x3382, 0x04},
+	{0x3383, 0x02},
+	{0x3384, 0x02},
+	{0x3385, 0x03},
+	{0x3386, 0x05},
+	{0x3387, 0x07},
+	{0x3388, 0x0f},
+	{0x3389, 0x0b},
+	{0x338a, 0x08},
+	{0x338b, 0x07},
+	{0x338c, 0x07},
+	{0x338d, 0x07},
+	{0x338e, 0x0a},
+	{0x338f, 0x0b},
+	{0x3390, 0x26},
+	{0x3391, 0x11},
+	{0x3392, 0x0e},
+	{0x3393, 0x0c},
+	{0x3394, 0x0b},
+	{0x3395, 0x0c},
+	{0x3396, 0x0e},
+	{0x3397, 0x11},
+
+	/* B */
+	{0x3398, 0x10},
+	{0x3399, 0x10},
+	{0x339a, 0x10},
+	{0x339b, 0x10},
+	{0x339c, 0x10},
+	{0x339d, 0x10},
+	{0x339e, 0x10},
+	{0x339f, 0x10},
+	{0x33a0, 0x10},
+	{0x33a1, 0x10},
+	{0x33a2, 0x10},
+	{0x33a3, 0x10},
+	{0x33a4, 0x10},
+	{0x33a5, 0x10},
+	{0x33a6, 0x10},
+	{0x33a7, 0x10},
+	{0x33a8, 0x10},
+	{0x33a9, 0x10},
+	{0x33aa, 0x10},
+	{0x33ab, 0x10},
+	{0x33ac, 0x10},
+	{0x33ad, 0x10},
+	{0x33ae, 0x10},
+	{0x33af, 0x10},
+	{0x33b0, 0x10},
+	{0x33b1, 0x10},
+	{0x33b2, 0x10},
+	{0x33b3, 0x10},
+	{0x33b4, 0x10},
+	{0x33b5, 0x10},
+	{0x33b6, 0x10},
+	{0x33b7, 0x10},
+	{0x33b8, 0x10},
+	{0x33b9, 0x10},
+	{0x33ba, 0x10},
+	{0x33bb, 0x10},
+
+	/* R */
+	{0x33bc, 0x10},
+	{0x33bd, 0x10},
+	{0x33be, 0x10},
+	{0x33bf, 0x10},
+	{0x33c0, 0x10},
+	{0x33c1, 0x10},
+	{0x33c2, 0x10},
+	{0x33c3, 0x10},
+	{0x33c4, 0x10},
+	{0x33c5, 0x10},
+	{0x33c6, 0x10},
+	{0x33c7, 0x10},
+	{0x33c8, 0x10},
+	{0x33c9, 0x10},
+	{0x33ca, 0x10},
+	{0x33cb, 0x10},
+	{0x33cc, 0x10},
+	{0x33cd, 0x10},
+	{0x33ce, 0x10},
+	{0x33cf, 0x10},
+	{0x33d0, 0x10},
+	{0x33d1, 0x10},
+	{0x33d2, 0x10},
+	{0x33d3, 0x10},
+	{0x33d4, 0x10},
+	{0x33d5, 0x10},
+	{0x33d6, 0x10},
+	{0x33d7, 0x10},
+	{0x33d8, 0x10},
+	{0x33d9, 0x10},
+	{0x33da, 0x10},
+	{0x33db, 0x10},
+	{0x33dc, 0x10},
+	{0x33dd, 0x10},
+	{0x33de, 0x10},
+	{0x33df, 0x10},
+	{0x3350, 0x06},
+	{0x3351, 0xab},
+	{0x3352, 0x05},
+	{0x3353, 0x00},
+	{0x3354, 0x04},
+	{0x3355, 0xf8},
+	{0x3356, 0x07},
+	{0x3357, 0x74},
+	{OV8810_REG_TERM, OV8810_VAL_TERM},
+};
+
+const static struct ov8810_reg ov8810_common_csi2[] = {
+	{OV8810_MIPI_CTRL0B, 0x0f},  /* disable MIPI output (enabled later) */
+	{0x3601, 0x16},
+	{OV8810_REG_TERM, OV8810_VAL_TERM},
+};
+
+const static struct ov8810_reg ov8810_mech_shutter[] = {
+	{0x30e1, 0xd0},	/* Set array reset control for frame mode */
+	{0x350e, 0x44},	/* Use sensor native vsync for frame mode */
+	{0x3058, 0x0c},	/* Set internal analog control for frame mode */
+	{OV8810_REG_TERM, OV8810_VAL_TERM},
+};
+
+struct ov8810_platform_data {
+	/* Set power state, zero is off, non-zero is on. */
+	int (*power_set)(struct device *dev, struct i2c_client *i2c_client,\
+				enum v4l2_power power);
+	/* Default registers written after power-on or reset. */
+	const struct ov8810_reg *default_regs;
+	int (*ifparm)(struct v4l2_ifparm *p);
+	int (*priv_data_set)(void *);
+	void (*lock_cpufreq)(int lock);	
+};
+
+#if defined(CONFIG_LEDS_FLASH_RESET)
+extern bool bd7885_device_detection(void);
+#endif
+
+#endif /* ifndef OV8810_H */
+
diff --git a/drivers/media/video/tda19989.c b/drivers/media/video/tda19989.c
new file mode 100644
index 0000000..0cf55b7
--- /dev/null
+++ b/drivers/media/video/tda19989.c
@@ -0,0 +1,489 @@
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/kmod.h>
+#include <linux/ioctl.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <linux/device.h>
+#include <linux/cdev.h>
+#include <linux/platform_device.h>
+#include <linux/workqueue.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <mach/gpio.h>
+#include <linux/irq.h> 
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#if defined(CONFIG_MOT_FEAT_DEVICE_TREE)
+#include <mach/mot-gpio-omap.h>
+#endif
+#include "tda19989.h"
+
+#ifdef TDA19989_CEC_AVAILABLE
+#include <linux/regulator/consumer.h>
+#endif
+
+static dev_t tda19989_dev_num;
+static struct cdev tda19989_cdev;
+static struct class *tda19989_class;
+static int tda19989_major = -1;
+
+static struct i2c_client *tda19989_client=NULL;
+
+static int hdmi_int_enabled=0;
+static int hdmi_int_done=0;
+static int hdmi_sleep_on=0;
+wait_queue_head_t hdmi_int_wait;
+#ifdef TDA19989_CEC_AVAILABLE
+static struct  regulator *cec_regulator;
+#endif
+
+static irqreturn_t hdmi_int_irq(int irq, void *dev_inst)
+{
+    printk("hdmi_int_irq() pre state : %d \n", hdmi_sleep_on);
+    if(hdmi_sleep_on)
+    {
+        wake_up_interruptible(&hdmi_int_wait);
+        hdmi_sleep_on=0;
+    }
+    else
+    {
+        printk("hdmi_int_irq error !!! \n");
+    }
+
+    return IRQ_HANDLED;
+}
+
+static ssize_t tda19989_read(struct file *fp, char __user *buf, size_t count, loff_t *ppos)
+{
+    printk("Tda19989_read() pre state : %d \n", hdmi_sleep_on);
+
+    if(!hdmi_sleep_on)
+    {
+        printk("sleep ..... enter !!!!  \n");
+        hdmi_sleep_on=1;
+        interruptible_sleep_on(&hdmi_int_wait);
+        printk("sleep ..... exit !!!!  \n");
+    }
+    else
+    {
+        printk("tda19989_read error !!! \n");
+    }
+    return 0;
+}
+
+static ssize_t tda19989_write( struct file * file, const char __user * buf, size_t count, loff_t *ppos )
+{
+    printk("hdmi_write start \n");
+    return 0;
+}
+
+static int tda19989_open(struct inode * inode, struct file * filp)
+{
+    int ret;
+
+    printk("tda19989_open start \n");
+    init_waitqueue_head(&hdmi_int_wait);
+
+    ret=gpio_request(HDMI_PWR_EN_GPIO_NUM, "HDMI_PWR_EN");
+    if(ret<0)
+    {
+        printk("tda19989 GPIO Pwr On request error !!! \n");
+        return -1;
+    }
+    gpio_direction_output(HDMI_PWR_EN_GPIO_NUM, 0);
+
+    ret=gpio_request(HDMI_INT_PIN_GPIO_NUM, "HDMI_INT");
+    if(ret<0)
+    {
+        printk("tda19989 GPIO INT request error !!! \n");
+        gpio_free(HDMI_PWR_EN_GPIO_NUM);
+        return -1;
+    }
+#ifdef TDA19989_CEC_AVAILABLE
+    cec_regulator  = regulator_get(NULL, "vwlan2");
+    if (IS_ERR(cec_regulator)) {
+        printk("tda19989 failed to get regulator for HDMI");
+        return -ENODEV;
+    }
+    printk("pass 3 \n");
+    if (regulator_enable(cec_regulator) < 0)
+    {
+        printk("tda19989 Failed to enable regulator\n");
+        return -ENODEV;
+    }
+     printk("pass 4 \n");
+    regulator_set_voltage(cec_regulator,3300000,3300000);
+#endif
+
+    return 0;
+}
+
+static int tda19989_release(struct inode * inode, struct file * filp)
+{
+    printk("tda19989_release start \n");
+    return 0;
+}
+
+static int I2cTda19989_write(i2cKernelModeArg* pArg)
+{
+    u8 reg;
+    u8 length;
+    u8 *pData;
+    int retval=0;
+
+    reg = pArg->firstRegister;
+    length = pArg->lenData;
+    pData = &pArg->Data[0];
+
+    tda19989_client->addr=pArg->slaveAddr;
+    /*printk("[W] addr = %x, length = %d, pData = %d \n", tda19989_client->addr, length, *pData);*/
+    while(length--)
+    {
+        retval=i2c_smbus_write_byte_data(tda19989_client, reg, *pData);
+        if (retval != 0)
+        {
+            printk("I2cTda19989_write error [%d] \n", retval);
+            break;
+        }
+
+        reg++;
+        pData++;
+    }
+    return ((retval==0)?0:-1);
+}
+
+static int I2cTda19989_read(i2cKernelModeArg* pArg)
+{
+    u8 reg;
+    u8 length;
+    u8 *pData;
+
+    reg = pArg->firstRegister;
+    length = pArg->lenData;
+    pData = &pArg->Data[0];
+
+    tda19989_client->addr=pArg->slaveAddr;
+    /*printk("[R] addr = %x, length = %d, pData = %d \n", tda19989_client->addr, length, *pData);*/
+    while(length--)
+    {
+        *pData = (u8)i2c_smbus_read_byte_data(tda19989_client, reg);
+        reg++;
+        pData++;
+    }
+    return 0;
+}
+
+static int tda19989_ioctl(struct inode * inode, struct file *filp, u_int cmd, u_long arg)
+{
+    int result=0;
+
+    switch(cmd)
+    {
+        case HDMI_I2C_WRITE:
+        {
+            i2cKernelModeArg mArg;
+            if(copy_from_user((char*)&mArg, (char*)arg, sizeof(mArg)))
+            {
+                printk("tda19989 HDMI_I2C_WRITE copy_from_user error \n");
+                result = -EFAULT;
+                break;
+            }
+            result=I2cTda19989_write(&mArg);
+        }
+        break;
+
+        case HDMI_I2C_READ:
+        {
+            i2cKernelModeArg mArg;
+            if(copy_from_user((char*)&mArg, (char*)arg, sizeof(mArg)))
+            {
+                printk("tda19989 HDMI_I2C_READ copy_from_user error \n");
+                result = -EFAULT;
+                break;
+            }	
+            result=I2cTda19989_read(&mArg);
+            if(copy_to_user((char*)arg, (char*)&mArg, sizeof(mArg)))
+            {
+                printk("tda19989 HDMI_I2C_READ copy_to_user error \n");
+                result = -EFAULT;
+            }
+        }
+        break;
+
+        case HDMI_PWR_ONOFF:
+        {
+            int hdmi5VOn;
+            if (copy_from_user(&hdmi5VOn, (int*)arg, sizeof(hdmi5VOn)))
+            {
+                printk("tda19989 HDMI_5V_ENABLE copy_from_user error \n");
+                result = -EFAULT;
+                break;
+            }	
+            if(hdmi5VOn)
+                gpio_set_value(HDMI_PWR_EN_GPIO_NUM, 1);
+            else
+                gpio_set_value(HDMI_PWR_EN_GPIO_NUM, 0);
+        }
+        break;
+
+        case HDMI_INT_ENABLE:
+        {
+            int hdmiIntEn;
+            if (copy_from_user(&hdmiIntEn, (int*)arg, sizeof(hdmiIntEn)))
+            {
+                printk("tda19989 HDMI_INT_ENABLE copy_from_user error \n");
+                result = -EFAULT;
+                break;
+            }	
+
+            if(hdmiIntEn)
+            {
+                if(!hdmi_int_done)
+                {
+                    gpio_direction_input(HDMI_INT_PIN_GPIO_NUM);
+                    set_irq_type(gpio_to_irq(HDMI_INT_PIN_GPIO_NUM), IRQ_TYPE_EDGE_FALLING);
+                    result=request_irq(gpio_to_irq(HDMI_INT_PIN_GPIO_NUM), hdmi_int_irq,
+                                                  IRQF_TRIGGER_FALLING|IRQF_DISABLED, HDMI_TRNS_NAME, (void *)NULL);
+                    if(result)
+                    {
+                        printk(KERN_ERR "tda19989 request irq Error : %d\n", result);
+                        gpio_free(HDMI_INT_PIN_GPIO_NUM);
+                        return -1;
+                    }
+                    hdmi_int_done=1;
+                    hdmi_int_enabled=1;
+                }
+                else
+                {
+                    if(!hdmi_int_enabled)
+                    {
+                        enable_irq(OMAP_GPIO_IRQ(HDMI_INT_PIN_GPIO_NUM));
+                        hdmi_int_enabled=1;
+                    }
+                }
+            }
+            else
+            {
+                if(hdmi_int_enabled)
+                {
+                    disable_irq(OMAP_GPIO_IRQ(HDMI_INT_PIN_GPIO_NUM));
+                    hdmi_int_enabled=0;
+                }
+            }
+        }
+        break;
+
+#ifdef TDA19989_CEC_AVAILABLE
+        case HDMI_CEC_CAL_TIME:
+        {
+            int i;
+            struct timeval prevTime, curTime, resultTime;
+
+            gpio_direction_output(HDMI_INT_PIN_GPIO_NUM, 0);
+            gpio_set_value(HDMI_INT_PIN_GPIO_NUM, 0);
+
+            do_gettimeofday(&prevTime);
+            mdelay(9);
+            for(i=0; i<500; i++)
+            {
+                do_gettimeofday(&curTime);
+                resultTime.tv_usec=curTime.tv_usec-prevTime.tv_usec;
+                if(resultTime.tv_usec>9980) break;
+                udelay(2);
+            }
+
+            gpio_set_value(HDMI_INT_PIN_GPIO_NUM, 1);
+            do_gettimeofday(&curTime);
+
+            gpio_direction_output(HDMI_INT_PIN_GPIO_NUM, 1);
+
+            resultTime.tv_usec=curTime.tv_usec-prevTime.tv_usec;
+            printk("Time interval: %d\n", (int)resultTime.tv_usec);
+        }
+        break;
+#endif
+
+	 default:
+        break;
+    }
+
+    return result;
+}
+
+struct file_operations tda19989_fops =
+{
+    .owner = THIS_MODULE,
+    .read = tda19989_read,
+    .write = tda19989_write,
+    .open = tda19989_open,
+    .release = tda19989_release,
+    .ioctl = tda19989_ioctl,
+};
+
+static int i2cTda19989_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+    printk("I2cTda19989_Probe \n");
+
+    if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))
+    {
+        printk("tda19989 Can't support SMBUS \n");
+        return -ENODEV;
+    }	
+    tda19989_client = client;
+
+    return 0;
+}
+
+static int i2cTda19989_remove(struct i2c_client *client)
+{
+    printk("I2cTda19989_Remove \n");
+    return 0;
+}
+
+static const struct i2c_device_id tda19989_id[] = {
+	{ HDMI_TRNS_NAME, 0 },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(i2c, tda19989_id);
+
+static struct i2c_driver i2c_driver_tda19989 = 
+{
+    .driver =
+    {
+        .name = HDMI_TRNS_NAME,
+        .owner = THIS_MODULE,
+    },
+    .probe = i2cTda19989_probe,
+    .remove = __devexit_p(i2cTda19989_remove),
+    .id_table = tda19989_id,
+};
+
+static int tda19989_probe(struct platform_device *p_dev)
+{
+    printk("tda19989_probe \n");
+    return 0;
+}
+
+static int tda19989_remove(struct platform_device *p_dev)
+{
+    printk("tda19989_remove  \n");
+    return 0;
+}
+
+#if defined(CONFIG_PM)
+static int tda19989_suspend(struct platform_device* p_dev, pm_message_t event)
+{
+    printk("tda19989_suspend  \n");
+    /*need to check how to control tda19989 power state*/
+    return 0;
+}
+
+static int tda19989_resume(struct platform_device *p_dev)
+{
+    printk("tda19989_resume  \n");
+    /*need to check how to control tda19989 power state*/
+    return 0;
+}
+#endif
+
+static struct platform_driver tda19989_driver =
+{
+	.probe		= tda19989_probe,
+	.remove		= tda19989_remove,
+#if defined(CONFIG_PM)
+	.suspend		= tda19989_suspend,
+	.resume		= tda19989_resume,
+#endif
+	.driver		= {
+		.name	= HDMI_TRNS_NAME,
+		.owner	= THIS_MODULE,	
+	},
+};
+
+static struct platform_device tda19989_device = {
+	.name			= HDMI_TRNS_NAME,
+};
+
+static int __init hdmiTda19989_init (void)
+{
+    int ret;
+
+    ret = i2c_add_driver(&i2c_driver_tda19989);
+    if(ret){
+        printk("tda19989 : i2c add driver fail : err = %d\n", ret);		
+        return ret;
+    }
+
+    ret=alloc_chrdev_region(&tda19989_dev_num, 0, 1, HDMI_TRNS_NAME);
+    if(ret){
+        printk("tda19989 : alloc_chrdev_region failed: err = %d\n", ret);		
+        return ret;
+    }
+
+    cdev_init(&tda19989_cdev, &tda19989_fops);
+    tda19989_cdev.owner = THIS_MODULE;
+    ret=cdev_add(&tda19989_cdev, tda19989_dev_num, 1);
+    if(ret){
+        printk("tda19989 : add cdev failed: err = %d\n", ret);			
+        goto exit_err1;
+    }
+    tda19989_major = MAJOR(tda19989_dev_num);
+
+    ret=platform_driver_register(&tda19989_driver);
+    if(ret){
+        printk("can't register tda19989_driver driver\n");
+        goto exit_err2;
+    }
+	
+    ret=platform_device_register(&tda19989_device);
+    if(ret){
+        printk("can't register tda19989_driver device\n"); 
+        goto exit_err3;
+    }
+
+    tda19989_class=class_create(THIS_MODULE, HDMI_TRNS_NAME);
+    if(!tda19989_class){
+        printk("can't create tda19989 class \n"); 
+        goto exit_err4;			
+    }
+
+    device_create(tda19989_class, NULL, tda19989_dev_num, NULL, HDMI_TRNS_NAME);
+
+    return 0;
+
+exit_err4:
+	platform_device_unregister(&tda19989_device);
+exit_err3:
+	platform_driver_unregister(&tda19989_driver);
+exit_err2:
+   cdev_del(&tda19989_cdev);  
+exit_err1 :
+    unregister_chrdev_region(tda19989_dev_num, 1);
+
+    return ret;
+
+}
+
+static void __exit hdmiTda19989_exit (void)
+{
+    i2c_del_driver(&i2c_driver_tda19989);
+    device_destroy(tda19989_class, tda19989_dev_num);
+    class_destroy(tda19989_class);
+    platform_device_unregister(&tda19989_device);
+    platform_driver_unregister(&tda19989_driver);	
+    cdev_del(&tda19989_cdev);	
+    unregister_chrdev_region(tda19989_dev_num, 1);
+}
+
+module_init(hdmiTda19989_init);
+module_exit(hdmiTda19989_exit);
+
+MODULE_AUTHOR("Motorola");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/tda19989.h b/drivers/media/video/tda19989.h
new file mode 100644
index 0000000..3b50be6
--- /dev/null
+++ b/drivers/media/video/tda19989.h
@@ -0,0 +1,30 @@
+#ifndef __INCLUDED_TDA19989__
+#define __INCLUDED_TDA19989__
+
+#include <linux/types.h>
+
+/*#define TDA19989_CEC_AVAILABLE*/
+
+#define HDMI_I2C_WRITE		0
+#define HDMI_I2C_READ		1
+#define HDMI_PWR_ONOFF	2
+#define HDMI_INT_ENABLE	3
+#ifdef TDA19989_CEC_AVAILABLE
+#define HDMI_CEC_CAL_TIME	4
+#endif
+
+#define HDMI_TRNS_NAME  "tda19989"
+
+#define HDMI_INT_PIN_GPIO_NUM 25
+#define HDMI_PWR_EN_GPIO_NUM 26
+
+typedef struct _i2cKernelModeArg
+{
+    u8 slaveAddr;
+    u8 firstRegister;
+    u8 lenData;
+    u8 Data[128];
+} i2cKernelModeArg;
+
+#endif
+
diff --git a/drivers/media/video/videobuf-core.c b/drivers/media/video/videobuf-core.c
index b7b0584..efbe9f9 100644
--- a/drivers/media/video/videobuf-core.c
+++ b/drivers/media/video/videobuf-core.c
@@ -667,6 +667,7 @@ int videobuf_dqbuf(struct videobuf_queue *q,
 		buf->state = VIDEOBUF_IDLE;
 		break;
 	case VIDEOBUF_DONE:
+	case VIDEOBUF_IDLE:
 		dprintk(1, "dqbuf: state is done\n");
 		CALL(q, sync, q, buf);
 		buf->state = VIDEOBUF_IDLE;
diff --git a/drivers/mfd/cpcap-3mm5.c b/drivers/mfd/cpcap-3mm5.c
index 6579a4d..9d53634 100644
--- a/drivers/mfd/cpcap-3mm5.c
+++ b/drivers/mfd/cpcap-3mm5.c
@@ -88,6 +88,7 @@ static void hs_handler(enum cpcap_irqs irq, void *data)
 {
 	struct cpcap_3mm5_data *data_3mm5 = data;
 	int new_state = NO_DEVICE;
+	int cpcap_status_gpio_2, cpcap_status_gpio_4;
 
 	if (irq != CPCAP_IRQ_HS)
 		return;
@@ -109,13 +110,23 @@ static void hs_handler(enum cpcap_irqs irq, void *data)
 		cpcap_irq_unmask(data_3mm5->cpcap, CPCAP_IRQ_HS);
 
 		send_key_event(data_3mm5, 0);
+		cpcap_uc_stop(data_3mm5->cpcap, CPCAP_MACRO_5);
 	} else {
+		cpcap_status_gpio_2 = cpcap_regacc_write(data_3mm5->cpcap,
+                        CPCAP_REG_GPIO2, 0,
+                        CPCAP_BIT_GPIO2DRV);
+
+                cpcap_status_gpio_4 = cpcap_regacc_write(data_3mm5->cpcap,
+                        CPCAP_REG_GPIO4, CPCAP_BIT_GPIO4DRV,
+                        CPCAP_BIT_GPIO4DRV);
+		if ((cpcap_status_gpio_2 < 0) || (cpcap_status_gpio_4 < 0)) {
+                	pr_err("Cpcap TV_out: %s: "
+                                "Control Analog Switch failed: \n", __func__);
+        	}
+		
 		cpcap_regacc_write(data_3mm5->cpcap, CPCAP_REG_TXI,
 				   (CPCAP_BIT_MB_ON2 | CPCAP_BIT_PTT_CMP_EN),
 				   (CPCAP_BIT_MB_ON2 | CPCAP_BIT_PTT_CMP_EN));
-		cpcap_regacc_write(data_3mm5->cpcap, CPCAP_REG_RXOA,
-				   CPCAP_BIT_ST_HS_CP_EN,
-				   CPCAP_BIT_ST_HS_CP_EN);
 		audio_low_power_clear(data_3mm5);
 
 		/* Give PTTS time to settle */
@@ -134,6 +145,9 @@ static void hs_handler(enum cpcap_irqs irq, void *data)
 		cpcap_irq_unmask(data_3mm5->cpcap, CPCAP_IRQ_HS);
 		cpcap_irq_unmask(data_3mm5->cpcap, CPCAP_IRQ_MB2);
 		cpcap_irq_unmask(data_3mm5->cpcap, CPCAP_IRQ_UC_PRIMACRO_5);
+
+		cpcap_uc_start(data_3mm5->cpcap, CPCAP_MACRO_5);
+                cpcap_uc_start(data_3mm5->cpcap, CPCAP_MACRO_4);
 	}
 
 	switch_set_state(&data_3mm5->sdev, new_state);
@@ -175,6 +189,51 @@ static void key_handler(enum cpcap_irqs irq, void *data)
 	cpcap_irq_unmask(data_3mm5->cpcap, CPCAP_IRQ_UC_PRIMACRO_5);
 }
 
+static int init_analog_switch(struct cpcap_3mm5_data *data)
+{
+        int cpcap_status = 0;
+        struct cpcap_3mm5_data *data_3mm5 = data;
+
+        /* set vlev = 2.775V for GPIO 2 */
+        cpcap_status = cpcap_regacc_write(data_3mm5->cpcap,
+                                        CPCAP_REG_GPIO2, CPCAP_BIT_GPIO2VLEV,
+                                        CPCAP_BIT_GPIO2VLEV);
+        if (cpcap_status < 0) {
+                pr_err("Cpcap TV_out: %s: "
+                                "Configuring GPIO2 VLEV failed: \n", __func__);
+                return cpcap_status;
+        }
+
+        /* set vlev = 2.775V for GPIO 4 */
+        cpcap_status = cpcap_regacc_write(data_3mm5->cpcap,
+                                        CPCAP_REG_GPIO4, CPCAP_BIT_GPIO4VLEV,
+                                        CPCAP_BIT_GPIO4VLEV);
+        if (cpcap_status < 0) {
+                pr_err("Cpcap TV_out: %s: "
+                                "Configuring GPIO4 VLEV failed: \n", __func__);
+                return cpcap_status;
+        }
+
+        cpcap_status = cpcap_regacc_write(data_3mm5->cpcap,
+                                        CPCAP_REG_GPIO2, CPCAP_BIT_GPIO2DIR,
+                                        CPCAP_BIT_GPIO2DIR);
+        if (cpcap_status < 0) {
+                pr_err("Cpcap TV_out: %s: "
+                                "Configuring GPIO2 failed: \n", __func__);
+                return cpcap_status;
+        }
+        cpcap_status = cpcap_regacc_write(data_3mm5->cpcap,
+                                        CPCAP_REG_GPIO4, CPCAP_BIT_GPIO4DIR,
+                                        CPCAP_BIT_GPIO4DIR);
+
+        if (cpcap_status < 0) {
+                pr_err("Cpcap TV_out: %s: "
+                                "Configuring GPIO4 failed: \n", __func__);
+                return cpcap_status;
+        }
+        return 0;
+}
+
 static int __init cpcap_3mm5_probe(struct platform_device *pdev)
 {
 	int retval = 0;
@@ -195,7 +254,10 @@ static int __init cpcap_3mm5_probe(struct platform_device *pdev)
 	data->sdev.print_name = print_name;
 	switch_dev_register(&data->sdev);
 	platform_set_drvdata(pdev, data);
-
+	retval = init_analog_switch(data);
+        if (retval < 0)
+              return retval;
+	
 	data->regulator = regulator_get(NULL, "vaudio");
 	if (IS_ERR(data->regulator)) {
 		dev_err(&pdev->dev, "Could not get regulator for cpcap_3mm5\n");
diff --git a/drivers/mfd/cpcap-core.c b/drivers/mfd/cpcap-core.c
index c239e87..417cf85 100644
--- a/drivers/mfd/cpcap-core.c
+++ b/drivers/mfd/cpcap-core.c
@@ -147,8 +147,17 @@ static struct platform_device cpcap_rtc_device = {
 	.dev.platform_data = NULL,
 };
 
+#ifdef CONFIG_LEDS_AF_LED
+struct platform_device cpcap_af_led = {
+	.name		= LD_AF_LED_DEV,
+	.id		= -1,
+	.dev		= {
+		.platform_data  = NULL,
+	},
+};
+#endif
+
 static struct platform_device *cpcap_devices[] = {
-	&cpcap_uc_device,
 	&cpcap_adc_device,
 	&cpcap_key_device,
 	&cpcap_batt_device,
@@ -165,6 +174,10 @@ static struct platform_device *cpcap_devices[] = {
 #endif
 	&cpcap_3mm5_device,
 	&cpcap_rtc_device,
+	&cpcap_uc_device,
+#ifdef CONFIG_LEDS_AF_LED
+	&cpcap_af_led,
+#endif
 };
 
 static struct cpcap_device *misc_cpcap;
@@ -490,6 +503,18 @@ static int adc_ioctl(unsigned int cmd, unsigned long arg)
 	return retval;
 }
 
+#if defined(CONFIG_LEDS_FLASH_RESET)
+int cpcap_direct_misc_write(unsigned short reg, unsigned short value,\
+						unsigned short mask)
+{
+	int retval = -EINVAL;
+
+	retval = cpcap_regacc_write(misc_cpcap, reg, value, mask);
+
+	return retval;
+}
+#endif
+
 static int ioctl(struct inode *inode,
 		 struct file *file, unsigned int cmd, unsigned long arg)
 {
diff --git a/drivers/mfd/cpcap-regacc.c b/drivers/mfd/cpcap-regacc.c
index 2b8de54..d06cfb3 100644
--- a/drivers/mfd/cpcap-regacc.c
+++ b/drivers/mfd/cpcap-regacc.c
@@ -244,6 +244,11 @@ static const struct {
 	[CPCAP_REG_LMACE]     = {1183, 0xFFF8, 0xFFFF},
 };
 
+#ifdef CPCAP_AUDIO_REG_DEBUG
+static unsigned short
+CPCAP_AUD_CACHE[CPCAP_REG_LVAB-CPCAP_REG_VAUDIOC+1] = { 0 };
+#endif
+
 static int cpcap_spi_access(struct spi_device *spi, u8 *buf,
 			    size_t len)
 {
@@ -348,6 +353,13 @@ int cpcap_regacc_write(struct cpcap_device *cpcap,
 		old_value &= register_info_tbl[reg].rbw_mask;
 		old_value &= ~mask;
 		value |= old_value;
+
+#ifdef CPCAP_AUDIO_REG_DEBUG
+		if (reg >= CPCAP_REG_VAUDIOC && reg <= CPCAP_REG_LVAB)
+			CPCAP_AUD_CACHE[reg - CPCAP_REG_VAUDIOC] =
+					value & register_info_tbl[reg].rbw_mask;
+#endif
+
 		retval = cpcap_config_for_write(spi,
 						register_info_tbl[reg].address,
 						value);
@@ -381,3 +393,21 @@ int cpcap_regacc_init(struct cpcap_device *cpcap)
 
 	return retval;
 }
+
+#ifdef CPCAP_AUDIO_REG_DEBUG
+void cpcap_regacc_audio_reg_dump(void)
+{
+  printk(KERN_INFO
+	"CPCAP_aud:V:%04X C:%04X,%04X S:%04X,%04X In:%04X,%04X Out:%04X,%04X ",
+	CPCAP_AUD_CACHE[0], CPCAP_AUD_CACHE[1], CPCAP_AUD_CACHE[2],
+	CPCAP_AUD_CACHE[3], CPCAP_AUD_CACHE[4], CPCAP_AUD_CACHE[5],
+	CPCAP_AUD_CACHE[6], CPCAP_AUD_CACHE[7], CPCAP_AUD_CACHE[8]
+	);
+  printk(KERN_INFO
+	"Sw:%04X,%04X,%04X  %04X %04X %04X %04X %04X %04X\n",
+	CPCAP_AUD_CACHE[9], CPCAP_AUD_CACHE[10], CPCAP_AUD_CACHE[11],
+	CPCAP_AUD_CACHE[12], CPCAP_AUD_CACHE[13], CPCAP_AUD_CACHE[14],
+	CPCAP_AUD_CACHE[15], CPCAP_AUD_CACHE[16], CPCAP_AUD_CACHE[17]
+	);
+}
+#endif
diff --git a/drivers/misc/akm8973_akmd.c b/drivers/misc/akm8973_akmd.c
old mode 100755
new mode 100644
index b47cd19..0806cba
--- a/drivers/misc/akm8973_akmd.c
+++ b/drivers/misc/akm8973_akmd.c
@@ -284,8 +284,8 @@ static void AKECS_Report_Value(short *rbuf)
 		input_report_abs(data->input_dev, ABS_THROTTLE, rbuf[3]);
 
 	if (atomic_read(&mv_flag)) {
-		input_report_abs(data->input_dev, ABS_HAT0X, rbuf[9]);
-		input_report_abs(data->input_dev, ABS_HAT0Y, rbuf[10]);
+		input_report_abs(data->input_dev, ABS_HAT0X, 0 - rbuf[10]);
+		input_report_abs(data->input_dev, ABS_HAT0Y, rbuf[9]);
 		input_report_abs(data->input_dev, ABS_BRAKE, rbuf[11]);
 	}
 
diff --git a/drivers/misc/lis331dlh.c b/drivers/misc/lis331dlh.c
index bab1fd9..a9b7e6e 100644
--- a/drivers/misc/lis331dlh.c
+++ b/drivers/misc/lis331dlh.c
@@ -202,7 +202,8 @@ static int lis331dlh_hw_init(struct lis331dlh_data *lis)
 static void lis331dlh_device_power_off(struct lis331dlh_data *lis)
 {
 	int err;
-	u8 buf[2] = { CTRL_REG4, PM_OFF };
+/*	u8 buf[2] = { CTRL_REG4, PM_OFF }; */
+	u8 buf[2] = { CTRL_REG1, PM_OFF };
 
 	err = lis331dlh_i2c_write(lis, buf, 1);
 	if (err < 0)
diff --git a/drivers/misc/modem_pm_driver/Kconfig b/drivers/misc/modem_pm_driver/Kconfig
old mode 100755
new mode 100644
diff --git a/drivers/misc/modem_pm_driver/Makefile b/drivers/misc/modem_pm_driver/Makefile
old mode 100755
new mode 100644
diff --git a/drivers/misc/modem_pm_driver/modem_pm_driver.h b/drivers/misc/modem_pm_driver/modem_pm_driver.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/modem_pm_driver/modem_pm_driver_main.c b/drivers/misc/modem_pm_driver/modem_pm_driver_main.c
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/LICENSE b/drivers/misc/netmux/LICENSE
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/channelconfig.c b/drivers/misc/netmux/channelconfig.c
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/config.c b/drivers/misc/netmux/config.c
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/config.h b/drivers/misc/netmux/config.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/debug.c b/drivers/misc/netmux/debug.c
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/debug.h b/drivers/misc/netmux/debug.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/debug_client.h b/drivers/misc/netmux/debug_client.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/debug_host.h b/drivers/misc/netmux/debug_host.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/direct.c b/drivers/misc/netmux/direct.c
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/direct.h b/drivers/misc/netmux/direct.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/errorcodes.h b/drivers/misc/netmux/errorcodes.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/interface.c b/drivers/misc/netmux/interface.c
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/interface.h b/drivers/misc/netmux/interface.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/main.c b/drivers/misc/netmux/main.c
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/mux.c b/drivers/misc/netmux/mux.c
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/mux.h b/drivers/misc/netmux/mux.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/network.c b/drivers/misc/netmux/network.c
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/network.h b/drivers/misc/netmux/network.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/packet.h b/drivers/misc/netmux/packet.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/protocol.c b/drivers/misc/netmux/protocol.c
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/protocol.h b/drivers/misc/netmux/protocol.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/register.c b/drivers/misc/netmux/register.c
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/register.h b/drivers/misc/netmux/register.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/shared/ldprotocol.h b/drivers/misc/netmux/shared/ldprotocol.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/tty.c b/drivers/misc/netmux/tty.c
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/tty.h b/drivers/misc/netmux/tty.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/types.h b/drivers/misc/netmux/types.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/utility.c b/drivers/misc/netmux/utility.c
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/utility.h b/drivers/misc/netmux/utility.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/utility_client.h b/drivers/misc/netmux/utility_client.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux/utility_host.h b/drivers/misc/netmux/utility_host.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux_linkdriver/LICENSE b/drivers/misc/netmux_linkdriver/LICENSE
old mode 100755
new mode 100644
diff --git a/drivers/misc/netmux_linkdriver/usb/Makefile b/drivers/misc/netmux_linkdriver/usb/Makefile
old mode 100755
new mode 100644
diff --git a/drivers/misc/ts27010mux/Kconfig b/drivers/misc/ts27010mux/Kconfig
old mode 100755
new mode 100644
diff --git a/drivers/misc/ts27010mux/Makefile b/drivers/misc/ts27010mux/Makefile
old mode 100755
new mode 100644
diff --git a/drivers/misc/ts27010mux/ts0710.h b/drivers/misc/ts27010mux/ts0710.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/ts27010mux/ts27010_mux.c b/drivers/misc/ts27010mux/ts27010_mux.c
old mode 100755
new mode 100644
diff --git a/drivers/misc/ts27010mux/ts27010_mux.h b/drivers/misc/ts27010mux/ts27010_mux.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/vib-gpio.c b/drivers/misc/vib-gpio.c
old mode 100755
new mode 100644
diff --git a/drivers/misc/vib-omap-pwm.c b/drivers/misc/vib-omap-pwm.c
old mode 100755
new mode 100644
diff --git a/drivers/mmc/core/debugfs.c b/drivers/mmc/core/debugfs.c
index 610dbd1..fcd1a80 100644
--- a/drivers/mmc/core/debugfs.c
+++ b/drivers/mmc/core/debugfs.c
@@ -289,4 +289,5 @@ err:
 void mmc_remove_card_debugfs(struct mmc_card *card)
 {
 	debugfs_remove_recursive(card->debugfs_root);
+	card->debugfs_root = NULL;
 }
diff --git a/drivers/mmc/core/sdio_io.c b/drivers/mmc/core/sdio_io.c
old mode 100755
new mode 100644
diff --git a/drivers/mtd/nand/omap2.c b/drivers/mtd/nand/omap2.c
old mode 100755
new mode 100644
diff --git a/drivers/sim/sim_core.c b/drivers/sim/sim_core.c
index 75634d8..38dcac9 100644
--- a/drivers/sim/sim_core.c
+++ b/drivers/sim/sim_core.c
@@ -2103,7 +2103,7 @@ int sim_slim_status_handler()
 			sw1 = sim_module_card_data[0].buffer[bytes_recieved - 2];
 			sw2 = sim_module_card_data[0].buffer[bytes_recieved - 1];
 
-			if((((sw1 == 0x90) || (card_type == GSM_SIM && sw1==0x67)) && (sw2 == 0x00))||(sw1 == 0x91)){
+			if((((sw1 == 0x90) || (card_type == GSM_SIM && sw1==0x67)) && (sw2 == 0x00)) || (sw1 == 0x91)){
 				sim_low_power_enabled = TRUE;
       
 				/* Allow DMA to ACK idle requests */
diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 643908b..d807583 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -25,6 +25,9 @@
 #include <linux/mutex.h>
 #include <linux/spi/spi.h>
 
+#ifdef CONFIG_MOT_FEAT_SPI_SMS1130
+static struct spi_device *spi_device_smsmdtv;
+#endif
 
 /* SPI bustype and spi_master class are registered after board init code
  * provides the SPI device tables, ensuring that both are present by the
@@ -381,6 +384,9 @@ spi_register_board_info(struct spi_board_info const *info, unsigned n)
 static void scan_boardinfo(struct spi_master *master)
 {
 	struct boardinfo	*bi;
+#ifdef CONFIG_MOT_FEAT_SPI_SMS1130
+	struct spi_device *spi;
+#endif
 
 	mutex_lock(&board_lock);
 	list_for_each_entry(bi, &board_list, list) {
@@ -393,7 +399,19 @@ static void scan_boardinfo(struct spi_master *master)
 			/* NOTE: this relies on spi_new_device to
 			 * issue diagnostics when given bogus inputs
 			 */
+#ifdef CONFIG_MOT_FEAT_SPI_SMS1130
+		spi = spi_new_device(master, chip);
+/* note: this macro is remove from include/linux/kobject.h */
+#define KOBJ_NAME_LEN 20
+
+	if (strncmp(chip->modalias, "smsspi", KOBJ_NAME_LEN) == 0) {
+		spi_device_smsmdtv = spi;
+
+		printk(KERN_INFO "smsspi device is added.\n");
+	}
+#else
 			(void) spi_new_device(master, chip);
+#endif
 		}
 	}
 	mutex_unlock(&board_lock);
@@ -699,6 +717,19 @@ int spi_write_then_read(struct spi_device *spi,
 }
 EXPORT_SYMBOL_GPL(spi_write_then_read);
 
+#ifdef CONFIG_MOT_FEAT_SPI_SMS1130
+struct spi_device *spi_get_spi_device(char *modalias)
+{
+#define KOBJ_NAME_LEN   20
+
+	if (strncmp(modalias, "smsspi", KOBJ_NAME_LEN) == 0)
+		return spi_device_smsmdtv;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(spi_get_spi_device);
+#endif
+
 /*-------------------------------------------------------------------------*/
 
 static int __init spi_init(void)
diff --git a/drivers/usb/gadget/f_acm.c b/drivers/usb/gadget/f_acm.c
index b5292ae..93c44c8 100644
--- a/drivers/usb/gadget/f_acm.c
+++ b/drivers/usb/gadget/f_acm.c
@@ -14,6 +14,7 @@
 
 #include <linux/kernel.h>
 #include <linux/device.h>
+#include <linux/tty.h>
 
 #include "u_serial.h"
 #include "gadget_chips.h"
@@ -106,7 +107,7 @@ static struct usb_descriptor_header *null_acm_descs[] = {
 /* notification endpoint uses smallish and infrequent fixed-size messages */
 
 #define GS_LOG2_NOTIFY_INTERVAL		5	/* 1 << 5 == 32 msec */
-#define GS_NOTIFY_MAXPACKET		10	/* notification + 2 bytes */
+#define GS_NOTIFY_MAXPACKET		64	/* notification + 2 bytes */
 
 /* interface and class descriptors: */
 
@@ -590,6 +591,38 @@ static void acm_cdc_notify_complete(struct usb_ep *ep, struct usb_request *req)
 		acm_notify_serial_state(acm);
 }
 
+#ifdef CONFIG_USB_MOT_ANDROID
+static void acm_tiocmset(struct gserial *port, int set, int clear)
+{
+	struct f_acm            *acm = port_to_acm(port);
+
+	if (set & TIOCM_DTR)
+		acm->serial_state |= ACM_CTRL_DCD;
+	if (clear & TIOCM_DTR)
+		acm->serial_state &= ~ACM_CTRL_DCD;
+
+	if (set & TIOCM_DSR)
+		acm->serial_state |= ACM_CTRL_DSR;
+	if (clear & TIOCM_DSR)
+		acm->serial_state &= ~ACM_CTRL_DSR;
+
+	if (set & TIOCM_OUT1)
+		acm->serial_state |= ACM_CTRL_RI;
+	if (clear & TIOCM_OUT1)
+		acm->serial_state &= ~ACM_CTRL_RI;
+
+	if (set & TIOCM_OUT2)
+		acm->serial_state |= ACM_CTRL_OVERRUN;
+	if (clear & TIOCM_OUT2)
+		acm->serial_state &= ~ACM_CTRL_OVERRUN;
+
+	/*
+	*  TODO:  configure DSR/DCD/OUT1, etc according to set/clear
+	*/
+	acm_notify_serial_state(acm);
+}
+#endif
+
 /* connect == the TTY link is open */
 
 static void acm_connect(struct gserial *port)
@@ -846,6 +879,7 @@ int __init acm_bind_config(struct usb_configuration *c, u8 port_num)
 	acm->port.func.disable = acm_disable;
 
 #ifdef CONFIG_USB_MOT_ANDROID
+	acm->port.tiocmset = acm_tiocmset;
 	g_acm_dev = acm;
 #endif
 
diff --git a/drivers/usb/gadget/f_mass_storage.c b/drivers/usb/gadget/f_mass_storage.c
index 01c13a0..a7f4b42 100644
--- a/drivers/usb/gadget/f_mass_storage.c
+++ b/drivers/usb/gadget/f_mass_storage.c
@@ -1282,7 +1282,7 @@ static int do_inquiry(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 
 #ifdef CONFIG_USB_MOT_ANDROID
 	u8 *vend_str = "Motorola";
-	u8 *prod_str = "A853";
+	u8 *prod_str = "XT701";
 
 	fsg->vendor = vend_str;
 	fsg->product = prod_str;
diff --git a/drivers/usb/gadget/f_mtp.c b/drivers/usb/gadget/f_mtp.c
index d2078b9..194653b 100644
--- a/drivers/usb/gadget/f_mtp.c
+++ b/drivers/usb/gadget/f_mtp.c
@@ -59,22 +59,33 @@
  *
  */
 #define STRING_INTERFACE	0
-#define STRING_MTP      	1
+#define STRING_MTP      	0
 
 /* static strings, in UTF-8 */
-static struct usb_string mtp_string_defs[] = {
+static struct usb_string mtp_string_defs1[] = {
 	[STRING_INTERFACE].s = "Motorola MTP Interface",
-	[STRING_MTP].s = "MSFT100\034",
 	{  /* ZEROES END LIST */ },
 };
 
-static struct usb_gadget_strings mtp_string_table = {
+static struct usb_string mtp_string_defs2[] = {
+     [STRING_MTP].s = "MSFT100\034",
+     {  /* ZEROES END LIST */ },
+};
+
+
+static struct usb_gadget_strings mtp_string_table1 = {
 	.language =		0x0409,	/* en-us */
-	.strings =		mtp_string_defs,
+	.strings =		mtp_string_defs1,
+};
+
+static struct usb_gadget_strings mtp_string_table2 = {
+     .language =     0x0, /* en-us */
+     .strings =      mtp_string_defs2,
 };
 
 static struct usb_gadget_strings *mtp_strings[] = {
-	&mtp_string_table,
+	&mtp_string_table1,
+	&mtp_string_table2,
 	NULL,
 };
 
@@ -1153,11 +1164,11 @@ int __init mtp_function_add(struct usb_composite_dev *cdev,
 
 	status = usb_string_id(c->cdev);
 	if (status >= 0) {
-		mtp_string_defs[STRING_INTERFACE].id = status;
+		mtp_string_defs1[STRING_INTERFACE].id = status;
 		intf_desc.iInterface = status;
 	}
 
-	mtp_string_defs[STRING_MTP].id = mtp_ext_str_idx;
+	mtp_string_defs2[STRING_MTP].id = mtp_ext_str_idx;
 
 	g_usb_mtp_context.cdev = cdev;
 	g_usb_mtp_context.function.name = "mtp";
diff --git a/drivers/usb/gadget/mot_android.c b/drivers/usb/gadget/mot_android.c
index 8214441..0a07e1f 100644
--- a/drivers/usb/gadget/mot_android.c
+++ b/drivers/usb/gadget/mot_android.c
@@ -107,14 +107,16 @@ static struct device_pid_vid mot_android_vid_pid[MAX_DEVICE_TYPE_NUM] = {
 	 USB_CLASS_COMM, USB_CLASS_COMM, USB_CLASS_PER_INTERFACE},
 	{"eth_adb", ETH_TYPE_FLAG | ADB_TYPE_FLAG, 0x22b8, 0x41d4,
 	 "Motorola Android Composite Device"},
-	{"acm_eth_mtp", ACM_TYPE_FLAG | ETH_TYPE_FLAG | MTP_TYPE_FLAG, 0x22b8,
+	/* remove MTP_TYPE_FLAG here to disable mtp function driver */
+	{"acm_eth_mtp", ACM_TYPE_FLAG | ETH_TYPE_FLAG, 0x22b8,
 	 0x41d8, "Motorola Config 30", USB_CLASS_VENDOR_SPEC,
 	 USB_CLASS_VENDOR_SPEC, USB_CLASS_VENDOR_SPEC},
 	{"mtp_adb", MTP_TYPE_FLAG | ADB_TYPE_FLAG, 0x22b8, 0x41dc,
 	 "Motorola Config 32", USB_CLASS_VENDOR_SPEC,
 	 USB_CLASS_VENDOR_SPEC, USB_CLASS_VENDOR_SPEC},
 	{"acm_eth_mtp_adb",
-	 ACM_TYPE_FLAG | ETH_TYPE_FLAG | MTP_TYPE_FLAG | ADB_TYPE_FLAG, 0x22b8,
+	/* remove MTP_TYPE_FLAG here to disable mtp function driver */
+	 ACM_TYPE_FLAG | ETH_TYPE_FLAG | ADB_TYPE_FLAG, 0x22b8,
 	 0x41da, "Motorola Config 31", USB_CLASS_VENDOR_SPEC,
 	 USB_CLASS_VENDOR_SPEC, USB_CLASS_VENDOR_SPEC},
 	{"acm_eth_adb", ACM_TYPE_FLAG | ETH_TYPE_FLAG | ADB_TYPE_FLAG, 0x22b8,
@@ -489,7 +491,16 @@ static void force_reenumeration(struct android_dev *dev, int dev_type)
 
 	temp_enabled = dev_type & ADB_TYPE_FLAG;
 	f = adb_function_enable_id(temp_enabled,
-				   android_config_driver.next_interface_id);
+	/*			   android_config_driver.next_interface_id);*/
+	/*
+	 * For acm_eth_mtp and acm_eth_mtp_adb modes, mtp is disabled.
+	 * The interface number have to be increased one to match PC driver.
+	 */
+				((dev_type & ACM_TYPE_FLAG) &&
+					(dev_type & ETH_TYPE_FLAG)) ?
+				(android_config_driver.next_interface_id + 1) :
+				android_config_driver.next_interface_id);
+
 	if (temp_enabled) {
 		android_config_driver.interface[android_config_driver.
 						next_interface_id] = f;
diff --git a/drivers/usb/gadget/u_serial.c b/drivers/usb/gadget/u_serial.c
index 39827d1..217b4b6 100644
--- a/drivers/usb/gadget/u_serial.c
+++ b/drivers/usb/gadget/u_serial.c
@@ -998,10 +998,27 @@ static int gs_break_ctl(struct tty_struct *tty, int duration)
 	return status;
 }
 
+#ifdef CONFIG_USB_MOT_ANDROID
+/* Add TIOCMSET which is used by ATCMD */
+static int gs_tiocmset(struct tty_struct *tty, struct file *file,
+	unsigned int set, unsigned int clear)
+{
+	struct gs_port  *port = tty->driver_data;
+
+	printk(KERN_INFO "%s set=%x clear=%x \n", __func__, set, clear);
+	port->port_usb->tiocmset(port->port_usb, set, clear);
+	return 0;
+}
+#endif
+
 static const struct tty_operations gs_tty_ops = {
 	.open =			gs_open,
 	.close =		gs_close,
 	.write =		gs_write,
+
+#ifdef CONFIG_USB_MOT_ANDROID
+	.tiocmset =             gs_tiocmset,
+#endif
 	.put_char =		gs_put_char,
 	.flush_chars =		gs_flush_chars,
 	.write_room =		gs_write_room,
diff --git a/drivers/usb/gadget/u_serial.h b/drivers/usb/gadget/u_serial.h
index 300f0ed..724a4ce 100644
--- a/drivers/usb/gadget/u_serial.h
+++ b/drivers/usb/gadget/u_serial.h
@@ -42,6 +42,9 @@ struct gserial {
 	struct usb_cdc_line_coding port_line_coding;	/* 9600-8-N-1 etc */
 
 	/* notification callbacks */
+#ifdef CONFIG_USB_MOT_ANDROID
+	void (*tiocmset)(struct gserial *p, int set, int clear);
+#endif
 	void (*connect)(struct gserial *p);
 	void (*disconnect)(struct gserial *p);
 	int (*send_break)(struct gserial *p, int duration);
diff --git a/drivers/video/omap2/displays/Kconfig b/drivers/video/omap2/displays/Kconfig
index 55d85c1..7ec9e4d 100644
--- a/drivers/video/omap2/displays/Kconfig
+++ b/drivers/video/omap2/displays/Kconfig
@@ -51,4 +51,10 @@ config PANEL_SHOLES
         help
 	  LCD Panel used in sholes
 
+# charlotte adding to support HDMI 
+config PANEL_HDTV
+        tristate "HDTV Panel"
+        help
+	  HDTV Panel
+
 endmenu
diff --git a/drivers/video/omap2/displays/Makefile b/drivers/video/omap2/displays/Makefile
index 81ec8b8..5acdc4d 100644
--- a/drivers/video/omap2/displays/Makefile
+++ b/drivers/video/omap2/displays/Makefile
@@ -7,4 +7,6 @@ obj-$(CONFIG_PANEL_N800) += panel-n800.o
 
 obj-$(CONFIG_PANEL_ACX565AKM) += panel-acx565akm.o
 obj-$(CONFIG_PANEL_SHOLES) += panel-sholes.o
+# charlotte adding to support HDMI
+obj-$(CONFIG_PANEL_HDTV) += panel-hdtv.o
 obj-$(CONFIG_PANEL_ZOOM2) += panel-zoom2.o
diff --git a/drivers/video/omap2/displays/panel-hdtv.c b/drivers/video/omap2/displays/panel-hdtv.c
new file mode 100644
index 0000000..dc04e9c
--- /dev/null
+++ b/drivers/video/omap2/displays/panel-hdtv.c
@@ -0,0 +1,185 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+
+#include <mach/display.h>
+#include <mach/dma.h>
+
+#define DEBUG
+
+#ifdef DEBUG
+#define DBG(format, ...) (\
+	printk(KERN_DEBUG "hdtv-panel: " format, ## __VA_ARGS__))
+#else
+#define DBG(format, ...)
+#endif
+
+/* 720X480, Virtual 858X525*/
+static struct omap_video_timings hdtv_480p_panel_timings = {
+	.x_res          = 720,
+	.y_res          = 480,
+	.pixel_clock    = 27027,
+	.hfp            = 16,
+	.hsw            = 62,
+	.hbp            = 60,
+	.vfp            = 9,
+	.vsw            = 6,
+	.vbp            = 30,
+};
+
+
+/* 1280X720, Virtual 1650X750*/
+static struct omap_video_timings hdtv_720p_panel_timings = {
+	.x_res					= 1280,
+	.y_res					= 270,
+	.pixel_clock		= 74250,
+	.hfp						= 63,
+	.hsw						= 52,
+	.hbp						= 255,
+	.vfp						= 5,
+	.vsw						= 4,
+	.vbp						= 20,
+};
+
+static int hdtv_panel_probe(struct omap_dss_device *dssdev)
+{
+	DBG("%s IN\n", __func__);
+    /* TODO: timings should be configured by EDID data */
+	dssdev->panel.timings = hdtv_480p_panel_timings;
+	DBG("%s OUT\n", __func__);
+	return 0;
+}
+
+static void hdtv_panel_remove(struct omap_dss_device *dssdev)
+{
+	DBG("%s not supported\n", __func__);
+	return;
+}
+
+static int hdtv_panel_enable(struct omap_dss_device *dssdev)
+{
+    int ret;
+
+	DBG("%s IN\n", __func__);
+
+	if (dssdev->platform_enable)
+		ret = dssdev->platform_enable(dssdev);
+	else
+		ret = 0;
+
+	DBG("%s OUT\n", __func__);
+	return ret;
+}
+
+static void hdtv_panel_disable(struct omap_dss_device *dssdev)
+{
+	DBG("%s IN\n", __func__);
+
+	if (dssdev->platform_disable)
+		dssdev->platform_disable(dssdev);
+
+	DBG("%s OUT\n", __func__);
+}
+
+static void hdtv_panel_setup_update(struct omap_dss_device *dssdev,
+				      u16 x, u16 y, u16 w, u16 h)
+{
+	DBG("%s not supported\n", __func__);
+}
+
+static int hdtv_panel_enable_te(struct omap_dss_device *dssdev, bool enable)
+{
+	DBG("%s not supported\n", __func__);
+	return 0;
+}
+
+static int hdtv_panel_rotate(struct omap_dss_device *display, u8 rotate)
+{
+	DBG("%s not supported\n", __func__);
+	return 0;
+}
+
+static int hdtv_panel_mirror(struct omap_dss_device *display, bool enable)
+{
+	DBG("%s not supported\n", __func__);
+	return 0;
+}
+
+static int hdtv_panel_run_test(struct omap_dss_device *display, int test_num)
+{
+	DBG("%s not supported\n", __func__);
+	return 0;
+}
+
+static int hdtv_panel_suspend(struct omap_dss_device *dssdev)
+{
+	DBG("%s IN\n", __func__);
+
+	hdtv_panel_disable(dssdev);
+
+	DBG("%s OUT\n", __func__);
+	return 0;
+}
+
+static int hdtv_panel_resume(struct omap_dss_device *dssdev)
+{
+    int ret;
+	DBG("%s IN\n", __func__);
+
+	ret = hdtv_panel_enable(dssdev);
+
+	DBG("%s OUT\n", __func__);
+    return ret;
+}
+
+static bool hdtv_panel_te_support(struct omap_dss_device *dssdev)
+{
+	DBG("%s not supported\n", __func__);
+	return true;
+}
+
+static struct omap_dss_driver hdtv_panel_driver = {
+	.probe = hdtv_panel_probe,
+	.remove = hdtv_panel_remove,
+
+	.enable = hdtv_panel_enable,
+	.disable = hdtv_panel_disable,
+	.suspend = hdtv_panel_suspend,
+	.resume = hdtv_panel_resume,
+	.setup_update = hdtv_panel_setup_update,
+	.enable_te = hdtv_panel_enable_te,
+	.te_support = hdtv_panel_te_support,
+	.set_rotate = hdtv_panel_rotate,
+	.set_mirror = hdtv_panel_mirror,
+	.run_test = hdtv_panel_run_test,
+
+	.driver = {
+		.name = "hdtv-panel",
+		.owner = THIS_MODULE,
+	},
+};
+
+
+static int __init hdtv_panel_init(void)
+{
+	DBG("%s IN\n", __func__);
+	omap_dss_register_driver(&hdtv_panel_driver);
+	DBG("%s OUT\n", __func__);
+	return 0;
+}
+
+static void __exit hdtv_panel_exit(void)
+{
+	DBG("%s IN\n", __func__);
+	omap_dss_unregister_driver(&hdtv_panel_driver);
+	DBG("%s OUT\n", __func__);
+}
+
+module_init(hdtv_panel_init);
+module_exit(hdtv_panel_exit);
+
+MODULE_AUTHOR("Motorola");
+MODULE_DESCRIPTION("Hdtv Panel Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/omap2/displays/panel-sholes.c b/drivers/video/omap2/displays/panel-sholes.c
index ed08420..3828bf2 100644
--- a/drivers/video/omap2/displays/panel-sholes.c
+++ b/drivers/video/omap2/displays/panel-sholes.c
@@ -3,14 +3,22 @@
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/err.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/mutex.h>
+#include <linux/pagemap.h>
+#include <linux/platform_device.h>
 #include <linux/workqueue.h>
 #include <linux/sched.h>
+#include <linux/panel-suppliers.h>
 
 #include <mach/display.h>
 #include <mach/dma.h>
 #include <asm/atomic.h>
 
-#define DEBUG
+#include "panel-sholes.h"
+
 #ifdef DEBUG
 #define DBG(format, ...) (printk(KERN_DEBUG "sholes-panel: " format, ## __VA_ARGS__))
 #else
@@ -25,7 +33,9 @@
 #define EDISCO_CMD_SET_COLUMN_ADDRESS	0x2A
 #define EDISCO_CMD_SET_PAGE_ADDRESS	0x2B
 #define EDISCO_CMD_SET_TEAR_ON		0x35
+#define EDISCO_CMD_SET_TEAR_OFF		0x34
 #define EDISCO_CMD_SET_TEAR_SCANLINE	0x44
+#define EDISCO_CMD_READ_DDB_START	0xA1
 
 #define EDISCO_CMD_VC   0
 #define EDISCO_VIDEO_VC 1
@@ -53,7 +63,25 @@ static struct omap_video_timings sholes_panel_timings = {
 
 atomic_t state;
 
-static int sholes_panel_probe(struct omap_dss_device *dssdev)
+#define DEVICE_NAME  "lcd-choles"
+struct sholes_panel_device {
+	struct mutex  mtx; /* Lock for all device accesses */
+
+	int major;
+	struct class *cls;
+	struct device *dev;
+
+	int opened;
+
+	int fod_en; /* Freeze-On-Display state */
+	int panel_en;   /* Panel hardware state */
+	int dss_en; /* Last DSS state request */
+};
+
+static struct sholes_panel_device *gDev;
+static struct omap_dss_device *gDssdev;
+
+static int sholes_panel_dss_probe(struct omap_dss_device *dssdev)
 {
 	DBG("probe\n");
 	dssdev->ctrl.pixel_size = 24;
@@ -68,15 +96,41 @@ static int sholes_panel_probe(struct omap_dss_device *dssdev)
 	return 0;
 }
 
-static void sholes_panel_remove(struct omap_dss_device *dssdev)
+static void sholes_panel_dss_remove(struct omap_dss_device *dssdev)
 {
 	return;
 }
+static u16 sholes_panel_read_supplier_id(void)
+{
+	static u16 id = SUPPLIER_ID_INVALID;
+	u8 data[2];
+
+	if (id == SUPPLIER_ID_AUO || id == SUPPLIER_ID_TMD)
+		goto end;
+
+	if (dsi_vc_set_max_rx_packet_size(EDISCO_CMD_VC, 2))
+		goto end;
+
+	if (dsi_vc_dcs_read(EDISCO_CMD_VC, EDISCO_CMD_READ_DDB_START, data, 2) != 2)
+		goto end;
+		
+	if (dsi_vc_set_max_rx_packet_size(EDISCO_CMD_VC, 1))
+		goto end;
+
+	id = (data[0] << 8) | data[1];
+	
+	if (id != SUPPLIER_ID_AUO && id != SUPPLIER_ID_TMD)
+		id = SUPPLIER_ID_INVALID;
+end:
+	return id;
+}
 
-static int sholes_panel_enable(struct omap_dss_device *dssdev)
+static int sholes_panel_dss_enable(struct omap_dss_device *dssdev)
 {
 	u8 data[7];
-	int ret;
+	u16 id = SUPPLIER_ID_INVALID;
+	
+	int ret = 0;
 
 	DBG("enable\n");
 	if (dssdev->platform_enable) {
@@ -85,65 +139,137 @@ static int sholes_panel_enable(struct omap_dss_device *dssdev)
 			return ret;
 	}
 
-	/* turn of mcs register acces protection */
-	data[0] = 0xb2;
-	data[1] = 0x00;
-	ret = dsi_vc_write(EDISCO_CMD_VC, EDISCO_SHORT_WRITE_1, data, 2);
-
-	/* enable lane setting and test registers*/
-	data[0] = 0xef;
-	data[1] = 0x01;
-	data[2] = 0x01;
-	ret = dsi_vc_write(EDISCO_CMD_VC, EDISCO_LONG_WRITE, data, 3);
-
-	/* 2nd param 61 = 1 line; 63 = 2 lanes */
-	data[0] = 0xef;
-	data[1] = 0x60;
-	data[2] = 0x63;
-	ret = dsi_vc_dcs_write(EDISCO_CMD_VC, data, 3);
+	mutex_lock(&gDev->mtx);
+	if (gDev->fod_en)
+		atomic_set(&state, PANEL_OFF);
+	gDev->dss_en = 1;
+	gDev->panel_en = 1;
+	mutex_unlock(&gDev->mtx);
+
+	id = sholes_panel_read_supplier_id();
+
+	if (id == SUPPLIER_ID_AUO) {
+		/* turn of mcs register acces protection */
+		data[0] = 0xb2;
+		data[1] = 0x00;
+		data[2] = 0x00;
+		data[3] = 0x00;
+		ret |= dsi_vc_write(EDISCO_CMD_VC, EDISCO_LONG_WRITE, data, 4);
+
+		/* enable lane setting and test registers*/
+		data[0] = 0xef;
+		data[1] = 0x01;
+		data[2] = 0x01;
+		data[3] = 0x00;
+		ret |= dsi_vc_write(EDISCO_CMD_VC, EDISCO_LONG_WRITE, data, 4);
+
+		/* 2nd param 61 = 1 line; 63 = 2 lanes */
+		data[0] = 0xef;
+		data[1] = 0x60;
+		data[2] = 0x63;
+		data[3] = 0x00;
+		ret |= dsi_vc_write(EDISCO_CMD_VC, EDISCO_LONG_WRITE, data, 4);
+
+		/* Set dynamic backlight control PWM; D[7:4] = PWM_DIV[3:0];*/
+		/* D[3]=0 (PWM OFF);
+		 * D[2]=0 (auto BL control OFF);
+		 * D[1]=0 (Grama correction On);
+		 * D[0]=0 (Enhanced Image Correction OFF) */
+		data[0] = 0xb4;
+		data[1] = (id == SUPPLIER_ID_AUO ? 0x0F : 0x1F);
+		data[2] = 0x03;
+		data[3] = 0x00;
+		ret |= dsi_vc_write(EDISCO_CMD_VC, EDISCO_LONG_WRITE, data, 4);
+
+		/* set page, column address */
+		data[0] = EDISCO_CMD_SET_PAGE_ADDRESS;
+		data[1] = 0x00;
+		data[2] = 0x00;
+		data[3] = (dssdev->panel.timings.y_res - 1) >> 8;
+		data[4] = (dssdev->panel.timings.y_res - 1) & 0xff;
+		data[5] = 0x00;
+		ret |= dsi_vc_dcs_write(EDISCO_CMD_VC, data, 6);
+
+		data[0] = EDISCO_CMD_SET_COLUMN_ADDRESS;
+		data[1] = 0x00;
+		data[2] = 0x00;
+		data[3] = (dssdev->panel.timings.x_res - 1) >> 8;
+		data[4] = (dssdev->panel.timings.x_res - 1) & 0xff;
+		data[5] = 0x00;
+		ret |= dsi_vc_dcs_write(EDISCO_CMD_VC, data, 6);
+
+		/* turn it on */
+		data[0] = EDISCO_CMD_EXIT_SLEEP_MODE;
+		data[1] = 0x00;
+		data[2] = 0x00;
+		data[3] = 0x00;
+		ret |= dsi_vc_dcs_write(EDISCO_CMD_VC, data, 4);
 
-	/* 2nd param 0 = WVGA; 1 = WQVGA */
-	data[0] = 0xb3;
-	data[1] = 0x00;
-	ret = dsi_vc_dcs_write(EDISCO_CMD_VC, data, 2);
+	}
+	else if (id == SUPPLIER_ID_TMD) {
+
+		/* turn of mcs register acces protection */
+		data[0] = 0xb2;
+		data[1] = 0x00;
+		ret |= dsi_vc_write(EDISCO_CMD_VC, EDISCO_SHORT_WRITE_1, data, 2);
+		
+		/* enable lane setting and test registers*/
+		data[0] = 0xef;
+		data[1] = 0x01;
+		data[2] = 0x01;
+		ret |= dsi_vc_write(EDISCO_CMD_VC, EDISCO_LONG_WRITE, data, 3);
+
+		/* 2nd param 61 = 1 line; 63 = 2 lanes */
+		data[0] = 0xef;
+		data[1] = 0x60;
+		data[2] = 0x63;
+		ret |= dsi_vc_write(EDISCO_CMD_VC, EDISCO_LONG_WRITE, data, 3);
+
+		/* Set dynamic backlight control PWM; D[7:4] = PWM_DIV[3:0];*/
+		/* D[3]=0 (PWM OFF);
+		 * D[2]=0 (auto BL control OFF);
+		 * D[1]=0 (Grama correction On);
+		 * D[0]=0 (Enhanced Image Correction OFF) */
+		data[0] = 0xb4;
+		data[1] = (id == SUPPLIER_ID_AUO ? 0x0F : 0x1F);
+		ret |= dsi_vc_write(EDISCO_CMD_VC, EDISCO_SHORT_WRITE_1, data, 2);
+
+		/* set page, column address */
+		data[0] = EDISCO_CMD_SET_PAGE_ADDRESS;
+		data[1] = 0x00;
+		data[2] = 0x00;
+		data[3] = (dssdev->panel.timings.y_res - 1) >> 8;
+		data[4] = (dssdev->panel.timings.y_res - 1) & 0xff;
+		ret |= dsi_vc_dcs_write(EDISCO_CMD_VC, data, 5);
+
+		data[0] = EDISCO_CMD_SET_COLUMN_ADDRESS;
+		data[1] = 0x00;
+		data[2] = 0x00;
+		data[3] = (dssdev->panel.timings.x_res - 1) >> 8;
+		data[4] = (dssdev->panel.timings.x_res - 1) & 0xff;
+		ret |= dsi_vc_dcs_write(EDISCO_CMD_VC, data, 5);
+
+		/* turn it on */
+		data[0] = EDISCO_CMD_EXIT_SLEEP_MODE;
+		ret |= dsi_vc_dcs_write(EDISCO_CMD_VC, data, 1);
 
-	/* Set dynamic backlight control and PWM; D[7:4] = PWM_DIV[3:0];*/
-	/* D[3]=0 (PWM OFF);
-	 * D[2]=0 (auto BL control OFF);
-	 * D[1]=0 (Grama correction On);
-	 * D[0]=0 (Enhanced Image Correction OFF) */
-	data[0] = 0xb4;
-	data[1] = 0x1f;
-	ret = dsi_vc_dcs_write(EDISCO_CMD_VC, data, 2);
+	}
+	else {
 
-	/* set page, column address */
-	data[0] = EDISCO_CMD_SET_PAGE_ADDRESS;
-	data[1] = 0x00;
-	data[2] = 0x00;
-	data[3] = (dssdev->panel.timings.y_res - 1) >> 8;
-	data[4] = (dssdev->panel.timings.y_res - 1) & 0xff;
-	ret = dsi_vc_dcs_write(EDISCO_CMD_VC, data, 5);
-	if (ret)
+		DBG("Panel not installed\n");
 		goto error;
+	}
 
-	data[0] = EDISCO_CMD_SET_COLUMN_ADDRESS;
-	data[1] = 0x00;
-	data[2] = 0x00;
-	data[3] = (dssdev->panel.timings.x_res - 1) >> 8;
-	data[4] = (dssdev->panel.timings.x_res - 1) & 0xff;
-	ret = dsi_vc_dcs_write(EDISCO_CMD_VC, data, 5);
-	if (ret)
-		goto error;
+	mdelay(200);
 
-	/* turn it on */
-	data[0] = EDISCO_CMD_EXIT_SLEEP_MODE;
-	//ret = dsi_vc_write(EDISCO_CMD_VC, EDISCO_SHORT_WRITE_0, data, 1);
-	ret = dsi_vc_dcs_write(EDISCO_CMD_VC, data, 1);
+	DBG("supplier id: 0x%04x\n", (unsigned int)id);
 
-	mdelay(200);
+	if (ret)
+		goto error;
 
 	return 0;
 error:
+	atomic_set(&state, PANEL_OFF);
 	return -EINVAL;
 }
 
@@ -152,7 +278,6 @@ static void sholes_panel_disable(struct omap_dss_device *dssdev)
 	u8 data[1];
 	struct sholes_data *sholes_data = dssdev->data;
 
-	DBG("sholes_panel_ctrl_disable\n");
 
 	data[0] = EDISCO_CMD_SET_DISPLAY_OFF;
 	dsi_vc_dcs_write(EDISCO_CMD_VC, data, 1);
@@ -168,19 +293,40 @@ static void sholes_panel_disable(struct omap_dss_device *dssdev)
 
 }
 
+static void sholes_panel_dss_disable(struct omap_dss_device *dssdev)
+{
+	DBG("sholes_panel_dss_disable\n");
+
+	mutex_lock(&gDev->mtx);
+
+	gDev->dss_en = 0;
+
+	if (gDev->fod_en) {
+		DBG("Freezing the last frame on the display\n");
+		mutex_unlock(&gDev->mtx);
+		return;
+	}
+
+	gDev->panel_en = 0;
+
+	mutex_unlock(&gDev->mtx);
+
+	sholes_panel_disable(dssdev);
+}
+
 static int sholes_panel_display_on(struct omap_dss_device *dssdev)
 {
 	u8 data = EDISCO_CMD_SET_DISPLAY_ON;
 
 	if (atomic_cmpxchg(&state, PANEL_OFF, PANEL_ON) ==
-	    PANEL_OFF) {
+		PANEL_OFF) {
 		return dsi_vc_dcs_write(EDISCO_CMD_VC, &data, 1);
 	}
 	return 0;
 }
 
-static void sholes_panel_setup_update(struct omap_dss_device *dssdev,
-				      u16 x, u16 y, u16 w, u16 h)
+static void sholes_panel_dss_setup_update(struct omap_dss_device *dssdev,
+					  u16 x, u16 y, u16 w, u16 h)
 {
 
 	u8 data[5];
@@ -206,11 +352,12 @@ static void sholes_panel_setup_update(struct omap_dss_device *dssdev,
 		return;
 }
 
-static int sholes_panel_enable_te(struct omap_dss_device *dssdev, bool enable)
+static int sholes_panel_dss_enable_te(struct omap_dss_device *dssdev, bool enable)
 {
 	u8 data[3];
 	int ret;
 
+	if (enable) {
 	data[0] = EDISCO_CMD_SET_TEAR_ON;
 	data[1] = 0x00;
 	ret = dsi_vc_dcs_write(EDISCO_CMD_VC, data, 2);
@@ -223,6 +370,12 @@ static int sholes_panel_enable_te(struct omap_dss_device *dssdev, bool enable)
 	ret = dsi_vc_dcs_write(EDISCO_CMD_VC, data, 3);
 	if (ret)
 		goto error;
+	} else {
+		data[0] = EDISCO_CMD_SET_TEAR_OFF;
+		ret = dsi_vc_dcs_write(EDISCO_CMD_VC, data, 1);
+		if (ret)
+			goto error;
+	}
 
 	DBG("edisco_ctrl_enable_te \n");
 	return 0;
@@ -231,46 +384,46 @@ error:
 	return -EINVAL;
 }
 
-static int sholes_panel_rotate(struct omap_dss_device *display, u8 rotate)
+static int sholes_panel_dss_rotate(struct omap_dss_device *display, u8 rotate)
 {
 	return 0;
 }
 
-static int sholes_panel_mirror(struct omap_dss_device *display, bool enable)
+static int sholes_panel_dss_mirror(struct omap_dss_device *display, bool enable)
 {
 	return 0;
 }
 
-static int sholes_panel_run_test(struct omap_dss_device *display, int test_num)
+static int sholes_panel_dss_run_test(struct omap_dss_device *display, int test_num)
 {
 	return 0;
 }
 
-static int sholes_panel_suspend(struct omap_dss_device *dssdev)
+static int sholes_panel_dss_suspend(struct omap_dss_device *dssdev)
 {
-	sholes_panel_disable(dssdev);
+	sholes_panel_dss_disable(dssdev);
 	return 0;
 }
 
-static int sholes_panel_resume(struct omap_dss_device *dssdev)
+static int sholes_panel_dss_resume(struct omap_dss_device *dssdev)
 {
-	return sholes_panel_enable(dssdev);
+	return sholes_panel_dss_enable(dssdev);
 }
 
-static struct omap_dss_driver sholes_panel_driver = {
-	.probe = sholes_panel_probe,
-	.remove = sholes_panel_remove,
+static struct omap_dss_driver sholes_panel_dss_driver = {
+	.probe = sholes_panel_dss_probe,
+	.remove = sholes_panel_dss_remove,
 
-	.enable = sholes_panel_enable,
+	.enable = sholes_panel_dss_enable,
 	.framedone = sholes_panel_display_on,
-	.disable = sholes_panel_disable,
-	.suspend = sholes_panel_suspend,
-	.resume = sholes_panel_resume,
-	.setup_update = sholes_panel_setup_update,
-	.enable_te = sholes_panel_enable_te,
-	.set_rotate = sholes_panel_rotate,
-	.set_mirror = sholes_panel_mirror,
-	.run_test = sholes_panel_run_test,
+	.disable = sholes_panel_dss_disable,
+	.suspend = sholes_panel_dss_suspend,
+	.resume = sholes_panel_dss_resume,
+	.setup_update = sholes_panel_dss_setup_update,
+	.enable_te = sholes_panel_dss_enable_te,
+	.set_rotate = sholes_panel_dss_rotate,
+	.set_mirror = sholes_panel_dss_mirror,
+	.run_test = sholes_panel_dss_run_test,
 
 	.driver = {
 		.name = "sholes-panel",
@@ -278,19 +431,248 @@ static struct omap_dss_driver sholes_panel_driver = {
 	},
 };
 
+static ssize_t show_panel_supplier(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u",
+			(unsigned int)sholes_panel_read_supplier_id());
+}
+
+static DEVICE_ATTR(panel_supplier, 0644, show_panel_supplier, NULL);
+
+/*=== Driver Interface Functions =======================================*/
+
+static int sholes_panel_set_fod(int *fod_en)
+{
+	int rc;
+	int en;
+
+	rc = copy_from_user(&en, fod_en, sizeof(int));
+	if (rc != 0) {
+		DBG("S_FOD copy from user failed\n");
+		goto failed;
+	}
+
+	en = (en) ? 1 : 0;
+
+	if (en != gDev->fod_en) {
+		gDev->fod_en = en;
+		if (!en && !gDev->dss_en && gDev->panel_en) {
+			dsi_bus_lock();
+			gDev->panel_en = 0;
+			sholes_panel_disable(gDssdev);
+			dsi_bus_unlock();
+		}
+	}
+
+failed:
+	return rc;
+}
+static int sholes_panel_open(struct inode *inode, struct file *file)
+{
+	int rc = 0;
+
+	DBG("sholes_panel_open\n");
+
+	if (gDev == NULL) {
+		DBG("Invalid device\n");
+		return -ENODEV;
+	}
+
+	mutex_lock(&gDev->mtx);
+
+	/* We only support single open */
+	if (gDev->opened) {
+		DBG("Device already opened\n");
+		rc = -EBUSY;
+		goto failed;
+	}
+
+	gDev->opened = 1;
+
+failed:
+	mutex_unlock(&gDev->mtx);
+	return rc;
+}
+
+static int sholes_panel_release(struct inode *inode, struct file *file)
+{
+	int rc = 0;
+
+	DBG("sholes_panel_release\n");
+
+	if (gDev == NULL) {
+		DBG("Invalid device\n");
+		return -ENODEV;
+	}
+
+	mutex_lock(&gDev->mtx);
+
+	gDev->opened = 0;
+
+	mutex_unlock(&gDev->mtx);
+
+	return rc;
+}
+
+static int sholes_panel_ioctl(struct inode *inode, struct file *file,
+							u_int cmd, u_long arg)
+{
+	int rc = 0;
+
+	if (unlikely(_IOC_TYPE(cmd) != SHOLES_IOCTL_MAGIC)) {
+		printk(KERN_ERR "Bad command value (%d)\n", cmd);
+		return -EINVAL;
+	}
+
+	mutex_lock(&gDev->mtx);
+
+	switch (cmd) {
+	case SHOLES_G_FOD:
+		rc = put_user(gDev->fod_en, (int *) arg);
+		break;
+	case SHOLES_S_FOD:
+		rc = sholes_panel_set_fod((int *) arg);
+		break;
+	default:
+		DBG("Invalid ioctl (%x)\n", cmd);
+		rc = -EINVAL;
+		break;
+	}
+
+	mutex_unlock(&gDev->mtx);
+
+	return rc;
+}
+
+static const struct file_operations sholes_panel_fops = {
+	.owner = THIS_MODULE,
+	.open = sholes_panel_open,
+	.release = sholes_panel_release,
+	.ioctl = sholes_panel_ioctl,
+};
+
+
+static int __init sholes_panel_probe(struct platform_device *pdev)
+{
+	int rc = 0;
+
+	DBG("sholes_panel_probe\n");
+
+	gDev = kzalloc(sizeof(struct sholes_panel_device), GFP_KERNEL);
+	if (gDev == NULL)
+		return -ENOMEM;
+
+	memset(gDev, 0, sizeof(gDev));
+
+	mutex_init(&gDev->mtx);
+
+	gDev->opened = 0;
+
+	gDev->major = register_chrdev(0, DEVICE_NAME, &sholes_panel_fops);
+	if (gDev->major < 0) {
+		printk(KERN_ERR "failed chrdev register\n");
+		rc = -ENODEV;
+		goto failed_chrdev;
+	}
+
+	gDev->cls = class_create(THIS_MODULE, DEVICE_NAME);
+	if (IS_ERR(gDev->cls)) {
+		printk(KERN_DEBUG "failed class creation\n");
+		rc = PTR_ERR(gDev->cls);
+		goto failed_class;
+	}
+
+	gDev->dev = device_create(gDev->cls, gDev->dev, MKDEV(gDev->major, 0),
+							NULL, DEVICE_NAME);
+
+	rc = device_create_file(gDev->dev, &dev_attr_panel_supplier);
+	if (rc < 0) {
+		pr_err("%s:File device creation failed: %d\n", __func__, rc);
+		rc = -ENODEV;
+		goto failed_attribute;
+	}
+	return 0;
+
+failed_attribute:
+	device_remove_file(gDev->dev, &dev_attr_panel_supplier);
+failed_class:
+	unregister_chrdev(gDev->major, DEVICE_NAME);
+failed_chrdev:
+	kfree(gDev);
+	gDev = NULL;
+	return rc;
+}
+
+static int sholes_panel_remove(struct platform_device *pdev)
+{
+	struct sholes_panel_device *dsw = platform_get_drvdata(pdev);
+	
+	DBG("sholes panel remove\n");
+	
+	if(dsw) {
+		device_remove_file(dsw->dev, &dev_attr_panel_supplier);
+		class_destroy(dsw->cls);
+		unregister_chrdev(dsw->major, DEVICE_NAME);
+		kfree(dsw);
+	}
+	return 0;
+}
+
+static struct platform_device sholes_panel_dev = {
+	.name = DEVICE_NAME,
+	.id = -1,
+};
+
+static struct platform_driver sholes_panel_driver = {
+	.remove = sholes_panel_remove,
+	.driver = {
+		.name = DEVICE_NAME,
+	},
+};
+
+/*=== Driver Interface Functions =======================================*/
 
 static int __init sholes_panel_init(void)
 {
+	int rc = 0;
+	
 	DBG("sholes_panel_init\n");
-	omap_dss_register_driver(&sholes_panel_driver);
+
+	rc = platform_device_register(&sholes_panel_dev);
+	if(rc != 0) {
+		printk(KERN_ERR "failed panel device register %d\n", rc);
+		goto faildev;
+	}
+
+	rc = platform_driver_probe(&sholes_panel_driver, sholes_panel_probe);
+	if (rc != 0) {
+		printk(KERN_ERR "failed panel register/probe %d\n", rc);
+		goto faildrv;
+	}
+
+	rc = omap_dss_register_driver(&sholes_panel_dss_driver);
+	if(rc != 0) {
+		printk(KERN_ERR "failed panel dss register %d\n", rc);
+		goto faildss;
+	}
 	return 0;
+faildss:
+	platform_driver_unregister(&sholes_panel_driver);
+faildrv:
+	platform_device_unregister(&sholes_panel_dev);
+faildev:
+	return -ENODEV;
+
 }
 
 static void __exit sholes_panel_exit(void)
 {
 	DBG("sholes_panel_exit\n");
 
-	omap_dss_unregister_driver(&sholes_panel_driver);
+	omap_dss_unregister_driver(&sholes_panel_dss_driver);
+	platform_driver_unregister(&sholes_panel_driver);
+	platform_device_unregister(&sholes_panel_dev);
 }
 
 module_init(sholes_panel_init);
diff --git a/drivers/video/omap2/displays/panel-sholes.h b/drivers/video/omap2/displays/panel-sholes.h
new file mode 100644
index 0000000..86b3bce
--- /dev/null
+++ b/drivers/video/omap2/displays/panel-sholes.h
@@ -0,0 +1,13 @@
+#ifndef __PANEL_SHOLES_H__
+#define __PANEL_SHOLES_H__
+
+#define SHOLES_IOCTL_MAGIC  'g'
+#define SHOLES_IOCTL_BASE   0x60
+
+/* Freeze On Disable */
+#define SHOLES_G_FOD        _IOR(SHOLES_IOCTL_MAGIC, \
+                    SHOLES_IOCTL_BASE+0, int)
+#define SHOLES_S_FOD        _IOW(SHOLES_IOCTL_MAGIC, \
+                    SHOLES_IOCTL_BASE+1, int)
+
+#endif /* __PANEL_SHOLES_H__ */
diff --git a/drivers/video/omap2/dss/display.c b/drivers/video/omap2/dss/display.c
index fac6515..cd68868 100644
--- a/drivers/video/omap2/dss/display.c
+++ b/drivers/video/omap2/dss/display.c
@@ -277,16 +277,26 @@ static ssize_t display_wss_store(struct device *dev,
 	return size;
 }
 
+#ifdef CONFIG_PANEL_HDTV /* charlotte change permission S_IRUGO->S_IRWXUGO */
+static DEVICE_ATTR(enabled, S_IRWXUGO|S_IWUSR,
+		display_enabled_show, display_enabled_store);
+#else
 static DEVICE_ATTR(enabled, S_IRUGO|S_IWUSR,
 		display_enabled_show, display_enabled_store);
+#endif
 static DEVICE_ATTR(update_mode, S_IRUGO|S_IWUSR,
 		display_upd_mode_show, display_upd_mode_store);
 static DEVICE_ATTR(tear_elim, S_IRUGO|S_IWUSR,
 		display_tear_show, display_tear_store);
 static DEVICE_ATTR(timings, S_IRUGO|S_IWUSR,
 		display_timings_show, display_timings_store);
+#ifdef CONFIG_PANEL_HDTV /* charlotte change permission S_IRUGO->S_IRWXUGO */
+static DEVICE_ATTR(rotate, S_IRWXUGO|S_IWUSR,
+		display_rotate_show, display_rotate_store);
+#else
 static DEVICE_ATTR(rotate, S_IRUGO|S_IWUSR,
 		display_rotate_show, display_rotate_store);
+#endif
 static DEVICE_ATTR(mirror, S_IRUGO|S_IWUSR,
 		display_mirror_show, display_mirror_store);
 static DEVICE_ATTR(wss, S_IRUGO|S_IWUSR,
diff --git a/drivers/video/omap2/dss/dsi.c b/drivers/video/omap2/dss/dsi.c
index c197129..eb4fc33 100644
--- a/drivers/video/omap2/dss/dsi.c
+++ b/drivers/video/omap2/dss/dsi.c
@@ -32,6 +32,7 @@
 #include <linux/regulator/consumer.h>
 #include <linux/kthread.h>
 #include <linux/wait.h>
+#include <linux/delay.h>
 
 #include <mach/board.h>
 #include <mach/display.h>
@@ -228,6 +229,8 @@ static struct
 	unsigned pll_locked;
 
 	struct completion bta_completion;
+	struct completion packet_sent_completion;
+	struct completion te_trigger_completion;
 
 	struct task_struct *thread;
 	wait_queue_head_t waitqueue;
@@ -552,6 +555,9 @@ void dsi_irq_handler(void)
 		print_irq_status(irqstatus);
 	}
 
+	if (irqstatus & DSI_IRQ_TE_TRIGGER)
+		complete(&dsi.te_trigger_completion);
+
 	for (i = 0; i < 4; ++i) {
 		if ((irqstatus & (1<<i)) == 0)
 			continue;
@@ -560,7 +566,8 @@ void dsi_irq_handler(void)
 
 		if (vcstatus & DSI_VC_IRQ_BTA)
 			complete(&dsi.bta_completion);
-
+		if (vcstatus & DSI_VC_IRQ_PACKET_SENT)
+			complete(&dsi.packet_sent_completion);
 		if (vcstatus & DSI_VC_IRQ_ERROR_MASK) {
 			DSSERR("DSI VC(%d) error, vc irqstatus %x\n",
 				       i, vcstatus);
@@ -637,6 +644,24 @@ static u32 dsi_get_errors(void)
 	return e;
 }
 
+static void dsi_enable_te_irq(void)
+{
+	u32 l;
+
+	l = dsi_read_reg(DSI_IRQENABLE);
+	l |= DSI_IRQ_TE_TRIGGER;
+	dsi_write_reg(DSI_IRQENABLE, l);
+}
+
+static void dsi_disable_te_irq(int channel)
+{
+	u32 l;
+
+	l = dsi_read_reg(DSI_IRQENABLE);
+	l &= ~DSI_IRQ_TE_TRIGGER;
+	dsi_write_reg(DSI_IRQENABLE, l);
+}
+
 static void dsi_vc_enable_bta_irq(int channel)
 {
 	u32 l;
@@ -654,7 +679,23 @@ static void dsi_vc_disable_bta_irq(int channel)
 	l &= ~DSI_VC_IRQ_BTA;
 	dsi_write_reg(DSI_VC_IRQENABLE(channel), l);
 }
+static void dsi_vc_enable_packet_sent_irq(int channel)
+{
+	u32 l;
 
+	l = dsi_read_reg(DSI_VC_IRQENABLE(channel));
+	l |= DSI_VC_IRQ_PACKET_SENT;
+	dsi_write_reg(DSI_VC_IRQENABLE(channel), l);
+}
+
+static void dsi_vc_disable_packet_sent_irq(int channel)
+{
+	u32 l;
+
+	l = dsi_read_reg(DSI_VC_IRQENABLE(channel));
+	l &= ~DSI_VC_IRQ_PACKET_SENT;
+	dsi_write_reg(DSI_VC_IRQENABLE(channel), l);
+}
 /* DSI func clock. this could also be DSI2_PLL_FCLK */
 static inline void enable_clocks(bool enable)
 {
@@ -767,6 +808,8 @@ static int dsi_set_lp_clk_divisor(struct omap_dss_device *dssdev)
 	if (dsi_fclk > 30*1000*1000)
 		REG_FLD_MOD(DSI_CLK_CTRL, 1, 21, 21); /* LP_RX_SYNCHRO_ENABLE */
 
+	REG_FLD_MOD(DSI_CLK_CTRL, 0, 13, 13);	/* NON CONTINUOUS CLK MODE */
+
 	return 0;
 }
 
@@ -1431,13 +1474,13 @@ static void dsi_complexio_timings(void)
 
 	/* calculate timings */
 
-	/* 1 * DDR_CLK = 2 * UI */
+	/* DDR_CLK = 1 / (2 * UI) */
 
 	/* min 40ns + 4*UI	max 85ns + 6*UI */
 	ths_prepare = ns2ddr(70) + 2;
 
-	/* min 145ns + 10*UI */
-	ths_prepare_ths_zero = ns2ddr(175) + 2;
+	/* min 145ns + 10*UI for TMD, min 480ns for AUO */
+	ths_prepare_ths_zero = ns2ddr(175 + 425) + 2;
 
 	/* min max(8*UI, 60ns+4*UI) */
 	ths_trail = ns2ddr(60) + 5;
@@ -1446,7 +1489,10 @@ static void dsi_complexio_timings(void)
 	ths_exit = ns2ddr(145);
 
 	/* tlpx min 50n */
+	/* AUO experiment it's less than 50ns 
 	tlpx_half = ns2ddr(25);
+	*/
+	tlpx_half = ns2ddr(30);
 
 	/* min 60ns */
 	tclk_trail = ns2ddr(60) + 2;
@@ -1846,6 +1892,8 @@ static int dsi_vc_send_bta(int channel)
 		dsi_vc_flush_receive_data(channel);
 	}
 
+	udelay(1); /* Make sure the packet to packet interval for AUO 3.7 */
+	
 	REG_FLD_MOD(DSI_VC_CTRL(channel), 1, 6, 6); /* BTA_EN */
 
 	tmo = jiffies + msecs_to_jiffies(10);
@@ -1911,6 +1959,8 @@ static inline void dsi_vc_write_long_header(int channel, u8 data_type,
 	val = FLD_VAL(data_id, 7, 0) | FLD_VAL(len, 23, 8) |
 		FLD_VAL(ecc, 31, 24);
 
+	udelay(1); /* Make sure the packet to packet interval for AUO 3.7 */
+	
 	dsi_write_reg(DSI_VC_LONG_PACKET_HEADER(channel), val);
 }
 
@@ -1947,7 +1997,8 @@ static int dsi_vc_send_long(int channel, u8 data_type, u8 *data, u16 len,
 
 	enable_clocks(1);
 	dsi_enable_pll_clock(1);
-
+	INIT_COMPLETION(dsi.packet_sent_completion);
+	dsi_vc_enable_packet_sent_irq(channel);
 	dsi_vc_write_long_header(channel, data_type, len, ecc);
 
 	/*dsi_vc_print_status(0); */
@@ -1991,6 +2042,12 @@ static int dsi_vc_send_long(int channel, u8 data_type, u8 *data, u16 len,
 		dsi_vc_write_long_payload(channel, b1, b2, b3, 0);
 	}
 
+	if (wait_for_completion_timeout(&dsi.packet_sent_completion, msecs_to_jiffies(10)) == 0) {
+		DSSERR("Failed to send long packet\n");
+	}
+
+	dsi_vc_disable_packet_sent_irq(channel);
+
 	enable_clocks(0);
 	dsi_enable_pll_clock(0);
 
@@ -2008,6 +2065,7 @@ static int dsi_vc_send_short(int channel, u8 data_type, u16 data, u8 ecc)
 		DSSDBG("dsi_vc_send_short(ch%d, dt %#x, b1 %#x, b2 %#x)\n",
 				channel,
 				data_type, data & 0xff, (data >> 8) & 0xff);
+
 	enable_clocks(1);
 	dsi_enable_pll_clock(1);
 
@@ -2020,7 +2078,16 @@ static int dsi_vc_send_short(int channel, u8 data_type, u16 data, u8 ecc)
 
 	r = (data_id << 0) | (data << 8) | (ecc << 24);
 
+	udelay(1); /* Make sure the packet to packet interval for AUO 3.7 */
+	
+	INIT_COMPLETION(dsi.packet_sent_completion);
+	dsi_vc_enable_packet_sent_irq(channel);
 	dsi_write_reg(DSI_VC_SHORT_PACKET_HEADER(channel), r);
+	if (wait_for_completion_timeout(&dsi.packet_sent_completion, msecs_to_jiffies(10)) == 0) {
+		DSSERR("Failed to send short packet\n");
+	}
+
+	dsi_vc_disable_packet_sent_irq(channel);
 
 	enable_clocks(0);
 	dsi_enable_pll_clock(0);
@@ -2059,6 +2126,7 @@ int dsi_vc_write(int channel, u8 data_type, u8 *data, int len)
 	r = dsi_vc_write_nosync(channel, data_type, data, len);
 	if (r)
 		return r;
+
 	r = dsi_vc_send_bta_sync(channel);
 
 	return r;
@@ -2091,6 +2159,7 @@ int dsi_vc_dcs_write(int channel, u8 *data, int len)
 	if (r)
 		return r;
 
+
 	/* Some devices need time to process the msg in low power mode.
 	   This also makes the write synchronous, and checks that
 	   the peripheral is still alive */
@@ -2192,7 +2261,6 @@ int dsi_vc_dcs_read(int channel, u8 dcs_cmd, u8 *buf, int buflen)
 }
 EXPORT_SYMBOL(dsi_vc_dcs_read);
 
-
 int dsi_vc_set_max_rx_packet_size(int channel, u16 len)
 {
 	return dsi_vc_send_short(channel, DSI_DT_SET_MAX_RET_PKG_SIZE,
@@ -2483,6 +2551,22 @@ static void dsi_proto_timings(struct omap_dss_device *dssdev)
 			DSI_FLUSH(ch); \
 	} while (0)
 
+static int dsi_core_init(void)
+{
+	/* Autoidle */
+	REG_FLD_MOD(DSI_SYSCONFIG, 1, 0, 0);
+
+	/* ENWAKEUP */
+	REG_FLD_MOD(DSI_SYSCONFIG, 1, 2, 2);
+
+	/* SIDLEMODE smart-idle */
+	REG_FLD_MOD(DSI_SYSCONFIG, 2, 4, 3);
+
+	_dsi_initialize_irq();
+
+	return 0;
+}
+
 static int dsi_update_screen_l4(struct omap_dss_device *dssdev,
 			int x, int y, int w, int h)
 {
@@ -2664,8 +2748,21 @@ static void dsi_update_screen_dispc(struct omap_dss_device *dssdev,
 
 	dss_start_update(dssdev);
 
-	if (use_te_trigger)
+	if (use_te_trigger) {
+		dssdev->driver->enable_te(dssdev, 1);
+
+		INIT_COMPLETION(dsi.te_trigger_completion);
+		dsi_enable_te_irq();
+
 		dsi_vc_send_bta(1);
+
+		if (wait_for_completion_timeout(&dsi.te_trigger_completion,
+			msecs_to_jiffies(25)) == 0) {
+			dssdev->driver->enable_te(dssdev, 1);
+			dsi_vc_send_bta(1);
+			/* DSSERR("Retry sending TE trigger request\n"); */
+		}
+	}
 }
 
 static void dsi_framedone_irq_callback(void *data, u32 mask)
@@ -2975,9 +3072,15 @@ static int dsi_display_init_dsi(struct omap_dss_device *dssdev)
 {
 	struct dsi_clock_info cinfo;
 	int r;
+	int cnt = 0;
 
 	_dsi_print_reset_status();
 
+	/* disable interface first */
+	dsi_vc_enable(0, 0);
+	dsi_vc_enable(1, 0);
+	dsi_if_enable(0);
+
 #if CONFIG_OMAP2_DSS_USE_DSI_PLL
 	r = dsi_pll_init(1, 1);
 #else
@@ -3005,8 +3108,7 @@ static int dsi_display_init_dsi(struct omap_dss_device *dssdev)
 	dsi_proto_timings(dssdev);
 	dsi_set_lp_clk_divisor(dssdev);
 
-	if (1)
-		_dsi_print_reset_status();
+	_dsi_print_reset_status();
 
 	r = dsi_proto_config(dssdev);
 	if (r)
@@ -3019,9 +3121,57 @@ static int dsi_display_init_dsi(struct omap_dss_device *dssdev)
 	dsi_force_tx_stop_mode_io();
 
 	if (dssdev->driver->enable) {
-		r = dssdev->driver->enable(dssdev);
-		if (r)
+		while (1) {
+			r = dssdev->driver->enable(dssdev);
+			if((r == 0) || (cnt++ >= 2))
+				break;
+
+			DSSERR("Failed Init, 1. SW Rst DSI-block\n");
+
+			_dsi_reset();
+
+			dsi_core_init();
+
+#if CONFIG_OMAP2_DSS_USE_DSI_PLL
+			r = dsi_pll_init(1, 1);
+#else
+			r = dsi_pll_init(1, 0);
+#endif
+			if (r)
+				goto err0;
+
+			r = dsi_pll_calc_ddrfreq(dssdev, dssdev->phy.dsi.ddr_clk_hz, &cinfo);
+			if (r)
+				goto err1;
+
+			r = dsi_pll_program(&cinfo);
+			if (r)
+				goto err1;
+
+			r = dsi_complexio_init(dssdev);
+			if (r)
+				goto err1;
+
+			dsi_proto_timings(dssdev);
+			dsi_set_lp_clk_divisor(dssdev);
+
+			r = dsi_proto_config(dssdev);
+			if (r)
+				goto err2;
+
+			/* enable interface */
+			dsi_vc_enable(0, 1);
+			dsi_vc_enable(1, 1);
+			dsi_if_enable(1);
+			dsi_force_tx_stop_mode_io();
+
+			DSSERR("Failed Init, 2. Hard Rst Panel\n");
+
+		}
+		
+		if (cnt > 2)
 			goto err3;
+
 	}
 
 	/* enable high-speed after initial config */
@@ -3047,22 +3197,6 @@ static void dsi_display_uninit_dsi(struct omap_dss_device *dssdev)
 	dsi_pll_uninit();
 }
 
-static int dsi_core_init(void)
-{
-	/* Autoidle */
-	REG_FLD_MOD(DSI_SYSCONFIG, 1, 0, 0);
-
-	/* ENWAKEUP */
-	REG_FLD_MOD(DSI_SYSCONFIG, 1, 2, 2);
-
-	/* SIDLEMODE smart-idle */
-	REG_FLD_MOD(DSI_SYSCONFIG, 2, 4, 3);
-
-	_dsi_initialize_irq();
-
-	return 0;
-}
-
 static int dsi_display_enable(struct omap_dss_device *dssdev)
 {
 	int r = 0;
@@ -3086,11 +3220,11 @@ static int dsi_display_enable(struct omap_dss_device *dssdev)
 
 	enable_clocks(1);
 	dsi_enable_pll_clock(1);
-
+/* Skip to keep the DSI configuration of bootloader ==
 	r = _dsi_reset();
 	if (r)
 		goto err2;
-
+====================================================*/
 	dsi_core_init();
 
 	r = dsi_display_init_dispc(dssdev);
@@ -3104,7 +3238,19 @@ static int dsi_display_enable(struct omap_dss_device *dssdev)
 	dssdev->state = OMAP_DSS_DISPLAY_ACTIVE;
 
 	dsi.use_ext_te = dssdev->phy.dsi.ext_te;
+
+	/* Don't send TE DCS but modify LP_RX_TO for AUO 3.7
 	dsi_set_te(dssdev, dsi.te_enabled);
+	*/
+	if (!dsi.use_ext_te) {
+		if (dsi.te_enabled) {
+			/* disable LP_RX_TO, so that we can receive TE.  Time
+			 * to wait for TE is longer than the timer allows */
+			REG_FLD_MOD(DSI_TIMING2, 0, 15, 15); /* LP_RX_TO */
+		} else {
+			REG_FLD_MOD(DSI_TIMING2, 1, 15, 15); /* LP_RX_TO */
+		}
+	}
 
 	dsi.update_mode = dsi.user_update_mode;
 	if (dsi.update_mode == OMAP_DSS_UPDATE_AUTO)
@@ -3144,7 +3290,7 @@ static void dsi_display_disable(struct omap_dss_device *dssdev)
 	cancel_work_sync(&dsi.error_recovery.work);
 
 	complete_all(&dsi.update_completion);
-
+	complete_all(&dsi.packet_sent_completion);
 	if (dssdev->state == OMAP_DSS_DISPLAY_DISABLED ||
 			dssdev->state == OMAP_DSS_DISPLAY_SUSPENDED)
 		goto end;
@@ -3179,7 +3325,7 @@ static int dsi_display_suspend(struct omap_dss_device *dssdev)
 	cancel_work_sync(&dsi.error_recovery.work);
 
 	complete_all(&dsi.update_completion);
-
+	complete_all(&dsi.packet_sent_completion);
 	if (dssdev->state == OMAP_DSS_DISPLAY_DISABLED ||
 			dssdev->state == OMAP_DSS_DISPLAY_SUSPENDED)
 		goto end;
@@ -3237,8 +3383,19 @@ static int dsi_display_resume(struct omap_dss_device *dssdev)
 
 	dssdev->state = OMAP_DSS_DISPLAY_ACTIVE;
 
+	/* Don't send TE DCS but modify LP_RX_TO for AUO 3.7
 	dsi_set_te(dssdev, dsi.te_enabled);
-
+	*/
+	if (!dsi.use_ext_te) {
+		if (dsi.te_enabled) {
+			/* disable LP_RX_TO, so that we can receive TE.  Time
+			 * to wait for TE is longer than the timer allows */
+			REG_FLD_MOD(DSI_TIMING2, 0, 15, 15); /* LP_RX_TO */
+		} else {
+			REG_FLD_MOD(DSI_TIMING2, 1, 15, 15); /* LP_RX_TO */
+		}
+	}
+	
 	dsi.update_mode = dsi.user_update_mode;
 	if (dsi.update_mode == OMAP_DSS_UPDATE_AUTO)
 		dsi_start_auto_update(dssdev);
@@ -3399,7 +3556,19 @@ static int dsi_display_enable_te(struct omap_dss_device *dssdev, bool enable)
 	if (dssdev->state != OMAP_DSS_DISPLAY_ACTIVE)
 		goto end;
 
-	dsi_set_te(dssdev, enable);
+	/* Don't send TE DCS but modify LP_RX_TO for AUO 3.7
+ 	dsi_set_te(dssdev, enable);
+	*/
+	if (!dsi.use_ext_te) {
+		if (enable) {
+			/* disable LP_RX_TO, so that we can receive TE.  Time
+			 * to wait for TE is longer than the timer allows */
+			REG_FLD_MOD(DSI_TIMING2, 0, 15, 15); /* LP_RX_TO */
+		} else {
+			REG_FLD_MOD(DSI_TIMING2, 1, 15, 15); /* LP_RX_TO */
+		}
+	}
+
 end:
 	enable_clocks(0);
 	dsi_enable_pll_clock(0);
@@ -3627,9 +3796,11 @@ int dsi_init(struct platform_device *pdev)
 	dsi.errors = 0;
 
 	/* XXX fail properly */
-
+	printk(KERN_INFO "ASK036 TEST\n");
 	init_completion(&dsi.bta_completion);
+	init_completion(&dsi.packet_sent_completion);
 	init_completion(&dsi.update_completion);
+	init_completion(&dsi.te_trigger_completion);
 
 	dsi.thread = kthread_create(dsi_update_thread, NULL, "dsi");
 	if (IS_ERR(dsi.thread)) {
diff --git a/drivers/video/omap2/dss/manager.c b/drivers/video/omap2/dss/manager.c
index 3e33898..f8d2aa3 100644
--- a/drivers/video/omap2/dss/manager.c
+++ b/drivers/video/omap2/dss/manager.c
@@ -284,8 +284,13 @@ struct manager_attribute {
 	__ATTR(_name, _mode, _show, _store)
 
 static MANAGER_ATTR(name, S_IRUGO, manager_name_show, NULL);
+#ifdef CONFIG_PANEL_HDTV /* charlotte change permission S_IRUGO->S_IRWXUGO */
+static MANAGER_ATTR(display, S_IRWXUGO|S_IWUSR,
+		manager_display_show, manager_display_store);
+#else
 static MANAGER_ATTR(display, S_IRUGO|S_IWUSR,
 		manager_display_show, manager_display_store);
+#endif
 static MANAGER_ATTR(default_color, S_IRUGO|S_IWUSR,
 		manager_default_color_show, manager_default_color_store);
 static MANAGER_ATTR(trans_key_type, S_IRUGO|S_IWUSR,
diff --git a/drivers/video/omap2/dss/overlay.c b/drivers/video/omap2/dss/overlay.c
index 3652106..4e67394 100644
--- a/drivers/video/omap2/dss/overlay.c
+++ b/drivers/video/omap2/dss/overlay.c
@@ -263,16 +263,30 @@ struct overlay_attribute {
 	__ATTR(_name, _mode, _show, _store)
 
 static OVERLAY_ATTR(name, S_IRUGO, overlay_name_show, NULL);
+#ifdef CONFIG_PANEL_HDTV /* charlotte change permission S_IRUGO->S_IRWXUGO */
+static OVERLAY_ATTR(manager, S_IRWXUGO|S_IWUSR,
+		overlay_manager_show, overlay_manager_store);
+#else
 static OVERLAY_ATTR(manager, S_IRUGO|S_IWUSR,
 		overlay_manager_show, overlay_manager_store);
+#endif
 static OVERLAY_ATTR(input_size, S_IRUGO, overlay_input_size_show, NULL);
 static OVERLAY_ATTR(screen_width, S_IRUGO, overlay_screen_width_show, NULL);
+#ifdef CONFIG_PANEL_HDTV /* charlotte change permission S_IRUGO->S_IRWXUGO */
+static OVERLAY_ATTR(position, S_IRWXUGO|S_IWUSR,
+		overlay_position_show, overlay_position_store);
+static OVERLAY_ATTR(output_size, S_IRWXUGO|S_IWUSR,
+		overlay_output_size_show, overlay_output_size_store);
+static OVERLAY_ATTR(enabled, S_IRWXUGO|S_IWUSR,
+		overlay_enabled_show, overlay_enabled_store);
+#else
 static OVERLAY_ATTR(position, S_IRUGO|S_IWUSR,
 		overlay_position_show, overlay_position_store);
 static OVERLAY_ATTR(output_size, S_IRUGO|S_IWUSR,
 		overlay_output_size_show, overlay_output_size_store);
 static OVERLAY_ATTR(enabled, S_IRUGO|S_IWUSR,
 		overlay_enabled_show, overlay_enabled_store);
+#endif
 static OVERLAY_ATTR(global_alpha, S_IRUGO|S_IWUSR,
 		overlay_global_alpha_show, overlay_global_alpha_store);
 
@@ -372,6 +386,28 @@ int dss_check_overlay(struct omap_overlay *ovl, struct omap_dss_device *dssdev)
 			outh = info->out_height;
 	}
 
+#ifdef CONFIG_PANEL_HDTV /* BANG Hacked start */
+	if (info->out_width > dw || info->out_height > dh || info->width > dw || info->height > dh) {
+		printk(" The panel is changed from prev_dw,prev_dh=%d,%d to dw,dh\ = %d, %d \n",
+			info->out_width, info->out_height, dw, dh);
+		/* we start to switch panel */
+		if (dw < info->out_width) {
+			printk(" Overwrite overlay info for width \n");
+			info->out_width = dw;
+			info->width = dw;
+			outw = dw;
+		} 
+
+
+		if (dh < info->out_height) {
+			printk(" Overwrite overlay info for height \n");
+                        info->out_height = dh;
+			info->height = dh;
+                        outh = dh;				
+		}
+	}
+#endif /* BANG Hacked end */
+
 	if (dw < info->pos_x + outw) {
 		DSSDBG("check_overlay failed 1: %d < %d + %d\n",
 				dw, info->pos_x, outw);
diff --git a/drivers/video/omap2/omapfb/omapfb-sysfs.c b/drivers/video/omap2/omapfb/omapfb-sysfs.c
index ef30e0e..288a98f 100644
--- a/drivers/video/omap2/omapfb/omapfb-sysfs.c
+++ b/drivers/video/omap2/omapfb/omapfb-sysfs.c
@@ -463,9 +463,15 @@ static struct device_attribute omapfb_attrs[] = {
 			store_rotate_type),
 	__ATTR(mirror, S_IRUGO | S_IWUSR, show_mirror, store_mirror),
 	__ATTR(size, S_IRUGO | S_IWUSR, show_size, store_size),
+#ifdef CONFIG_PANEL_HDTV /* charlotte change permission S_IRUGO->S_IRWXUGO */
+	__ATTR(overlays, S_IRWXUGO | S_IWUSR, show_overlays, store_overlays),
+	__ATTR(overlays_rotate, S_IRWXUGO | S_IWUSR, show_overlays_rotate,
+			store_overlays_rotate),
+#else
 	__ATTR(overlays, S_IRUGO | S_IWUSR, show_overlays, store_overlays),
 	__ATTR(overlays_rotate, S_IRUGO | S_IWUSR, show_overlays_rotate,
 			store_overlays_rotate),
+#endif
 	__ATTR(phys_addr, S_IRUGO, show_phys, NULL),
 	__ATTR(virt_addr, S_IRUGO, show_virt, NULL),
 };
diff --git a/drivers/watchdog/omap_wdt.c b/drivers/watchdog/omap_wdt.c
index 2a673a2..caad365 100644
--- a/drivers/watchdog/omap_wdt.c
+++ b/drivers/watchdog/omap_wdt.c
@@ -576,9 +576,9 @@ static int omap_wdt_remove(struct platform_device *pdev)
  * may not play well enough with NOWAYOUT...
  */
 
-static int omap_wdt_suspend(struct platform_device *pdev, pm_message_t state)
+int omap_wdt_suspend(pm_message_t state)
 {
-	struct omap_wdt_dev *wdev = platform_get_drvdata(pdev);
+	struct omap_wdt_dev *wdev = platform_get_drvdata(omap_wdt_dev);
 
 #ifdef CONFIG_OMAP_WATCHDOG_CONTROL
 	if (CLOSE_WDT == cntrl_flag)
@@ -598,9 +598,9 @@ static int omap_wdt_suspend(struct platform_device *pdev, pm_message_t state)
 	return 0;
 }
 
-static int omap_wdt_resume(struct platform_device *pdev)
+int omap_wdt_resume(void)
 {
-	struct omap_wdt_dev *wdev = platform_get_drvdata(pdev);
+	struct omap_wdt_dev *wdev = platform_get_drvdata(omap_wdt_dev);
 
 #ifdef CONFIG_OMAP_WATCHDOG_CONTROL
 	if (CLOSE_WDT == cntrl_flag)
@@ -629,8 +629,10 @@ static struct platform_driver omap_wdt_driver = {
 	.probe		= omap_wdt_probe,
 	.remove		= omap_wdt_remove,
 	.shutdown	= omap_wdt_shutdown,
+/*
 	.suspend	= omap_wdt_suspend,
 	.resume		= omap_wdt_resume,
+*/
 	.driver		= {
 		.owner	= THIS_MODULE,
 		.name	= "omap_wdt",
diff --git a/fs/yaffs2/yaffs_guts.h b/fs/yaffs2/yaffs_guts.h
index d995617..5240581 100644
--- a/fs/yaffs2/yaffs_guts.h
+++ b/fs/yaffs2/yaffs_guts.h
@@ -558,7 +558,9 @@ struct yaffs_DeviceStruct {
 
 	int useHeaderFileSize;	/* Flag to determine if we should use file sizes from the header */
 
-	int emptyLostAndFound;  /* Flasg to determine if lst+found should be emptied on init */
+	int emptyLostAndFound;  /* Flasg to determine if lst+found should be
+				 * emptied on init
+				 */
 
 	int useNANDECC;		/* Flag to decide whether or not to use NANDECC */
 
diff --git a/include/linux/akm8973_akmd.h b/include/linux/akm8973_akmd.h
old mode 100755
new mode 100644
diff --git a/include/linux/earlysuspend.h b/include/linux/earlysuspend.h
old mode 100755
new mode 100644
diff --git a/include/linux/i2c/lp3907_i2c.h b/include/linux/i2c/lp3907_i2c.h
new file mode 100644
index 0000000..2563113
--- /dev/null
+++ b/include/linux/i2c/lp3907_i2c.h
@@ -0,0 +1,41 @@
+/*
+ * include/lp3907_i2c.h
+ *
+ * Configuration for LP3907 TDMB tuner regulator
+ */
+
+#ifndef __LINUX_LP3907_I2C_H
+#define __LINUX_LP3907_I2C_H
+
+#include <linux/ioctl.h>
+
+/*
+typedef struct {
+
+} __attribute__((packed)) lp3907_info;
+*/
+
+struct lp3907_platform_data {
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+};
+
+/* LP3907 indicator */
+#define LP3907_DRIVER_NAME 	     "lp3907"
+#define LP3907_DEVICE_NAME         "/dev/lp3907"
+
+/* ****************************************************************************
+ *   Command ID
+ * ************************************************************************** */
+
+#define LP3907_MAGIC    'l'
+
+#define LP3907_PWR_OFF_CMD          _IO(LP3907_MAGIC, 0)
+#define	LP3907_PWR_ON_CMD    	      _IO(LP3907_MAGIC, 1)
+
+#define LP3907_MAXNR                 2
+
+
+#endif /* __LINUX_LP3907_I2C_H */
diff --git a/include/linux/led-cpcap-lm3554.h b/include/linux/led-cpcap-lm3554.h
old mode 100755
new mode 100644
diff --git a/include/linux/led-lm3530.h b/include/linux/led-lm3530.h
old mode 100755
new mode 100644
index 5f30b26..f8069e3
--- a/include/linux/led-lm3530.h
+++ b/include/linux/led-lm3530.h
@@ -58,6 +58,11 @@
 #define LM3530_MANUAL_VALUE		0x64
 #define LM3530_SENSOR_ENABLE	0x08
 
+#define LM3530_MANUAL_RAMP_RATE_VALUE	0x1B
+
+#define LM3530_ALS_ZONE_MAX     0x4
+#define LM3530_ALS_ZONE_MIN     0x0
+
 #ifdef __KERNEL__
 struct lm3530_platform_data {
 	u8  power_up_gen_config;
diff --git a/include/linux/leds-bd7885.h b/include/linux/leds-bd7885.h
new file mode 100644
index 0000000..c463552
--- /dev/null
+++ b/include/linux/leds-bd7885.h
@@ -0,0 +1,122 @@
+/*
+ * include/leds-bd7885.h
+ *
+ * Configuration for BD7885 Flash driver
+ */
+
+#ifndef __LEDS_BD7885_H
+#define __LEDS_BD7885_H
+
+#include <linux/ioctl.h>
+
+/*This definition for Xenon flash driver.*/
+
+#define E_OK 0
+
+/* BD7885 indicator */
+#define BD7885_DRIVER_NAME 	     "bd7885"
+#define BD7885_DEVICE_NAME       "bd7885"
+
+#define BD7885_SLAVE_ADDR   (0x51)
+
+#define F_RDY_N_GPIO             36
+#define MAX_RETRY_CNT          (10)
+#define BD7885_REG_ADDR_LEN    (1)    /* 1 BYTE */
+#define BD7885_REG_DATA_LEN    (1)    /* 1 BYTE */
+#define BD7885_REG_ADDR_DATA_LEN    (2)    /* 2 BYTE */
+
+#define BD7885_MAX_RW_SIZE      (1)    /* 1 BYTE */
+
+#define BD7885_REG_ADDR_POS 0   /*Address position is first of array.*/
+#define BD7885_REG_DATA_POS 1   /*Data position is second of array.*/
+/* BD7885 control register map */
+
+/* BD7885 POWER STATUS */
+#define BD7885_INIT_STATUS	0
+#define BD7885_CHARGE_ENABLE_STATUS	1
+#define BD7885_CHARGE_DISABLE_STATUS 	2
+
+#define BD7885_REG_TERM 0xFF
+#define BD7885_VAL_TERM 0xFF
+
+#define BD7885_HW_ID_REG		0x00
+#define BD7885_HW_ID_VAL		0x01
+
+#define BD7885_DRVCNT_REG         0x01
+#define BD7885_PCNT_EN_MASK 0x1
+#define BD7885_CHG_EN_MASK 0x2
+
+#define BD7885_RECHG_REG           0x02
+#define BD7885_RECHG_EN_MASK 0x10
+
+#define BD7885_IPEAKADJ_REG      0x03
+
+#define BD7885_FULLADJ_REG        0x04
+#define BD7885_FULL_ADJ_LVL_MASK 0x0F
+
+#define BD7885_QUENCHCNT_REG   0x05
+
+#define BD7885_CAPDIS_EN_MASK  0x2
+#define BD7885_QUENCH_EN_MASK 0x1
+
+#define BD7885_QUENCH_ENABLE    0x1
+#define BD7885_QUENCH_DISABLE   0x0
+
+#define BD7885_DELAYADJ_REG      0x06
+
+#define BD7885_QUENCHADJ_REG   0x07
+#define BD7885_VSTOPADJ_SHIFT 0x3
+
+#define BD7885_STATUS_REG          0x08
+#define BD7885_STATUS_FULL_CHG_MASK 0x1
+#define BD7885_STATUS_QMON_MASK 0x2
+
+#define    BD7885_STROBE_OFF         0
+#define    BD7885_STROBE_QUENCH_MODE 1
+#define    BD7885_STROBE_MANUAL_MODE 2
+
+
+typedef enum {
+    BD7885_CHARGE_DISABLE = 0,
+    BD7885_CHARGE_ENABLE,
+} bd7885_charge_mode;
+
+typedef struct {
+	unsigned char reg;
+	unsigned char	   data;
+} bd7885_cfg;
+
+/* ****************************************************************************
+ *   Command ID
+ * ************************************************************************** */
+
+#define BD7885_IOCTL_BASE 42
+/** \def BD7885_IOCTL_*
+ *  \brief The following define the IOCTL command values via the ioctl macros
+ */
+/*Below direct register control is for exceptional case for HAL.*/
+#define BD7885_IOCTL_GET_REGISTER  _IOR(BD7885_IOCTL_BASE, 0, bd7885_cfg)
+		/*Register value read out from Xenon flash module.*/
+#define BD7885_IOCTL_SET_REGISTER  _IOW(BD7885_IOCTL_BASE, 1, bd7885_cfg)
+		/*Register value write down to Xenon flash module.*/
+#define BD7885_IOCTL_SET_CHARGING  _IOW(BD7885_IOCTL_BASE, 2, unsigned char)
+		/*Set charging status.*/
+
+#define BD7885_IOCTL_SET_CHARGE_LEVEL _IOW(BD7885_IOCTL_BASE, 3, unsigned char)
+		/*Set FULLADJ value for charging.*/
+#define BD7885_IOCTL_SET_MODE  _IOW(BD7885_IOCTL_BASE, 4, unsigned char)
+		/* 0=Off, 1= Quench mode, 2=Manual Mode */
+#define BD7885_IOCTL_SET_QUENCH_THRESHOLD \
+			_IOW(BD7885_IOCTL_BASE, 5, unsigned char)
+		/*Sets VSTOPADJ parameter.*/
+#define BD7885_IOCTL_GET_STATUS _IOR(BD7885_IOCTL_BASE, 6, unsigned char)
+		/*Charged status get.*/
+
+#define BD7885_IOCTL_READY_STROBE_MANUAL \
+			_IOW(BD7885_IOCTL_BASE, 7, unsigned char)
+		/* test ready strobe manually.*/
+#define BD7885_IOCTL_FIRE_STROBE_MANUAL \
+		_IOW(BD7885_IOCTL_BASE, 8, unsigned char)
+		/* test fire strobe manually.*/
+
+#endif /* __LEDS_BD7885_H */
diff --git a/include/linux/leds-bu9847.h b/include/linux/leds-bu9847.h
new file mode 100644
index 0000000..1aef720
--- /dev/null
+++ b/include/linux/leds-bu9847.h
@@ -0,0 +1,67 @@
+/*
+ * include/leds-bu9847.h
+ *
+ * Configuration for BU9847 Flash driver
+ */
+
+#ifndef __LEDS_BU9847_H
+#define __LEDS_BU9847_H
+
+#include <linux/ioctl.h>
+
+/*This definition for Xenon flash driver.*/
+
+#define E_OK 0
+
+/* BU9847 indicator */
+#define BU9847_DRIVER_NAME 	     "bu9847"
+#define BU9847_DEVICE_NAME            "bu9847"
+
+/*#define BU9847_SLAVE_ADDR   (0x50)*/ /*For P1 unit.*/
+#define BU9847_SLAVE_ADDR   (0x54) /*For P2 unit.*/
+
+#define MAX_RETRY_CNT          (10)
+#define BU9847_REG_ADDR_LEN    (1)    /* 1 BYTE */
+#define BU9847_REG_DATA_LEN    (1)    /* 1 BYTE */
+#define BU9847_REG_ADDR_DATA_LEN    (2)    /* 2 BYTE */
+
+#define BU9847_MAX_RW_SIZE      (1)    /* 1 BYTE */
+
+#define BU9847_REG_ADDR_POS 0   /*Address position is first of array.*/
+#define BU9847_REG_DATA_POS 1   /*Data position is second of array.*/
+/* BU9847 control register map */
+
+#define BU9847_REG_TERM 0xFF
+#define BU9847_VAL_TERM 0xFF
+
+#define BU9847_HW_ID_REG	    0x00
+#define BU9847_PRID1_REG         0x01
+#define BU9847_PRID2_REG         0x02
+#define BU9847_PRID3_REG         0x03
+
+#define BU9847_QCHC1_REG         0x04
+#define BU9847_QCHC2_REG         0x05
+#define BU9847_QCHC3_REG         0x06
+#define BU9847_QCHC4_REG         0x07
+#define BU9847_QCHC5_REG         0x08
+#define BU9847_QCHC6_REG         0x09
+#define BU9847_QCHC7_REG         0x0A
+#define BU9847_QCHC8_REG         0x0B
+#define BU9847_QCHC9_REG         0x0C
+#define BU9847_QCHC10_REG         0x0D
+#define BU9847_QCHC11_REG         0x0E
+#define BU9847_QCHC12_REG         0x0F
+
+#define BU9847_VCHGC_REG           0x10
+#define BU9847_PRLDT_REG           0x11
+
+/* ****************************************************************************
+ *   Command ID
+ * ************************************************************************** */
+
+#define BU9847_IOCTL_BASE 42
+
+/*Below direct register control is for exceptional case for HAL.*/
+#define BU9847_IOCTL_INIT                  _IO(BU9847_IOCTL_BASE, 20) /*Basic init for BU9847 device.*/
+
+#endif /* __LEDS_BU9847_H */
diff --git a/include/linux/leds-ld-cpcap.h b/include/linux/leds-ld-cpcap.h
old mode 100755
new mode 100644
index f2a9c2e..20d4073
--- a/include/linux/leds-ld-cpcap.h
+++ b/include/linux/leds-ld-cpcap.h
@@ -22,27 +22,34 @@
 #define LD_MSG_IND_DEV "notification-led"
 #define LD_DISP_BUTTON_DEV "button-backlight"
 #define LD_KPAD_DEV "keyboard-backlight"
+#define LD_AF_LED_DEV "af-led"
 #define LD_SUPPLY "sw5"
 
-#define LD_MSG_IND_ON			0x1
-#define LD_MSG_IND_CURRENT		0x2
+#define LD_MSG_IND_ON               0x1
+#define LD_MSG_IND_CURRENT          0x2
+#define LD_MSG_IND_LO_CURRENT       0x0
 
-#define LD_MSG_IND_CPCAP_MASK		0x3FF
+#define LD_MSG_IND_CPCAP_MASK       0x3FF
 
-#define LD_MSG_IND_LOW			0x20
-#define LD_MSG_IND_LOW_MED		0x20
-#define LD_MSG_IND_MEDIUM		0x30
-#define LD_MSG_IND_MED_HIGH		0x40
-#define LD_MSG_IND_HIGH			0x50
+#define LD_MSG_IND_LOW              0x10
+#define LD_MSG_IND_LOW_MED          0x20
+#define LD_MSG_IND_MEDIUM           0x30
+#define LD_MSG_IND_MED_HIGH         0x40
+#define LD_MSG_IND_HIGH             0x50
 
-#define LD_LED_RED		0x01
-#define LD_LED_GREEN	0x02
-#define LD_LED_BLUE		0x04
-  
+#define LD_LED_RED                  0x01
+#define LD_LED_GREEN                0x02
+#define LD_LED_BLUE                 0x04
 
-#define LD_DISP_BUTTON_ON		0x1
-#define LD_DISP_BUTTON_CURRENT		0xa
-#define LD_DISP_BUTTON_DUTY_CYCLE	0x2a0
+#define LD_DISP_BUTTON_ON           0x1
+#define LD_DISP_BUTTON_CURRENT      0xA
+#define LD_DISP_BUTTON_DUTY_CYCLE	0x2A0
 #define LD_DISP_BUTTON_CPCAP_MASK	0x3FF
 
+#define LD_BLED_CPCAP_DUTY_CYCLE    0xB8
+#define LD_BLED_CPCAP_MASK          0x3FF
+#define LD_BLED_CPCAP_CURRENT       0x0
+
+#define LD_ALT_ADBL_CURRENT         0x4
+
 #endif  /* __LED_LD_CPCAP_H__ */
diff --git a/include/linux/mipi_dli.h b/include/linux/mipi_dli.h
new file mode 100644
index 0000000..f20eca7
--- /dev/null
+++ b/include/linux/mipi_dli.h
@@ -0,0 +1,18 @@
+#ifndef __MIPI_DLI_H
+#define __MIPI_DLI_H
+
+#include <linux/ioctl.h>
+
+#define MIPI_DLI_DRIVER_NAME 	     "mipi_dli_tester"
+#define MIPI_DLI_DEVICE_NAME 	     "mipi_dli_tester"
+
+#define MIPI_DLI_IOCTL_BASE 88
+
+/* MIPI DLI Frame count.*/
+#define MIPI_DLI_IOCTL_FRAME_COUNT  _IOWR(MIPI_DLI_IOCTL_BASE, 0, unsigned long)
+/* MIPI DLI ECC count.*/
+#define MIPI_DLI_IOCTL_ECC_COUNT  _IOWR(MIPI_DLI_IOCTL_BASE, 1, unsigned long)
+/* MIPI DLI CRC count.*/
+#define MIPI_DLI_IOCTL_CRC_COUNT  _IOWR(MIPI_DLI_IOCTL_BASE, 2, unsigned long)
+
+#endif /*__MIPI_DLI_H*/
diff --git a/include/linux/mmc/sdio_func.h b/include/linux/mmc/sdio_func.h
old mode 100755
new mode 100644
diff --git a/include/linux/panel-suppliers.h b/include/linux/panel-suppliers.h
new file mode 100644
index 0000000..2c8012c
--- /dev/null
+++ b/include/linux/panel-suppliers.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2010 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+ * 02111-1307, USA
+ */
+
+#ifndef _LINUX_PANEL_SUPPLIERS_H__
+#define _LINUX_PANEL_SUPPLIERS_H__
+
+#define SUPPLIER_ID_AUO		0x0186
+#define SUPPLIER_ID_TMD		0x0126
+#define SUPPLIER_ID_INVALID	0xFFFF
+
+#endif /* _LINUX_PANEL_SUPPLIERS_H__ */
diff --git a/include/linux/qtouch_obp_ts.h b/include/linux/qtouch_obp_ts.h
index 1091b89..5a3e7e7 100644
--- a/include/linux/qtouch_obp_ts.h
+++ b/include/linux/qtouch_obp_ts.h
@@ -43,12 +43,23 @@ enum {
 	QTM_OBJ_TOUCH_KEYARRAY		= 15,
 	QTM_OBJ_PROCG_SIG_FILTER	= 16,
 	QTM_OBJ_PROCI_LINEAR_TBL	= 17,
-	QTM_OBJ_PROCI_GESTURES_PROC	= 18,
+	QTM_OBJ_SPT_COM_CONFIG		= 18,
+	QTM_OBJ_SPT_GPIO_PWM		= 19,
 	QTM_OBJ_PROCI_GRIPFACESUPPRESSION = 20,
-	QTM_OBJ_NOISESUPPRESSION_1 = 36,
+	QTM_OBJ_RESERVED3		= 21,
+	QTM_OBJ_PROCG_NOISE_SUPPRESSION	= 22,
+	QTM_OBJ_TOUCH_PROXIMITY		= 23,
+	QTM_OBJ_PROCI_ONE_TOUCH_GESTURE_PROC = 24,
+	QTM_OBJ_SPT_SELF_TEST		= 25,
+	QTM_OBJ_DEBUG_CTE_RANGE		= 26,
+	QTM_OBJ_PROCI_TWO_TOUCH_GESTURE_PROC = 27,
+	QTM_OBJ_SPT_CTE_CONFIG		= 28,
+	QTM_OBJ_NOISESUPPRESSION_1  = 36,
+	QTM_OBJ_DEBUG_DIAGNOSTIC         = 37,
+	QTM_OBJ_CPT_USERDATA             = 38,
 
 	/* Max number of objects currently defined */
-	QTM_OBP_MAX_OBJECT_NUM = QTM_OBJ_NOISESUPPRESSION_1 + 1,
+	QTM_OBP_MAX_OBJECT_NUM = QTM_OBJ_CPT_USERDATA + 1,
 };
 
 /* OBP structures as defined by the wire protocol. */
@@ -155,11 +166,13 @@ struct qtm_gen_power_cfg {
 /* GEN_ACQUIRECONFIG_T8 */
 struct qtm_gen_acquire_cfg {
 	uint8_t			charge_time;       /* in 250ns */
-	uint8_t			atouch_drift;      /* in 200ms */
+	uint8_t			reserve0;          /* Reserved */
 	uint8_t			touch_drift;       /* in 200ms */
 	uint8_t			drift_susp;        /* in 200ms */
 	uint8_t			touch_autocal;     /* in 200ms */
 	uint8_t			sync;
+	uint8_t			anti_cal_susp;
+	uint8_t			anti_cal_sthr;
 } __attribute__ ((packed));
 
 /* TOUCH_MULTITOUCHSCREEN_T9 */
@@ -173,22 +186,25 @@ struct qtm_touch_multi_cfg {
 	uint8_t			burst_len;
 	uint8_t			tch_det_thr;
 	uint8_t			tch_det_int;
-	uint8_t			rsvd1;
-	uint8_t			rsvd2;
+	uint8_t			orient;
+	uint8_t			mrg_to;
 	uint8_t			mov_hyst_init;
 	uint8_t			mov_hyst_next;
 	uint8_t			mov_filter;
 	uint8_t			num_touch;
 	uint8_t			merge_hyst;
 	uint8_t			merge_thresh;
-	uint8_t         amp_hyst;
+	uint8_t			amp_hyst;
 	uint16_t		x_res;
 	uint16_t		y_res;
 	uint8_t			x_low_clip;
 	uint8_t			x_high_clip;
 	uint8_t			y_low_clip;
 	uint8_t			y_high_clip;
-
+	uint8_t			x_edge_ori;
+	uint8_t			x_edge_cdist;
+	uint8_t			y_edge_ori;;
+	uint8_t			y_edge_cdist;
 } __attribute__ ((packed));
 
 /* TOUCH_KEYARRAY_T15 */
@@ -222,6 +238,32 @@ struct qtm_proci_linear_tbl_cfg {
 	uint8_t			y_segment[16];
 } __attribute__ ((packed));
 
+/* SPT_COM_CONFIG_T18 */
+struct qtm_spt_com_cfg {
+	uint8_t			ctrl;
+	uint8_t			cmd;
+} __attribute__ ((packed));
+
+/* SPT_GPIOPWM_T19*/
+struct qtm_spt_gpio_pwm_cfg {
+	uint8_t			ctrl;
+	uint8_t			report_mask;
+	uint8_t			pin_direction;
+	uint8_t			internal_pullup;
+	uint8_t			output_value;
+	uint8_t			wake_on_change;
+	uint8_t			pwm_enable;
+	uint8_t			pwm_period;
+	uint8_t			duty_cycle_0;
+	uint8_t			duty_cycle_1;
+	uint8_t			duty_cycle_2;
+	uint8_t			duty_cycle_3;
+	uint8_t			trigger_0;
+	uint8_t			trigger_1;
+	uint8_t			trigger_2;
+	uint8_t			trigger_3;
+} __attribute__ ((packed));
+
 /* PROCI_GRIPFACESUPPRESSION_T20 */
 struct qtm_proci_grip_suppression_cfg {
 	uint8_t			ctrl;
@@ -237,6 +279,72 @@ struct qtm_proci_grip_suppression_cfg {
 	uint8_t			shpthr2;
 } __attribute__ ((packed));
 
+/* PROCG_NOISESUPPRESSION_T22 */
+struct qtm_procg_noise_suppression_cfg {
+	uint8_t			ctrl;
+	uint16_t		reserve0;
+	uint16_t		gcaf_upper_limit;
+	uint16_t		gcaf_lower_limit;
+	uint8_t			gcaf_num_active;
+	uint8_t			noise_threshold;
+	uint8_t			reserve1;
+	uint8_t			freq_hop_scale;
+	uint8_t			burst_freq_0;
+	uint8_t			burst_freq_1;
+	uint8_t			burst_freq_2;
+	uint8_t			burst_freq_3;
+	uint8_t			burst_freq_4;
+	uint8_t			gcaf_num_idle;
+} __attribute__ ((packed));
+
+/* PROCI_ONETOUCHGESTUREPROCESSOR_T24 */
+struct qtm_proci_one_touch_gesture_proc_cfg {
+	uint8_t			ctrl;
+	uint8_t			reserve0;
+	uint16_t		gesture_enable;
+	uint8_t			pres_proc;
+	uint8_t			tap_time_out;
+	uint8_t			flick_time_out;
+	uint8_t			drag_time_out;
+	uint8_t			short_press_time_out;
+	uint8_t			long_press_time_out;
+	uint8_t			repeat_press_time_out;
+	uint16_t		flick_threshold;
+	uint16_t		drag_threshold;
+	uint16_t		tap_threshold;
+	uint16_t		throw_threshold;
+} __attribute__ ((packed));
+
+/* SPT_SELFTEST_T25 */
+struct qtm_spt_self_test_cfg {
+	uint8_t			ctrl;
+	uint8_t			command;
+	uint16_t		high_signal_limit_0;
+	uint16_t		low_signal_limit_0;
+	uint16_t		high_signal_limit_1;
+	uint16_t		low_signal_limit_1;
+} __attribute__ ((packed));
+
+/* PROCI_TWOTOUCHGESTUREPROCESSOR_T27 */
+struct qtm_proci_two_touch_gesture_proc_cfg {
+	uint8_t			ctrl;
+	uint8_t			reserved0;
+	uint8_t			reserved1;
+	uint8_t			gesture_enable;
+	uint8_t			rotate_threshold;
+	uint16_t		zoom_threshold;
+} __attribute__ ((packed));
+
+/* SPT_CTECONFIG_T28 */
+struct qtm_spt_cte_config_cfg {
+	uint8_t			ctrl;
+	uint8_t			command;
+	uint8_t			mode;
+	uint8_t			idle_gcaf_depth;
+	uint8_t			active_gcaf_depth;
+	uint8_t			voltage;
+} __attribute__ ((packed));
+
 /* QTM_OBJ_NOISESUPPRESSION_1 */
 struct qtm_proci_noise1_suppression_cfg {
 	uint8_t			ctrl;
@@ -245,14 +353,28 @@ struct qtm_proci_noise1_suppression_cfg {
 	uint8_t			duty_cycle;
 } __attribute__ ((packed));
 
+/* QTM_OBJ_CPT_USERDATA_T38 */
+struct qtm_spt_userdata {
+	uint8_t			data_0;
+	uint8_t			data_1;
+	uint8_t			data_2;
+	uint8_t			data_3;
+	uint8_t			data_4;
+	uint8_t			data_5;
+	uint8_t			data_6;
+	uint8_t			data_7;
+} __attribute__ ((packed));
+
 /*******************************/
 /******** platform data ********/
 /*******************************/
 
 struct vkey {
-	int	code;
-	int	min;
-	int	max;
+	int     code;
+	int     center_x;
+	int     center_y;
+	int     width;
+	int     height;
 };
 
 struct virt_keys {
@@ -293,8 +415,8 @@ struct qtouch_ts_platform_data {
 	uint32_t		abs_min_w;
 	uint32_t		abs_max_w;
 
-	uint32_t		x_delta;
-	uint32_t		y_delta;
+        uint32_t                x_delta;
+        uint32_t                y_delta;
 
 	uint16_t		nv_checksum;
 
@@ -317,8 +439,17 @@ struct qtouch_ts_platform_data {
 	struct qtm_touch_keyarray_cfg   key_array_cfg;
 	struct qtm_procg_sig_filter_cfg		sig_filter_cfg;
 	struct qtm_proci_linear_tbl_cfg		linear_tbl_cfg;
-	struct qtm_proci_grip_suppression_cfg	grip_suppression_cfg;
-	struct qtm_proci_noise1_suppression_cfg noise1_suppression_cfg;
+	struct qtm_proci_grip_suppression_cfg	    grip_suppression_cfg;
+	struct qtm_spt_com_cfg			        com_cfg;
+	struct qtm_spt_gpio_pwm_cfg			        gpio_pwm_cfg;
+	struct qtm_procg_noise_suppression_cfg	    noise_suppression_cfg;
+	struct qtm_proci_one_touch_gesture_proc_cfg	\
+					one_touch_gesture_proc_cfg;
+	struct qtm_spt_self_test_cfg			    self_test_cfg;
+	struct qtm_proci_two_touch_gesture_proc_cfg	two_touch_gesture_proc_cfg;
+	struct qtm_spt_cte_config_cfg			    cte_config_cfg;
+	struct qtm_proci_noise1_suppression_cfg     noise1_suppression_cfg;
+	struct qtm_spt_userdata     userdata;
 };
 
 #endif /* _LINUX_QTOUCH_OBP_TS_H */
diff --git a/include/linux/quickwakeup.h b/include/linux/quickwakeup.h
old mode 100755
new mode 100644
diff --git a/include/linux/sfh7743.h b/include/linux/sfh7743.h
old mode 100755
new mode 100644
diff --git a/include/linux/soundcard.h b/include/linux/soundcard.h
index 1904afe..b682b84 100644
--- a/include/linux/soundcard.h
+++ b/include/linux/soundcard.h
@@ -954,6 +954,9 @@ typedef unsigned char mixer_record[128];
 #define SOUND_MIXER_PRIVATE4		_SIOWR('M', 114, int)
 #define SOUND_MIXER_PRIVATE5		_SIOWR('M', 115, int)
 
+#define SOUND_MIXER_FMON            _SIOR('M', 120, int)
+#define SOUND_MIXER_FMOFF           _SIOR('M', 121, int)
+#define SOUND_MIXER_FMPATH          _SIOR('M', 122, int)
 /*
  * SOUND_MIXER_GETLEVELS and SOUND_MIXER_SETLEVELS calls can be used
  * for querying current mixer settings from the driver and for loading
diff --git a/include/linux/spi/cpcap.h b/include/linux/spi/cpcap.h
index 50245d7..44e19c6 100644
--- a/include/linux/spi/cpcap.h
+++ b/include/linux/spi/cpcap.h
@@ -606,6 +606,8 @@ struct cpcap_regacc {
 #define CPCAP_IOCTL_UC_MACRO_START \
 	_IOWR(0, CPCAP_IOCTL_NUM_UC_MACRO_START, enum cpcap_macro)
 
+/*#define CPCAP_AUDIO_REG_DEBUG*/
+
 #ifdef __KERNEL__
 struct cpcap_device {
 	struct spi_device	*spi;
@@ -686,5 +688,15 @@ int cpcap_uc_stop(struct cpcap_device *cpcap, enum cpcap_macro macro);
 
 unsigned char cpcap_uc_status(struct cpcap_device *cpcap,
 			      enum cpcap_macro macro);
+
+#if defined(CONFIG_LEDS_FLASH_RESET)
+int cpcap_direct_misc_write(unsigned short reg, unsigned short value,\
+							unsigned short mask);
+#endif
+
+#ifdef CPCAP_AUDIO_REG_DEBUG
+void cpcap_regacc_audio_reg_dump(void);
+#endif
+
 #endif /* __KERNEL__ */
 #endif /* _LINUX_SPI_CPCAP_H */
diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 68bb1c5..5026eed 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -803,4 +803,8 @@ spi_unregister_device(struct spi_device *spi)
 		device_unregister(&spi->dev);
 }
 
+#ifdef CONFIG_MOT_FEAT_SPI_SMS1130
+struct spi_device *spi_get_spi_device(char *modalias);
+#endif
+
 #endif /* __LINUX_SPI_H */
diff --git a/include/linux/wakelock.h b/include/linux/wakelock.h
old mode 100755
new mode 100644
diff --git a/kernel/power/main.c b/kernel/power/main.c
index 99bfb52..17e941f 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -27,6 +27,11 @@
 
 #include "power.h"
 
+#ifdef CONFIG_OMAP_WATCHDOG
+int omap_wdt_suspend(pm_message_t state);
+int omap_wdt_resume(void);
+#endif
+
 DEFINE_MUTEX(pm_mutex);
 
 unsigned int pm_flags;
@@ -292,6 +297,10 @@ static int _suspend_enter(suspend_state_t state)
 		goto Done;
 	}
 
+#ifdef CONFIG_OMAP_WATCHDOG
+	omap_wdt_suspend(PMSG_SUSPEND);
+#endif
+
 	error = sysdev_suspend(PMSG_SUSPEND);
 	if (!error) {
 		if (!suspend_test(TEST_CORE))
@@ -299,6 +308,10 @@ static int _suspend_enter(suspend_state_t state)
 		sysdev_resume();
 	}
 
+#ifdef CONFIG_OMAP_WATCHDOG
+	omap_wdt_resume();
+#endif
+
 	device_power_up(PMSG_RESUME);
  Done:
 
diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index c271728..7a1bc22 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -495,7 +495,7 @@ void hci_conn_enter_active_mode(struct hci_conn *conn)
 	if (test_bit(HCI_RAW, &hdev->flags))
 		return;
 
-	if (conn->mode != HCI_CM_SNIFF /* || !conn->power_save */)
+	if (conn->mode != HCI_CM_SNIFF /*|| !conn->power_save */)
 		goto timer;
 
 	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend)) {
diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c
index da2c3b8..07402b1 100644
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@ -34,11 +34,29 @@
  *
  */
 
+/*
+ * Copyright (C) 2009 Motorola, Inc.
+ */
+
+/*
+ * Author     Date          Comment
+ * =======   ===========   ====================================================
+ * Motorola  11/12/2009    Limit mss to be no bigger than 1372 to solve
+ *                         compatibility issue
+ */
+
+
 #include <net/tcp.h>
 
 #include <linux/compiler.h>
 #include <linux/module.h>
 
+/*
+ * Limit mss to be not bigger than 1372
+ * to solve compatibility issue
+ */
+#define TCP_MAX_SEGMENT_SIZE_LIMIT 1372
+
 /* People can turn this off for buggy TCP's found in printers etc. */
 int sysctl_tcp_retrans_collapse __read_mostly = 1;
 
@@ -113,6 +131,15 @@ static __u16 tcp_advertise_mss(struct sock *sk)
 	struct dst_entry *dst = __sk_dst_get(sk);
 	int mss = tp->advmss;
 
+	/*
+	 * Limit mss to be not bigger than 1372
+	 * to solve compatibility issue
+	 */
+	if (mss > TCP_MAX_SEGMENT_SIZE_LIMIT) {
+		mss = TCP_MAX_SEGMENT_SIZE_LIMIT;
+		tp->advmss = mss;
+	}
+
 	if (dst && dst_metric(dst, RTAX_ADVMSS) < mss) {
 		mss = dst_metric(dst, RTAX_ADVMSS);
 		tp->advmss = mss;
@@ -1021,6 +1048,13 @@ unsigned int tcp_sync_mss(struct sock *sk, u32 pmtu)
 	icsk->icsk_pmtu_cookie = pmtu;
 	if (icsk->icsk_mtup.enabled)
 		mss_now = min(mss_now, tcp_mtu_to_mss(sk, icsk->icsk_mtup.search_low));
+	/*
+	 * Limit mss to be not bigger than 1372
+	 * to solve compatiblity issue
+	 */
+	if (mss_now > TCP_MAX_SEGMENT_SIZE_LIMIT)
+		mss_now = TCP_MAX_SEGMENT_SIZE_LIMIT;
+
 	tp->mss_cache = mss_now;
 
 	return mss_now;
diff --git a/sound/oss/cpcap_audio_driver.c b/sound/oss/cpcap_audio_driver.c
old mode 100755
new mode 100644
diff --git a/sound/oss/moto_audio/cpcap_audio_driver.c b/sound/oss/moto_audio/cpcap_audio_driver.c
old mode 100755
new mode 100644
index 65b83ce..1d2d945
--- a/sound/oss/moto_audio/cpcap_audio_driver.c
+++ b/sound/oss/moto_audio/cpcap_audio_driver.c
@@ -509,6 +509,78 @@ static bool cpcap_audio_set_bits_for_speaker(int speaker, int balance,
 	return false; /* There is no external loudspeaker on this product */
 }
 
+static void cpcap_audio_set_output_amp(struct cpcap_audio_state *state)
+{
+  static unsigned int prev_aud_out_data;
+  bool activate_ext_loudspeaker = false;
+  struct cpcap_regacc reg_changes = { 0 };
+
+  activate_ext_loudspeaker = cpcap_audio_set_bits_for_speaker(
+					state->codec_primary_speaker,
+					state->codec_primary_balance,
+					&(reg_changes.value));
+
+  activate_ext_loudspeaker = activate_ext_loudspeaker ||
+					cpcap_audio_set_bits_for_speaker(
+					state->codec_secondary_speaker,
+					CPCAP_AUDIO_BALANCE_NEUTRAL,
+					&(reg_changes.value));
+
+  activate_ext_loudspeaker = activate_ext_loudspeaker ||
+					cpcap_audio_set_bits_for_speaker(
+					state->stdac_primary_speaker,
+					state->stdac_primary_balance,
+					&(reg_changes.value));
+
+  activate_ext_loudspeaker = activate_ext_loudspeaker ||
+					cpcap_audio_set_bits_for_speaker(
+					state->stdac_secondary_speaker,
+					CPCAP_AUDIO_BALANCE_NEUTRAL,
+					&(reg_changes.value));
+
+  activate_ext_loudspeaker = activate_ext_loudspeaker ||
+					cpcap_audio_set_bits_for_speaker(
+					state->ext_primary_speaker,
+					state->ext_primary_balance,
+					&(reg_changes.value));
+
+  activate_ext_loudspeaker = activate_ext_loudspeaker ||
+					cpcap_audio_set_bits_for_speaker(
+					state->ext_secondary_speaker,
+					CPCAP_AUDIO_BALANCE_NEUTRAL,
+					&(reg_changes.value));
+
+  reg_changes.mask = reg_changes.value | prev_aud_out_data;
+
+  prev_aud_out_data = reg_changes.value;
+
+  /* Charge pump should be enabled first and wait a minimum of 750 uSec
+		to allow for settling of the negative supply.
+  */
+	if ((reg_changes.mask & (CPCAP_BIT_HS_L_EN | CPCAP_BIT_HS_R_EN))) {
+		if (reg_changes.value
+			& (CPCAP_BIT_HS_L_EN | CPCAP_BIT_HS_R_EN)) {
+			cpcap_regacc_write(state->cpcap, CPCAP_REG_RXOA,
+			CPCAP_BIT_ST_HS_CP_EN, CPCAP_BIT_ST_HS_CP_EN);
+			mdelay(1);
+		}
+	}
+
+  logged_cpcap_write(state->cpcap, CPCAP_REG_RXOA,
+      reg_changes.value, reg_changes.mask);
+
+  /* When disabling HS output amp, HS_CP should be turned off after output
+		amp goes down. */
+	if ((reg_changes.mask & (CPCAP_BIT_HS_L_EN | CPCAP_BIT_HS_R_EN))) {
+		if (!(reg_changes.value
+			& (CPCAP_BIT_HS_L_EN | CPCAP_BIT_HS_R_EN))) {
+			mdelay(1);
+			cpcap_regacc_write(state->cpcap, CPCAP_REG_RXOA,
+				0, CPCAP_BIT_ST_HS_CP_EN);
+		}
+	}
+}
+
 static void cpcap_audio_configure_aud_mute(struct cpcap_audio_state *state,
 				struct cpcap_audio_state *prev_state)
 {
@@ -815,10 +887,55 @@ static void cpcap_audio_configure_input_gains(
 	}
 }
 
+/* In case of sholes tablet, FM radio use external pga.
+   FM radio have a different gain table. So we should set gain separately
+*/
+
+#define EXT_PGA_SPEAKER_OUT_GAIN         0x12
+#define EXT_PGA_HEADSET_OUT_GAIN         0x08
+
+
 static void cpcap_audio_configure_output_gains(
 	struct cpcap_audio_state *state,
 	struct cpcap_audio_state *previous_state)
 {
+/*	FM radio volume gain control routine is added by w21558
+*/
+#if 1
+	if (state->output_gain != previous_state->output_gain) {
+		struct cpcap_regacc reg_changes = { 0 };
+		unsigned int temp_output_gain = state->output_gain & 0x0000000F;
+		unsigned int ext_pag_output_gain = EXT_PGA_HEADSET_OUT_GAIN;
+		unsigned short prev_output_gain = 0;
+
+		if (state->output_gain == 0xFF) {
+			/* Only external PGA gain is changed */
+			int ret_val = 0;
+
+			ret_val = cpcap_regacc_read(state->cpcap,
+				CPCAP_REG_RXVC, &prev_output_gain);
+			prev_output_gain = (prev_output_gain & 0x00000F00) >> 8;
+
+			reg_changes.value |=
+			    ((prev_output_gain << 2) | (prev_output_gain << 8) |
+			     (ext_pag_output_gain << 12));
+		} else {
+
+			ext_pag_output_gain = (state->output_gain) ? \
+						EXT_PGA_HEADSET_OUT_GAIN : 0x00;
+
+		reg_changes.value |=
+		    ((temp_output_gain << 2) | (temp_output_gain << 8) |
+		     (ext_pag_output_gain << 12));
+		}
+
+		reg_changes.mask = 0xFF3C;
+
+		logged_cpcap_write(state->cpcap, CPCAP_REG_RXVC,
+				reg_changes.value, reg_changes.mask);
+	}
+#else
+
 	if (state->output_gain != previous_state->output_gain) {
 		struct cpcap_regacc reg_changes = { 0 };
 		unsigned int temp_output_gain = state->output_gain & 0x0000000F;
@@ -832,63 +949,29 @@ static void cpcap_audio_configure_output_gains(
 		logged_cpcap_write(state->cpcap, CPCAP_REG_RXVC,
 				reg_changes.value, reg_changes.mask);
 	}
+#endif
 }
 
 static void cpcap_audio_configure_output(
 	struct cpcap_audio_state *state,
-	struct cpcap_audio_state *previous_state)
+	struct cpcap_audio_state *previous_state,
+	bool speaker_off)
 {
-	static unsigned int prev_aud_out_data;
-
 	if (is_output_changed(previous_state, state) ||
 	    is_codec_changed(previous_state, state) ||
 	    is_stdac_changed(previous_state, state)) {
-		bool activate_ext_loudspeaker = false;
-		struct cpcap_regacc reg_changes = { 0 };
-
-		cpcap_audio_set_output_amp_switches(state);
-
-		activate_ext_loudspeaker = cpcap_audio_set_bits_for_speaker(
-						state->codec_primary_speaker,
-						 state->codec_primary_balance,
-						 &(reg_changes.value));
-
-		activate_ext_loudspeaker = activate_ext_loudspeaker ||
-					cpcap_audio_set_bits_for_speaker(
-						state->codec_secondary_speaker,
-						 CPCAP_AUDIO_BALANCE_NEUTRAL,
-						 &(reg_changes.value));
-
-		activate_ext_loudspeaker = activate_ext_loudspeaker ||
-					 cpcap_audio_set_bits_for_speaker(
-						state->stdac_primary_speaker,
-						 state->stdac_primary_balance,
-						 &(reg_changes.value));
-
-		activate_ext_loudspeaker = activate_ext_loudspeaker ||
-					cpcap_audio_set_bits_for_speaker(
-						state->stdac_secondary_speaker,
-						 CPCAP_AUDIO_BALANCE_NEUTRAL,
-						 &(reg_changes.value));
-
-		activate_ext_loudspeaker = activate_ext_loudspeaker ||
-					cpcap_audio_set_bits_for_speaker(
-						state->ext_primary_speaker,
-						 state->ext_primary_balance,
-						 &(reg_changes.value));
-
-		activate_ext_loudspeaker = activate_ext_loudspeaker ||
-					cpcap_audio_set_bits_for_speaker(
-						state->ext_secondary_speaker,
-						 CPCAP_AUDIO_BALANCE_NEUTRAL,
-						 &(reg_changes.value));
 
-		reg_changes.mask = reg_changes.value | prev_aud_out_data;
+		/* In case of turning on speaker, output amp switches should be
+			configured ahead of amp */
+		if (!speaker_off)
+			cpcap_audio_set_output_amp_switches(state);
 
-		prev_aud_out_data = reg_changes.value;
+		cpcap_audio_set_output_amp(state);
 
-		logged_cpcap_write(state->cpcap, CPCAP_REG_RXOA,
-				reg_changes.value, reg_changes.mask);
+		/* In case of turning off speaker, output amp should be turned
+			off ahead of amp switches */
+		if (speaker_off)
+			cpcap_audio_set_output_amp_switches(state);
 	}
 }
 
@@ -909,11 +992,13 @@ static void cpcap_audio_configure_input(
 		if (state->codec_mode == CPCAP_AUDIO_CODEC_LOOPBACK)
 			reg_changes.value |= CPCAP_BIT_DLM;
 
+#ifndef CONFIG_MACH_SHOLEST 
 		if (previous_state->microphone
 		    == CPCAP_AUDIO_IN_HEADSET) {
 			logged_cpcap_write(state->cpcap, CPCAP_REG_GPIO4,
 				     0, CPCAP_BIT_GPIO4DRV);
 		}
+#endif
 		switch (state->microphone) {
 		case CPCAP_AUDIO_IN_HANDSET:
 			reg_changes.value |= CPCAP_BIT_MB_ON1R
@@ -923,9 +1008,11 @@ static void cpcap_audio_configure_input(
 		case CPCAP_AUDIO_IN_HEADSET:
 			reg_changes.value |= CPCAP_BIT_HS_MIC_MUX
 				| CPCAP_BIT_MIC1_PGA_EN;
+#ifndef CONFIG_MACH_SHOLEST
 			logged_cpcap_write(state->cpcap, CPCAP_REG_GPIO4,
 					   CPCAP_BIT_GPIO4DRV,
 					   CPCAP_BIT_GPIO4DRV);
+#endif
 			break;
 
 		case CPCAP_AUDIO_IN_EXT_BUS:
@@ -994,39 +1081,10 @@ static void cpcap_audio_configure_power(int power)
 	}
 }
 
-static void cpcap_audio_register_dump(struct cpcap_audio_state *state)
-{
-	unsigned short reg_val = 0;
-
-	cpcap_regacc_read(state->cpcap, CPCAP_REG_VAUDIOC, &reg_val);
-	printk(KERN_INFO "0x200 = %x\n", reg_val);
-	cpcap_regacc_read(state->cpcap, CPCAP_REG_CC, &reg_val);
-	printk(KERN_INFO "0x201 = %x\n", reg_val);
-	cpcap_regacc_read(state->cpcap, CPCAP_REG_CDI, &reg_val);
-	printk(KERN_INFO "0x202 = %x\n", reg_val);
-	cpcap_regacc_read(state->cpcap, CPCAP_REG_SDAC, &reg_val);
-	printk(KERN_INFO "0x203 = %x\n", reg_val);
-	cpcap_regacc_read(state->cpcap, CPCAP_REG_SDACDI, &reg_val);
-	printk(KERN_INFO "0x204 = %x\n", reg_val);
-	cpcap_regacc_read(state->cpcap, CPCAP_REG_TXI, &reg_val);
-	printk(KERN_INFO "0x205 = %x\n", reg_val);
-	cpcap_regacc_read(state->cpcap, CPCAP_REG_TXMP, &reg_val);
-	printk(KERN_INFO "0x206 = %x\n", reg_val);
-	cpcap_regacc_read(state->cpcap, CPCAP_REG_RXOA, &reg_val);
-	printk(KERN_INFO "0x207 = %x\n", reg_val);
-	cpcap_regacc_read(state->cpcap, CPCAP_REG_RXVC, &reg_val);
-	printk(KERN_INFO "0x208 = %x\n", reg_val);
-	cpcap_regacc_read(state->cpcap, CPCAP_REG_RXCOA, &reg_val);
-	printk(KERN_INFO "0x209 = %x\n", reg_val);
-	cpcap_regacc_read(state->cpcap, CPCAP_REG_RXSDOA, &reg_val);
-	printk(KERN_INFO "0x20A = %x\n", reg_val);
-	cpcap_regacc_read(state->cpcap, CPCAP_REG_RXEPOA, &reg_val);
-	printk(KERN_INFO "0x20B = %x\n", reg_val);
-}
-
 void cpcap_audio_set_audio_state(struct cpcap_audio_state *state)
 {
 	struct cpcap_audio_state *previous_state = &previous_state_struct;
+	bool is_speaker_off = false;
 
 	if (state->codec_mute == CPCAP_AUDIO_CODEC_BYPASS_LOOP)
 		state->codec_mode = CPCAP_AUDIO_CODEC_ON;
@@ -1056,8 +1114,10 @@ void cpcap_audio_set_audio_state(struct cpcap_audio_state *state)
 		state->microphone != CPCAP_AUDIO_IN_BT_MONO))
 		cpcap_audio_configure_power(1);
 
-	if (is_speaker_turning_off(state, previous_state))
-		cpcap_audio_configure_output(state, previous_state);
+	is_speaker_off = is_speaker_turning_off(state, previous_state);
+	if (is_speaker_off)
+		cpcap_audio_configure_output(state, previous_state,
+						is_speaker_off);
 
 	if (is_codec_changed(state, previous_state)) {
 		int codec_mute = state->codec_mute;
@@ -1093,7 +1153,7 @@ void cpcap_audio_set_audio_state(struct cpcap_audio_state *state)
 
 	cpcap_audio_configure_input_gains(state, previous_state);
 
-	cpcap_audio_configure_output(state, previous_state);
+	cpcap_audio_configure_output(state, previous_state, is_speaker_off);
 
 	cpcap_audio_configure_output_gains(state, previous_state);
 
@@ -1111,8 +1171,6 @@ void cpcap_audio_set_audio_state(struct cpcap_audio_state *state)
 		cpcap_audio_configure_power(0);
 
 	previous_state_struct = *state;
-
-	cpcap_audio_register_dump(state);
 }
 
 void cpcap_audio_init(struct cpcap_audio_state *state)
@@ -1131,6 +1189,11 @@ void cpcap_audio_init(struct cpcap_audio_state *state)
 	logged_cpcap_write(state->cpcap, CPCAP_REG_RXSDOA, 0, 0x1FFF);
 	logged_cpcap_write(state->cpcap, CPCAP_REG_RXEPOA, 0, 0x7FFF);
 
+	/* Use free running clock for amplifiers */
+	logged_cpcap_write(state->cpcap, CPCAP_REG_A2LA,
+		CPCAP_BIT_A2_FREE_RUN,
+		CPCAP_BIT_A2_FREE_RUN);
+
 	logged_cpcap_write(state->cpcap, CPCAP_REG_GPIO4,
 			   CPCAP_BIT_GPIO4DIR, CPCAP_BIT_GPIO4DIR);
 
diff --git a/sound/oss/moto_audio/cpcap_audio_driver.h b/sound/oss/moto_audio/cpcap_audio_driver.h
index 0b567c7..063f7a6 100644
--- a/sound/oss/moto_audio/cpcap_audio_driver.h
+++ b/sound/oss/moto_audio/cpcap_audio_driver.h
@@ -24,7 +24,7 @@
 #include <linux/spi/cpcap-regbits.h>
 #include <linux/spi/cpcap.h>
 
-/*#define AUDIO_I2S_MODE*/
+#define AUDIO_I2S_MODE
 
 enum {
 	CPCAP_AUDIO_MODE_NORMAL,	/* mode of normal audio operation */
diff --git a/sound/oss/moto_audio/omap34xx_audio_driver.c b/sound/oss/moto_audio/omap34xx_audio_driver.c
old mode 100755
new mode 100644
index 9d53dce..938bd79
--- a/sound/oss/moto_audio/omap34xx_audio_driver.c
+++ b/sound/oss/moto_audio/omap34xx_audio_driver.c
@@ -291,7 +291,6 @@ static const struct sample_rate_info_t valid_sample_rates[] = {
 	{.rate = 48000, .cpcap_audio_rate = CPCAP_AUDIO_STDAC_RATE_48000_HZ},
 };
 
-static unsigned long flags;
 static int read_buf_full;
 static int primary_spkr_setting = CPCAP_AUDIO_OUT_NONE;
 static int secondary_spkr_setting = CPCAP_AUDIO_OUT_NONE;
@@ -1470,8 +1469,8 @@ static int audio_configure_ssi(struct inode *inode, struct file *file)
 		tx_params.word_length1 = OMAP_MCBSP_WORD_32;
 		ssi = STDAC_SSI;
 #ifdef AUDIO_I2S_MODE
-		tx_cfg_params.fs_polarity  = OMAP_MCBSP_FS_ACTIVE_LOW;
-		tx_cfg_params.phase = OMAP_MCBSP_FRAME_DUALPHASE;
+		/*tx_cfg_params.fs_polarity  = OMAP_MCBSP_FS_ACTIVE_LOW;*/
+		/*tx_cfg_params.phase = OMAP_MCBSP_FRAME_DUALPHASE;*/
 #endif
 		omap_ctrl_writel(omap_ctrl_readl(OMAP2_CONTROL_DEVCONF0) |
 					(1 << OMAP2_CONTROL_DEVCONF0_BIT6),
@@ -1786,6 +1785,41 @@ static int audio_ioctl(struct inode *inode, struct file *file,
 		break;
 	}
 
+	case SOUND_MIXER_FMPATH:
+		{
+			int spkr;
+			TRY(copy_from_user(&spkr, (int *)arg, sizeof(int)))
+			AUDIO_LEVEL2_LOG("SOUND_MIXER_FMPATH with spkr = %#x\n", spkr);
+			cpcap_audio_state.ext_primary_speaker = spkr;
+/* 	FM radio output gain is controlled by cpcap_audio_driver.c
+	So, this value should not be changed here.
+	This value should be synced other output gain value.
+*/
+			cpcap_audio_state.output_gain = 0xFF;
+			cpcap_audio_set_audio_state(&cpcap_audio_state);
+			break;
+		}
+
+	case SOUND_MIXER_FMON:
+		{
+			AUDIO_LEVEL2_LOG("SOUND_MIXER_FMON\n");
+			cpcap_audio_state.ext_primary_speaker = CPCAP_AUDIO_OUT_NONE;
+			cpcap_audio_state.analog_source =
+				CPCAP_AUDIO_ANALOG_SOURCE_STEREO;
+			cpcap_audio_set_audio_state(&cpcap_audio_state);
+			break;
+		}
+
+	case SOUND_MIXER_FMOFF:
+		{
+			AUDIO_LEVEL2_LOG("SOUND_MIXER_FMOFF\n");
+			cpcap_audio_state.ext_primary_speaker =	CPCAP_AUDIO_OUT_NONE;
+			cpcap_audio_state.ext_secondary_speaker =
+				CPCAP_AUDIO_OUT_NONE;
+			cpcap_audio_set_audio_state(&cpcap_audio_state);
+			break;
+		}
+
 	case SOUND_MIXER_RECSRC:
 	{
 		int mic;
@@ -1877,6 +1911,7 @@ static ssize_t audio_write(struct file *file, const char *buffer, size_t count,
 								loff_t *nouse)
 {
 	int chunksize, ret = 0;
+	unsigned long flags;
 	const char *buffer0 = buffer;
 	struct inode *inode = (struct inode *)file->private_data;
 	int minor = MINOR(inode->i_rdev);
@@ -1993,6 +2028,7 @@ static ssize_t audio_write(struct file *file, const char *buffer, size_t count,
 
 	if (buffer - buffer0)
 		ret = buffer - buffer0;
+
 out:
 	mutex_unlock(&audio_lock);
 	return ret;
diff --git a/sound/oss/omap34xx_audio_driver.c b/sound/oss/omap34xx_audio_driver.c
old mode 100755
new mode 100644
index 76b6173..7a87d44
--- a/sound/oss/omap34xx_audio_driver.c
+++ b/sound/oss/omap34xx_audio_driver.c
@@ -1886,7 +1886,6 @@ static ssize_t audio_write(struct file *file, const char *buffer, size_t count,
 	int minor = MINOR(inode->i_rdev);
 	struct audio_stream *str = (minor == state.dev_dsp) ?
 			state.stdac_out_stream : state.codec_out_stream;
-	unsigned long flags;
 
 	mutex_lock(&audio_lock);
 
@@ -1982,23 +1981,12 @@ static ssize_t audio_write(struct file *file, const char *buffer, size_t count,
 
 		buf->offset = 0;
 
-		/*
-		 * HACKHACKHACK
-		 *
-		 * Disabling IRQs works around a race accessing str between the
-		 * following code and the interrupt handler.  This should be
-		 * replaced with propper locking around access to any
-		 * audio_stream throughout the dirver.
-		 */
-
-		local_irq_save(flags);
 		if (++str->usr_head >= str->nbfrags)
 			str->usr_head = 0;
 
 		str->pending_frags++;
 
 		ret = audio_process_buf(str, inode);
-		local_irq_restore(flags);
 	}
 
 	if (buffer - buffer0)
-- 
1.7.8

